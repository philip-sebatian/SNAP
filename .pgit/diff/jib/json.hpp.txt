+0$#endif  // INCLUDE_NLOHMANN_JSON_HPP_
+0$
+0$
+0$
+0$#undef JSON_HEDLEY_FALL_THROUGH
+0$#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
+0$#undef JSON_HEDLEY_WARN_UNUSED_RESULT
+0$#undef JSON_HEDLEY_WARNING
+0$#undef JSON_HEDLEY_VERSION_ENCODE
+0$#undef JSON_HEDLEY_VERSION_DECODE_REVISION
+0$#undef JSON_HEDLEY_VERSION_DECODE_MINOR
+0$#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
+0$#undef JSON_HEDLEY_VERSION
+0$#undef JSON_HEDLEY_UNREACHABLE_RETURN
+0$#undef JSON_HEDLEY_UNREACHABLE
+0$#undef JSON_HEDLEY_UNPREDICTABLE
+0$#undef JSON_HEDLEY_UNLIKELY
+0$#undef JSON_HEDLEY_UNAVAILABLE
+0$#undef JSON_HEDLEY_TI_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_VERSION
+0$#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_CLPRU_VERSION
+0$#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_CL7X_VERSION
+0$#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_CL6X_VERSION
+0$#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_CL430_VERSION
+0$#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_CL2000_VERSION
+0$#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
+0$#undef JSON_HEDLEY_TI_ARMCL_VERSION
+0$#undef JSON_HEDLEY_TINYC_VERSION_CHECK
+0$#undef JSON_HEDLEY_TINYC_VERSION
+0$#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
+0$#undef JSON_HEDLEY_SUNPRO_VERSION
+0$#undef JSON_HEDLEY_STRINGIFY_EX
+0$#undef JSON_HEDLEY_STRINGIFY
+0$#undef JSON_HEDLEY_STATIC_CAST
+0$#undef JSON_HEDLEY_STATIC_ASSERT
+0$#undef JSON_HEDLEY_SENTINEL
+0$#undef JSON_HEDLEY_RETURNS_NON_NULL
+0$#undef JSON_HEDLEY_RESTRICT
+0$#undef JSON_HEDLEY_REQUIRE_MSG
+0$#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
+0$#undef JSON_HEDLEY_REQUIRE
+0$#undef JSON_HEDLEY_REINTERPRET_CAST
+0$#undef JSON_HEDLEY_PURE
+0$#undef JSON_HEDLEY_PUBLIC
+0$#undef JSON_HEDLEY_PRIVATE
+0$#undef JSON_HEDLEY_PRINTF_FORMAT
+0$#undef JSON_HEDLEY_PREDICT
+0$#undef JSON_HEDLEY_PGI_VERSION_CHECK
+0$#undef JSON_HEDLEY_PGI_VERSION
+0$#undef JSON_HEDLEY_PELLES_VERSION_CHECK
+0$#undef JSON_HEDLEY_PELLES_VERSION
+0$#undef JSON_HEDLEY_NULL
+0$#undef JSON_HEDLEY_NO_THROW
+0$#undef JSON_HEDLEY_NO_RETURN
+0$#undef JSON_HEDLEY_NO_ESCAPE
+0$#undef JSON_HEDLEY_NON_NULL
+0$#undef JSON_HEDLEY_NEVER_INLINE
+0$#undef JSON_HEDLEY_MSVC_VERSION_CHECK
+0$#undef JSON_HEDLEY_MSVC_VERSION
+0$#undef JSON_HEDLEY_MESSAGE
+0$#undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
+0$#undef JSON_HEDLEY_MCST_LCC_VERSION
+0$#undef JSON_HEDLEY_MALLOC
+0$#undef JSON_HEDLEY_LIKELY
+0$#undef JSON_HEDLEY_IS_CONSTEXPR_
+0$#undef JSON_HEDLEY_IS_CONSTANT
+0$#undef JSON_HEDLEY_INTEL_VERSION_CHECK
+0$#undef JSON_HEDLEY_INTEL_VERSION
+0$#undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
+0$#undef JSON_HEDLEY_INTEL_CL_VERSION
+0$#undef JSON_HEDLEY_INLINE
+0$#undef JSON_HEDLEY_IMPORT
+0$#undef JSON_HEDLEY_IBM_VERSION_CHECK
+0$#undef JSON_HEDLEY_IBM_VERSION
+0$#undef JSON_HEDLEY_IAR_VERSION_CHECK
+0$#undef JSON_HEDLEY_IAR_VERSION
+0$#undef JSON_HEDLEY_HAS_WARNING
+0$#undef JSON_HEDLEY_HAS_FEATURE
+0$#undef JSON_HEDLEY_HAS_EXTENSION
+0$#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
+0$#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
+0$#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
+0$#undef JSON_HEDLEY_HAS_BUILTIN
+0$#undef JSON_HEDLEY_HAS_ATTRIBUTE
+0$#undef JSON_HEDLEY_GNUC_VERSION_CHECK
+0$#undef JSON_HEDLEY_GNUC_VERSION
+0$#undef JSON_HEDLEY_GNUC_HAS_WARNING
+0$#undef JSON_HEDLEY_GNUC_HAS_FEATURE
+0$#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
+0$#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
+0$#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
+0$#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
+0$#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
+0$#undef JSON_HEDLEY_GCC_VERSION_CHECK
+0$#undef JSON_HEDLEY_GCC_VERSION
+0$#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
+0$#undef JSON_HEDLEY_GCC_HAS_WARNING
+0$#undef JSON_HEDLEY_GCC_HAS_FEATURE
+0$#undef JSON_HEDLEY_GCC_HAS_EXTENSION
+0$#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
+0$#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
+0$#undef JSON_HEDLEY_GCC_HAS_BUILTIN
+0$#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
+0$#undef JSON_HEDLEY_FLAGS_CAST
+0$#undef JSON_HEDLEY_FLAGS
+0$#undef JSON_HEDLEY_END_C_DECLS
+0$#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
+0$#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
+0$#undef JSON_HEDLEY_EMPTY_BASES
+0$#undef JSON_HEDLEY_DMC_VERSION_CHECK
+0$#undef JSON_HEDLEY_DMC_VERSION
+0$#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
+0$#undef JSON_HEDLEY_DIAGNOSTIC_POP
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
+0$#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+0$#undef JSON_HEDLEY_DEPRECATED_FOR
+0$#undef JSON_HEDLEY_DEPRECATED
+0$#undef JSON_HEDLEY_C_DECL
+0$#undef JSON_HEDLEY_CRAY_VERSION_CHECK
+0$#undef JSON_HEDLEY_CRAY_VERSION
+0$#undef JSON_HEDLEY_CPP_CAST
+0$#undef JSON_HEDLEY_CONST_CAST
+0$#undef JSON_HEDLEY_CONSTEXPR
+0$#undef JSON_HEDLEY_CONST
+0$#undef JSON_HEDLEY_CONCAT_EX
+0$#undef JSON_HEDLEY_CONCAT3_EX
+0$#undef JSON_HEDLEY_CONCAT3
+0$#undef JSON_HEDLEY_CONCAT
+0$#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
+0$#undef JSON_HEDLEY_COMPCERT_VERSION
+0$#undef JSON_HEDLEY_CLANG_HAS_WARNING
+0$#undef JSON_HEDLEY_CLANG_HAS_FEATURE
+0$#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
+0$#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
+0$#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
+0$#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
+0$#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
+0$#undef JSON_HEDLEY_BEGIN_C_DECLS
+0$#undef JSON_HEDLEY_ASSUME
+0$#undef JSON_HEDLEY_ARRAY_PARAM
+0$#undef JSON_HEDLEY_ARM_VERSION_CHECK
+0$#undef JSON_HEDLEY_ARM_VERSION
+0$#undef JSON_HEDLEY_ALWAYS_INLINE
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
+0$
+0$#endif
+0$    #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
+0$    #undef JSON_HAS_STATIC_RTTI
+0$    #undef JSON_HAS_RANGES
+0$    #undef JSON_HAS_THREE_WAY_COMPARISON
+0$    #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$    #undef JSON_HAS_FILESYSTEM
+0$    #undef JSON_HAS_CPP_20
+0$    #undef JSON_HAS_CPP_17
+0$    #undef JSON_HAS_CPP_14
+0$    #undef JSON_HAS_CPP_11
+0$    #undef JSON_TRY
+0$    #undef JSON_CATCH
+0$#ifndef JSON_TEST_KEEP_MACROS
+0$
+0$#undef JSON_USE_GLOBAL_UDLS
+0$#undef JSON_DISABLE_ENUM_SERIALIZATION
+0$#undef JSON_NO_UNIQUE_ADDRESS
+0$#undef JSON_INLINE_VARIABLE
+0$#undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
+0$#undef JSON_EXPLICIT
+0$#undef NLOHMANN_BASIC_JSON_TPL
+0$#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$#undef JSON_PRIVATE_UNLESS_TESTED
+0$#undef JSON_THROW
+0$#undef JSON_INTERNAL_CATCH
+0$#undef JSON_ASSERT
+0$// clean up
+0$
+0$#endif
+0$    #pragma clang diagnostic pop
+0$#if defined(__clang__)
+0$// restore clang diagnostic settings
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/macro_unscope.hpp>
+0$
+0$#endif
+0$    #endif
+0$        using nlohmann::literals::json_literals::operator "" _json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
+0$        using nlohmann::literals::json_literals::operator "" _json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
+0$    #else
+0$        using nlohmann::literals::json_literals::operator ""_json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
+0$        using nlohmann::literals::json_literals::operator ""_json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
+0$    #if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
+0$#if JSON_USE_GLOBAL_UDLS
+0$
+0$}  // namespace std
+0$
+0$#endif
+0$
+0$}
+0$    j1.swap(j2);
+0${
+0$    is_nothrow_move_assignable<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value)
+0$    is_nothrow_move_constructible<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value&&                          // NOLINT(misc-redundant-expression,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL& j1, nlohmann::NLOHMANN_BASIC_JSON_TPL& j2) noexcept(  // NOLINT(readability-inconsistent-declaration-parameter-name, cert-dcl58-cpp)
+0$NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$/// @sa https://json.nlohmann.me/api/basic_json/std_swap/
+0$/// @brief exchanges the values of two JSON objects
+0$
+0$#ifndef JSON_HAS_CPP_20
+0$// C++20 prohibit function specialization in the std namespace.
+0$
+0$};
+0$    }
+0$#endif
+0$        return ::nlohmann::detail::operator<(lhs, rhs);
+0$#else
+0$        return std::is_lt(lhs <=> rhs); // *NOPAD*
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$    {
+0$                    ::nlohmann::detail::value_t rhs) const noexcept
+0$    bool operator()(::nlohmann::detail::value_t lhs,
+0$    */
+0$    @since version 3.0.0
+0$    @brief compare two value_t enum values
+0$    /*!
+0${
+0$struct less< ::nlohmann::detail::value_t> // do not remove the space after '<', see https://github.com/nlohmann/json/pull/679
+0$template<>
+0$// specialization for std::less<value_t>
+0$
+0$};
+0$    }
+0$        return nlohmann::detail::hash(j);
+0$    {
+0$    std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL& j) const
+0${
+0$struct hash<nlohmann::NLOHMANN_BASIC_JSON_TPL> // NOLINT(cert-dcl58-cpp)
+0$NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$/// @sa https://json.nlohmann.me/api/basic_json/std_hash/
+0$/// @brief hash value for JSON objects
+0$
+0${
+0$namespace std // NOLINT(cert-dcl58-cpp)
+0$
+0$///////////////////////
+0$// nonmember support //
+0$///////////////////////
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace literals
+0$}  // namespace json_literals
+0$
+0$}
+0$    return nlohmann::json::json_pointer(std::string(s, n));
+0${
+0$#endif
+0$    inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
+0$#else
+0$    inline nlohmann::json::json_pointer operator ""_json_pointer(const char* s, std::size_t n)
+0$#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
+0$JSON_HEDLEY_NON_NULL(1)
+0$/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json_pointer/
+0$/// @brief user-defined string literal for JSON pointer
+0$
+0$}
+0$    return nlohmann::json::parse(s, s + n);
+0${
+0$#endif
+0$    inline nlohmann::json operator "" _json(const char* s, std::size_t n)
+0$#else
+0$    inline nlohmann::json operator ""_json(const char* s, std::size_t n)
+0$#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
+0$JSON_HEDLEY_NON_NULL(1)
+0$/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json/
+0$/// @brief user-defined string literal for JSON values
+0$
+0${
+0$inline namespace json_literals
+0${
+0$inline namespace literals
+0$
+0$}
+0$    return j.dump();
+0${
+0$std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
+0$NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$/// @sa https://json.nlohmann.me/api/basic_json/to_string/
+0$/// @brief user-defined to_string function for JSON values
+0$
+0$};
+0$    /// @}
+0$
+0$    }
+0$        }
+0$            *this = apply_patch;
+0$        {
+0$        else
+0$        }
+0$            }
+0$                }
+0$                    operator[](it.key()).merge_patch(it.value());
+0$                {
+0$                else
+0$                }
+0$                    erase(it.key());
+0$                {
+0$                if (it.value().is_null())
+0$            {
+0$            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
+0$            }
+0$                *this = object();
+0$            {
+0$            if (!is_object())
+0$        {
+0$        if (apply_patch.is_object())
+0$    {
+0$    void merge_patch(const basic_json& apply_patch)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/merge_patch/
+0$    /// @brief applies a JSON Merge Patch
+0$
+0$    /// @{
+0$    /// @name JSON Merge Patch functions
+0$
+0$    ////////////////////////////////
+0$    // JSON Merge Patch functions //
+0$    ////////////////////////////////
+0$
+0$    /// @}
+0$    }
+0$        return result;
+0$
+0$        }
+0$            }
+0$                break;
+0$                });
+0$                    {"op", "replace"}, {"path", path}, {"value", target}
+0$                {
+0$                result.push_back(
+0$                // both primitive type: replace value
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$
+0$                }
+0$                    }
+0$                        });
+0$                            {"value", it.value()}
+0$                            {"op", "add"}, {"path", path_key},
+0$                        {
+0$                        result.push_back(
+0$                        const auto path_key = detail::concat(path, '/', detail::escape(it.key()));
+0$                        // found a key that is not in this -> add it
+0$                    {
+0$                    if (source.find(it.key()) == source.end())
+0$                {
+0$                for (auto it = target.cbegin(); it != target.cend(); ++it)
+0$                // second pass: traverse other object's elements
+0$
+0$                }
+0$                    }
+0$                        }));
+0$                            {"op", "remove"}, {"path", path_key}
+0$                        {
+0$                        result.push_back(object(
+0$                        // found a key that is not in o -> remove it
+0$                    {
+0$                    else
+0$                    }
+0$                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
+0$                        auto temp_diff = diff(it.value(), target[it.key()], path_key);
+0$                        // recursive call to compare object values at key it
+0$                    {
+0$                    if (target.find(it.key()) != target.end())
+0$
+0$                    const auto path_key = detail::concat(path, '/', detail::escape(it.key()));
+0$                    // escape the key name to be used in a JSON patch
+0$                {
+0$                for (auto it = source.cbegin(); it != source.cend(); ++it)
+0$                // first pass: traverse this object's elements
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$
+0$                }
+0$                    ++i;
+0$                    });
+0$                        {"value", target[i]}
+0$                        {"path", detail::concat(path, "/-")},
+0$                        {"op", "add"},
+0$                    {
+0$                    result.push_back(
+0$                {
+0$                while (i < target.size())
+0$                // add other remaining elements
+0$
+0$                }
+0$                    ++i;
+0$                    }));
+0$                        {"path", detail::concat(path, '/', std::to_string(i))}
+0$                        {"op", "remove"},
+0$                    {
+0$                    result.insert(result.begin() + end_index, object(
+0$                    // indices
+0$                    // add operations in reverse order to avoid invalid
+0$                {
+0$                while (i < source.size())
+0$                const auto end_index = static_cast<difference_type>(result.size());
+0$                // remove my remaining elements
+0$
+0$                // in a second pass, traverse the remaining elements
+0$                // We now reached the end of at least one array
+0$
+0$                }
+0$                    ++i;
+0$                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
+0$                    auto temp_diff = diff(source[i], target[i], detail::concat(path, '/', std::to_string(i)));
+0$                    // recursive call to compare array values at index i
+0$                {
+0$                while (i < source.size() && i < target.size())
+0$                std::size_t i = 0;
+0$                // first pass: traverse common elements
+0$            {
+0$            case value_t::array:
+0$        {
+0$        switch (source.type())
+0$
+0$        }
+0$            return result;
+0$            });
+0$                {"op", "replace"}, {"path", path}, {"value", target}
+0$            {
+0$            result.push_back(
+0$            // different types: replace value
+0$        {
+0$        if (source.type() != target.type())
+0$
+0$        }
+0$            return result;
+0$        {
+0$        if (source == target)
+0$        // if the values are the same, return empty patch
+0$
+0$        basic_json result(value_t::array);
+0$        // the patch
+0$    {
+0$                           const std::string& path = "")
+0$    static basic_json diff(const basic_json& source, const basic_json& target,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/diff/
+0$    /// @brief creates a diff as a JSON patch
+0$
+0$    }
+0$        return result;
+0$        result.patch_inplace(json_patch);
+0$        basic_json result = *this;
+0$    {
+0$    basic_json patch(const basic_json& json_patch) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/patch/
+0$    /// @brief applies a JSON patch to a copy of the current object
+0$
+0$    }
+0$        }
+0$            }
+0$                }
+0$                    JSON_THROW(parse_error::create(105, 0, detail::concat("operation value '", op, "' is invalid"), &val));
+0$                    // "test"
+0$                    // op must be "add", "remove", "replace", "move", "copy", or
+0$                {
+0$                default:
+0$                case patch_operations::invalid:
+0$
+0$                }
+0$                    break;
+0$
+0$                    }
+0$                        JSON_THROW(other_error::create(501, detail::concat("unsuccessful: ", val.dump()), &val));
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!success))
+0$                    // throw an exception if test fails
+0$
+0$                    }
+0$                        // ignore out of range errors: success remains false
+0$                    {
+0$                    JSON_INTERNAL_CATCH (out_of_range&)
+0$                    }
+0$                        success = (result.at(ptr) == get_value("test", "value", false));
+0$                        // the "path" location must exist - use at()
+0$                        // check if "value" matches the one at "path"
+0$                    {
+0$                    JSON_TRY
+0$                    bool success = false;
+0$                {
+0$                case patch_operations::test:
+0$
+0$                }
+0$                    break;
+0$                    operation_add(ptr, v);
+0$                    // specified in the "from" member.
+0$                    // operation at the target location using the value
+0$                    // The copy is functionally identical to an "add"
+0$
+0$                    basic_json const v = result.at(from_ptr);
+0$                    // the "from" location must exist - use at()
+0$
+0$                    const json_pointer from_ptr(from_path);
+0$                    const auto from_path = get_value("copy", "from", true).template get<std::string>();
+0$                {
+0$                case patch_operations::copy:
+0$
+0$                }
+0$                    break;
+0$                    operation_add(ptr, v);
+0$                    operation_remove(from_ptr);
+0$                    // location with the value that was just removed.
+0$                    // immediately by an "add" operation at the target
+0$                    // "remove" operation on the "from" location, followed
+0$                    // The move operation is functionally identical to a
+0$
+0$                    basic_json const v = result.at(from_ptr);
+0$                    // the "from" location must exist - use at()
+0$
+0$                    json_pointer from_ptr(from_path);
+0$                    const auto from_path = get_value("move", "from", true).template get<std::string>();
+0$                {
+0$                case patch_operations::move:
+0$
+0$                }
+0$                    break;
+0$                    result.at(ptr) = get_value("replace", "value", false);
+0$                    // the "path" location must exist - use at()
+0$                {
+0$                case patch_operations::replace:
+0$
+0$                }
+0$                    break;
+0$                    operation_remove(ptr);
+0$                {
+0$                case patch_operations::remove:
+0$
+0$                }
+0$                    break;
+0$                    operation_add(ptr, get_value("add", "value", false));
+0$                {
+0$                case patch_operations::add:
+0$            {
+0$            switch (get_op(op))
+0$
+0$            json_pointer ptr(path);
+0$            const auto path = get_value(op, "path", true).template get<std::string>();
+0$            const auto op = get_value("op", "op", true).template get<std::string>();
+0$            // collect mandatory members
+0$
+0$            }
+0$                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &val));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
+0$            // type check: every element of the array must be an object
+0$
+0$            };
+0$                return it->second;
+0$                // no error: return value
+0$
+0$                }
+0$                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have string member '", member, "'"), &val));
+0$                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
+0$                // check if result is of type string
+0$
+0$                }
+0$                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have member '", member, "'"), &val));
+0$                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(it == val.m_data.m_value.object->end()))
+0$                // check if desired value is present
+0$
+0$                const auto error_msg = (op == "op") ? "operation" : detail::concat("operation '", op, '\''); // NOLINT(bugprone-unused-local-non-trivial-variable)
+0$                // context-sensitive error message
+0$
+0$                auto it = val.m_data.m_value.object->find(member);
+0$                // find value
+0$            {
+0$                                          bool string_type) -> basic_json &
+0$                                          const std::string & member,
+0$            const auto get_value = [&val](const std::string & op,
+0$            // wrapper to get a value for an operation
+0$        {
+0$        for (const auto& val : json_patch)
+0$        // iterate and apply the operations
+0$
+0$        }
+0$            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &json_patch));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
+0$        // type check: top level value must be an array
+0$
+0$        };
+0$            }
+0$                parent.erase(json_pointer::template array_index<basic_json_t>(last_path));
+0$                // note erase performs range check
+0$            {
+0$            else if (parent.is_array())
+0$            }
+0$                }
+0$                    JSON_THROW(out_of_range::create(403, detail::concat("key '", last_path, "' not found"), this));
+0$                {
+0$                else
+0$                }
+0$                    parent.erase(it);
+0$                {
+0$                if (JSON_HEDLEY_LIKELY(it != parent.end()))
+0$                auto it = parent.find(last_path);
+0$                // perform range check
+0$            {
+0$            if (parent.is_object())
+0$            // remove child
+0$
+0$            basic_json& parent = result.at(ptr);
+0$            ptr.pop_back();
+0$            const auto last_path = ptr.back();
+0$            // get reference to parent of JSON pointer ptr
+0$        {
+0$        const auto operation_remove = [this, & result](json_pointer & ptr)
+0$        // wrapper for "remove" operation; remove value at ptr
+0$
+0$        };
+0$            }
+0$                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$                default:            // LCOV_EXCL_LINE
+0$                case value_t::discarded: // LCOV_EXCL_LINE
+0$                case value_t::binary: // LCOV_EXCL_LINE
+0$                case value_t::number_float: // LCOV_EXCL_LINE
+0$                case value_t::number_unsigned: // LCOV_EXCL_LINE
+0$                case value_t::number_integer: // LCOV_EXCL_LINE
+0$                case value_t::boolean: // LCOV_EXCL_LINE
+0$                case value_t::string: // LCOV_EXCL_LINE
+0$                // if there exists a parent it cannot be primitive
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
+0$                        // default case: insert add offset
+0$
+0$                        }
+0$                            JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), &parent));
+0$                            // avoid undefined behavior
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
+0$                        const auto idx = json_pointer::template array_index<basic_json_t>(last_path);
+0$                    {
+0$                    else
+0$                    }
+0$                        parent.push_back(val);
+0$                        // special case: append to back
+0$                    {
+0$                    if (last_path == "-")
+0$                {
+0$                case value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    parent[last_path] = val;
+0$                    // use operator[] to add value
+0$                {
+0$                case value_t::object:
+0$                case value_t::null:
+0$            {
+0$            switch (parent.m_data.m_type)
+0$
+0$            basic_json& parent = result.at(ptr);
+0$            // parent must exist when performing patch add per RFC6902 specs
+0$            ptr.pop_back();
+0$            const auto last_path = ptr.back();
+0$            // get reference to parent of JSON pointer ptr
+0$
+0$            }
+0$                result.at(top_pointer);
+0$            {
+0$            if (top_pointer != ptr)
+0$            json_pointer const top_pointer = ptr.top();
+0$            // make sure the top element of the pointer exists
+0$
+0$            }
+0$                return;
+0$                result = val;
+0$            {
+0$            if (ptr.empty())
+0$            // adding to the root of the target document means replacing it
+0$        {
+0$        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
+0$        // wrapper for "add" operation; add value at ptr
+0$
+0$        };
+0$            return patch_operations::invalid;
+0$
+0$            }
+0$                return patch_operations::test;
+0$            {
+0$            if (op == "test")
+0$            }
+0$                return patch_operations::copy;
+0$            {
+0$            if (op == "copy")
+0$            }
+0$                return patch_operations::move;
+0$            {
+0$            if (op == "move")
+0$            }
+0$                return patch_operations::replace;
+0$            {
+0$            if (op == "replace")
+0$            }
+0$                return patch_operations::remove;
+0$            {
+0$            if (op == "remove")
+0$            }
+0$                return patch_operations::add;
+0$            {
+0$            if (op == "add")
+0$        {
+0$        const auto get_op = [](const std::string & op)
+0$
+0$        enum class patch_operations {add, remove, replace, move, copy, test, invalid};
+0$        // the valid JSON Patch operations
+0$        basic_json& result = *this;
+0$    {
+0$    void patch_inplace(const basic_json& json_patch)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/patch/
+0$    /// @brief applies a JSON patch in-place without copying the object
+0$
+0$    /// @{
+0$    /// @name JSON Patch functions
+0$
+0$    //////////////////////////
+0$    // JSON Patch functions //
+0$    //////////////////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        return json_pointer::unflatten(*this);
+0$    {
+0$    basic_json unflatten() const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/unflatten/
+0$    /// @brief unflatten a previously flattened JSON value
+0$
+0$    }
+0$        return result;
+0$        json_pointer::flatten("", *this, result);
+0$        basic_json result(value_t::object);
+0$    {
+0$    basic_json flatten() const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/flatten/
+0$    /// @brief return flattened JSON value
+0$
+0$    }
+0$        return ptr.get_checked(this);
+0$    {
+0$    const_reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
+0$
+0$    }
+0$        return ptr.get_checked(this);
+0$    {
+0$    const_reference at(const json_pointer& ptr) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified element via JSON Pointer
+0$
+0$    }
+0$        return ptr.get_checked(this);
+0$    {
+0$    reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr)
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
+0$
+0$    }
+0$        return ptr.get_checked(this);
+0$    {
+0$    reference at(const json_pointer& ptr)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified element via JSON Pointer
+0$
+0$    }
+0$        return ptr.get_unchecked(this);
+0$    {
+0$    const_reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
+0$
+0$    }
+0$        return ptr.get_unchecked(this);
+0$    {
+0$    const_reference operator[](const json_pointer& ptr) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified element via JSON Pointer
+0$
+0$    }
+0$        return ptr.get_unchecked(this);
+0$    {
+0$    reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr)
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
+0$
+0$    }
+0$        return ptr.get_unchecked(this);
+0$    {
+0$    reference operator[](const json_pointer& ptr)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified element via JSON Pointer
+0$
+0$    /// @{
+0$    /// @name JSON Pointer functions
+0$
+0$    //////////////////////////
+0$    // JSON Pointer support //
+0$    //////////////////////////
+0$
+0$    /// @}
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
+0$        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$        auto ia = i.get();
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const bool allow_exceptions = true)
+0$                                const bool strict = true,
+0$    static basic_json from_bson(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return from_bson(ptr, ptr + len, strict, allow_exceptions);
+0$    {
+0$                                const bool allow_exceptions = true)
+0$                                const bool strict = true,
+0$    static basic_json from_bson(const T* ptr, std::size_t len,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename T>
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const bool allow_exceptions = true)
+0$                                const bool strict = true,
+0$    static basic_json from_bson(IteratorType first, IteratorType last,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
+0$    /// @brief create a JSON value from an input in BSON format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const bool allow_exceptions = true)
+0$                                const bool strict = true,
+0$    static basic_json from_bson(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
+0$    /// @brief create a JSON value from an input in BSON format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_bjdata(IteratorType first, IteratorType last,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
+0$    /// @brief create a JSON value from an input in BJData format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_bjdata(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
+0$    /// @brief create a JSON value from an input in BJData format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
+0$        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$        auto ia = i.get();
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_ubjson(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_ubjson(const T* ptr, std::size_t len,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename T>
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_ubjson(IteratorType first, IteratorType last,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
+0$    /// @brief create a JSON value from an input in UBJSON format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                  const bool allow_exceptions = true)
+0$                                  const bool strict = true,
+0$    static basic_json from_ubjson(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
+0$    /// @brief create a JSON value from an input in UBJSON format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
+0$        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$        auto ia = i.get();
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                   const bool allow_exceptions = true)
+0$                                   const bool strict = true,
+0$    static basic_json from_msgpack(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
+0$    {
+0$                                   const bool allow_exceptions = true)
+0$                                   const bool strict = true,
+0$    static basic_json from_msgpack(const T* ptr, std::size_t len,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename T>
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                   const bool allow_exceptions = true)
+0$                                   const bool strict = true,
+0$    static basic_json from_msgpack(IteratorType first, IteratorType last,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
+0$    /// @brief create a JSON value from an input in MessagePack format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                   const bool allow_exceptions = true)
+0$                                   const bool strict = true,
+0$    static basic_json from_msgpack(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
+0$    /// @brief create a JSON value from an input in MessagePack format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
+0$        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$        auto ia = i.get();
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
+0$                                const bool allow_exceptions = true,
+0$                                const bool strict = true,
+0$    static basic_json from_cbor(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
+0$    {
+0$                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
+0$                                const bool allow_exceptions = true,
+0$                                const bool strict = true,
+0$    static basic_json from_cbor(const T* ptr, std::size_t len,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename T>
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
+0$                                const bool allow_exceptions = true,
+0$                                const bool strict = true,
+0$    static basic_json from_cbor(IteratorType first, IteratorType last,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
+0$    /// @brief create a JSON value from an input in CBOR format
+0$
+0$    }
+0$        return res ? result : basic_json(value_t::discarded);
+0$        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
+0$        basic_json result;
+0$    {
+0$                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
+0$                                const bool allow_exceptions = true,
+0$                                const bool strict = true,
+0$    static basic_json from_cbor(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
+0$    /// @brief create a JSON value from an input in CBOR format
+0$
+0$    }
+0$        binary_writer<char>(o).write_bson(j);
+0$    {
+0$    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
+0$    /// @brief create a BSON serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<std::uint8_t>(o).write_bson(j);
+0$    {
+0$    static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
+0$    /// @brief create a BSON serialization of a given JSON value
+0$
+0$    }
+0$        return result;
+0$        to_bson(j, result);
+0$        std::vector<std::uint8_t> result;
+0$    {
+0$    static std::vector<std::uint8_t> to_bson(const basic_json& j)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
+0$    /// @brief create a BSON serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<char>(o).write_ubjson(j, use_size, use_type, true, true);
+0$    {
+0$                          const bool use_size = false, const bool use_type = false)
+0$    static void to_bjdata(const basic_json& j, detail::output_adapter<char> o,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
+0$    /// @brief create a BJData serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type, true, true);
+0$    {
+0$                          const bool use_size = false, const bool use_type = false)
+0$    static void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
+0$    /// @brief create a BJData serialization of a given JSON value
+0$
+0$    }
+0$        return result;
+0$        to_bjdata(j, result, use_size, use_type);
+0$        std::vector<std::uint8_t> result;
+0$    {
+0$            const bool use_type = false)
+0$            const bool use_size = false,
+0$    static std::vector<std::uint8_t> to_bjdata(const basic_json& j,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
+0$    /// @brief create a BJData serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
+0$    {
+0$                          const bool use_size = false, const bool use_type = false)
+0$    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
+0$    /// @brief create a UBJSON serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
+0$    {
+0$                          const bool use_size = false, const bool use_type = false)
+0$    static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
+0$    /// @brief create a UBJSON serialization of a given JSON value
+0$
+0$    }
+0$        return result;
+0$        to_ubjson(j, result, use_size, use_type);
+0$        std::vector<std::uint8_t> result;
+0$    {
+0$            const bool use_type = false)
+0$            const bool use_size = false,
+0$    static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
+0$    /// @brief create a UBJSON serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<char>(o).write_msgpack(j);
+0$    {
+0$    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
+0$    /// @brief create a MessagePack serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<std::uint8_t>(o).write_msgpack(j);
+0$    {
+0$    static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
+0$    /// @brief create a MessagePack serialization of a given JSON value
+0$
+0$    }
+0$        return result;
+0$        to_msgpack(j, result);
+0$        std::vector<std::uint8_t> result;
+0$    {
+0$    static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
+0$    /// @brief create a MessagePack serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<char>(o).write_cbor(j);
+0$    {
+0$    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
+0$    /// @brief create a CBOR serialization of a given JSON value
+0$
+0$    }
+0$        binary_writer<std::uint8_t>(o).write_cbor(j);
+0$    {
+0$    static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
+0$    /// @brief create a CBOR serialization of a given JSON value
+0$
+0$    }
+0$        return result;
+0$        to_cbor(j, result);
+0$        std::vector<std::uint8_t> result;
+0$    {
+0$    static std::vector<std::uint8_t> to_cbor(const basic_json& j)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
+0$    /// @brief create a CBOR serialization of a given JSON value
+0$  public:
+0$
+0$    /// @{
+0$    /// @name binary serialization/deserialization support
+0$
+0$    //////////////////////////////////////////
+0$    // binary serialization/deserialization //
+0$    //////////////////////////////////////////
+0$
+0$#endif
+0$    basic_json* m_parent = nullptr;
+0$    /// a pointer to a parent value (for debugging purposes)
+0$#if JSON_DIAGNOSTICS
+0$
+0$    data m_data = {};
+0$
+0$    };
+0$        }
+0$            m_value.destroy(m_type);
+0$        {
+0$        ~data() noexcept
+0$
+0$        data& operator=(const data&) noexcept = delete;
+0$        data& operator=(data&&) noexcept = delete;
+0$        data(const data&) noexcept = delete;
+0$        data(data&&) noexcept = default;
+0$        data() noexcept = default;
+0$
+0$        }
+0$            m_value.array = create<array_t>(cnt, val);
+0$        {
+0$            : m_type(value_t::array)
+0$        data(size_type cnt, const basic_json& val)
+0$
+0$        }
+0$        {
+0$            : m_type(v), m_value(v)
+0$        data(const value_t v)
+0$
+0$        json_value m_value = {};
+0$        /// the value of the current element
+0$
+0$        value_t m_type = value_t::null;
+0$        /// the type of the current element
+0$    {
+0$    struct data
+0$
+0$    //////////////////////
+0$    // member variables //
+0$    //////////////////////
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    }
+0$        }
+0$                return "number";
+0$            default:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$                return "discarded";
+0$            case value_t::discarded:
+0$                return "binary";
+0$            case value_t::binary:
+0$                return "boolean";
+0$            case value_t::boolean:
+0$                return "string";
+0$            case value_t::string:
+0$                return "array";
+0$            case value_t::array:
+0$                return "object";
+0$            case value_t::object:
+0$                return "null";
+0$            case value_t::null:
+0$        {
+0$        switch (m_data.m_type)
+0$    {
+0$    const char* type_name() const noexcept
+0$    JSON_HEDLEY_RETURNS_NON_NULL
+0$    /// @sa https://json.nlohmann.me/api/basic_json/type_name/
+0$    /// @brief return the type as string
+0$
+0$    ///////////////////////////
+0$    // convenience functions //
+0$    ///////////////////////////
+0$
+0$    /// @}
+0$#endif  // JSON_NO_IO
+0$    }
+0$        return i;
+0$        parser(detail::input_adapter(i)).parse(false, j);
+0$    {
+0$    friend std::istream& operator>>(std::istream& i, basic_json& j)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
+0$    /// @brief deserialize from stream
+0$
+0$    }
+0$        return operator>>(i, j);
+0$    {
+0$    friend std::istream& operator<<(basic_json& j, std::istream& i)
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
+0$    ///             replace calls like `j << i;` with `i >> j;`.
+0$    ///             operator>>(std::istream&, basic_json&) instead; that is,
+0$    ///             version 4.0.0 of the library. Please use
+0$    /// @deprecated This stream operator is deprecated since 3.0.0 and will be removed in
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
+0$    /// @brief deserialize from stream
+0$#ifndef JSON_NO_IO
+0$    }
+0$               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
+0$               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
+0$               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
+0$        return format == input_format_t::json
+0$        auto ia = i.get();
+0$    {
+0$                          const bool ignore_comments = false)
+0$                          const bool strict = true,
+0$                          input_format_t format = input_format_t::json,
+0$    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
+0$    JSON_HEDLEY_NON_NULL(2)
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
+0$    template <typename SAX>
+0$    ///             sax_parse(ptr, ptr + len) instead.
+0$    ///             version 4.0.0 of the library. Please use
+0$    /// @deprecated This function is deprecated since 3.8.0 and will be removed in
+0$    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
+0$    /// @brief generate SAX events
+0$
+0$    }
+0$               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
+0$               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
+0$        return format == input_format_t::json
+0$        auto ia = detail::input_adapter(std::move(first), std::move(last));
+0$    {
+0$                          const bool ignore_comments = false)
+0$                          const bool strict = true,
+0$                          input_format_t format = input_format_t::json,
+0$    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
+0$    JSON_HEDLEY_NON_NULL(3)
+0$    template<class IteratorType, class SAX>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
+0$    /// @brief generate SAX events
+0$
+0$    }
+0$               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
+0$               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
+0$        return format == input_format_t::json
+0$        auto ia = detail::input_adapter(std::forward<InputType>(i));
+0$    {
+0$                          const bool ignore_comments = false)
+0$                          const bool strict = true,
+0$                          input_format_t format = input_format_t::json,
+0$    static bool sax_parse(InputType&& i, SAX* sax,
+0$    JSON_HEDLEY_NON_NULL(2)
+0$    template <typename InputType, typename SAX>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
+0$    /// @brief generate SAX events
+0$
+0$    }
+0$        return parser(i.get(), nullptr, false, ignore_comments).accept(true);
+0$    {
+0$                       const bool ignore_comments = false)
+0$    static bool accept(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
+0$    {
+0$                       const bool ignore_comments = false)
+0$    static bool accept(IteratorType first, IteratorType last,
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/accept/
+0$    /// @brief check if the input is valid JSON
+0$
+0$    }
+0$        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
+0$    {
+0$                       const bool ignore_comments = false)
+0$    static bool accept(InputType&& i,
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/accept/
+0$    /// @brief check if the input is valid JSON
+0$
+0$    }
+0$        return result;
+0$        parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
+0$        basic_json result;
+0$    {
+0$                            const bool ignore_comments = false)
+0$                            const bool allow_exceptions = true,
+0$                            const parser_callback_t cb = nullptr,
+0$    static basic_json parse(detail::span_input_adapter&& i,
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$
+0$    }
+0$        return result;
+0$        parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
+0$        basic_json result;
+0$    {
+0$                            const bool ignore_comments = false)
+0$                            const bool allow_exceptions = true,
+0$                            const parser_callback_t cb = nullptr,
+0$                            IteratorType last,
+0$    static basic_json parse(IteratorType first,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename IteratorType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/parse/
+0$    /// @brief deserialize from a pair of character iterators
+0$
+0$    }
+0$        return result;
+0$        parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
+0$        basic_json result;
+0$    {
+0$                            const bool ignore_comments = false)
+0$                            const bool allow_exceptions = true,
+0$                            const parser_callback_t cb = nullptr,
+0$    static basic_json parse(InputType&& i,
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    template<typename InputType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/parse/
+0$    /// @brief deserialize from a compatible input
+0$
+0$    /// @{
+0$    /// @name deserialization
+0$
+0$    /////////////////////
+0$    // deserialization //
+0$    /////////////////////
+0$
+0$    /// @}
+0$#endif  // JSON_NO_IO
+0$    }
+0$        return o << j;
+0$    {
+0$    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
+0$    ///             replace calls like `j >> o;` with `o << j;`.
+0$    ///             operator<<(std::ostream&, const basic_json&) instead; that is,
+0$    ///             version 4.0.0 of the library. Please use
+0$    /// @deprecated This function is deprecated since 3.0.0 and will be removed in
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
+0$    /// @brief serialize to stream
+0$
+0$    }
+0$        return o;
+0$        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
+0$        serializer s(detail::output_adapter<char>(o), o.fill());
+0$        // do the actual serialization
+0$
+0$        o.width(0);
+0$        // reset width to 0 for subsequent calls to this stream
+0$
+0$        const auto indentation = pretty_print ? o.width() : 0;
+0$        const bool pretty_print = o.width() > 0;
+0$        // read width member and use it as indentation parameter if nonzero
+0$    {
+0$    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
+0$    /// @brief serialize to stream
+0$#ifndef JSON_NO_IO
+0$    /// @{
+0$    /// @name serialization
+0$
+0$    ///////////////////
+0$    // serialization //
+0$    ///////////////////
+0$
+0$    /// @}
+0$
+0$#undef JSON_IMPLEMENT_OPERATOR
+0$
+0$#endif
+0$    }
+0$        return basic_json(lhs) >= rhs;
+0$    {
+0$    friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
+0$    /// @brief comparison: greater than or equal
+0$
+0$    }
+0$        return lhs >= basic_json(rhs);
+0$    {
+0$    friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
+0$    /// @brief comparison: greater than or equal
+0$
+0$    }
+0$        return !(lhs < rhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(lhs, rhs, true))
+0$    {
+0$    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
+0$    /// @brief comparison: greater than or equal
+0$
+0$    }
+0$        return basic_json(lhs) > rhs;
+0$    {
+0$    friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
+0$    /// @brief comparison: greater than
+0$
+0$    }
+0$        return lhs > basic_json(rhs);
+0$    {
+0$    friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
+0$    /// @brief comparison: greater than
+0$
+0$    }
+0$        return !(lhs <= rhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(lhs, rhs))
+0$        // double inverse
+0$    {
+0$    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
+0$    /// @brief comparison: greater than
+0$
+0$    }
+0$        return basic_json(lhs) <= rhs;
+0$    {
+0$    friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
+0$    /// @brief comparison: less than or equal
+0$
+0$    }
+0$        return lhs <= basic_json(rhs);
+0$    {
+0$    friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
+0$    /// @brief comparison: less than or equal
+0$
+0$    }
+0$        return !(rhs < lhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(lhs, rhs, true))
+0$    {
+0$    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
+0$    /// @brief comparison: less than or equal
+0$
+0$    }
+0$        return basic_json(lhs) < rhs;
+0$    {
+0$    friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
+0$    /// @brief comparison: less than
+0$
+0$    }
+0$        return lhs < basic_json(rhs);
+0$    {
+0$    friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
+0$    /// @brief comparison: less than
+0$
+0$    }
+0$        JSON_IMPLEMENT_OPERATOR( <, false, false, operator<(lhs_type, rhs_type))
+0$        // because MSVC has problems otherwise.
+0$        // we compare types. Note we have to call the operator explicitly,
+0$        // default_result is used if we cannot compare values. In that case,
+0$    {
+0$    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
+0$    /// @brief comparison: less than
+0$
+0$    }
+0$        return basic_json(lhs) != rhs;
+0$    {
+0$    friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
+0$    /// @brief comparison: not equal
+0$
+0$    }
+0$        return lhs != basic_json(rhs);
+0$    {
+0$    friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
+0$    /// @brief comparison: not equal
+0$
+0$    }
+0$        return !(lhs == rhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(lhs, rhs, true))
+0$    {
+0$    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
+0$    /// @brief comparison: not equal
+0$
+0$    }
+0$        return basic_json(lhs) == rhs;
+0$    {
+0$    friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
+0$    /// @brief comparison: equal
+0$
+0$    }
+0$        return lhs == basic_json(rhs);
+0$    {
+0$    friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
+0$                 std::is_scalar<ScalarType>::value, int>::type = 0>
+0$    template<typename ScalarType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
+0$    /// @brief comparison: equal
+0$
+0$    }
+0$#endif
+0$#pragma GCC diagnostic pop
+0$#ifdef __GNUC__
+0$        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
+0$#endif
+0$#pragma GCC diagnostic ignored "-Wfloat-equal"
+0$#pragma GCC diagnostic push
+0$#ifdef __GNUC__
+0$    {
+0$    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
+0$    /// @brief comparison: equal
+0$#else
+0$#endif
+0$    }
+0$        return *this >= basic_json(rhs);
+0$    {
+0$    bool operator>=(ScalarType rhs) const noexcept
+0$    requires std::is_scalar_v<ScalarType>
+0$    template<typename ScalarType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
+0$    /// @brief comparison: greater than or equal
+0$
+0$    }
+0$        return !(*this < rhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(rhs, true))
+0$    {
+0$    bool operator>=(const_reference rhs) const noexcept
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
+0$    /// @brief comparison: greater than or equal
+0$
+0$    }
+0$        return *this <= basic_json(rhs);
+0$    {
+0$    bool operator<=(ScalarType rhs) const noexcept
+0$    requires std::is_scalar_v<ScalarType>
+0$    template<typename ScalarType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
+0$    /// @brief comparison: less than or equal
+0$
+0$    }
+0$        return !(rhs < *this);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(rhs, true))
+0$    {
+0$    bool operator<=(const_reference rhs) const noexcept
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
+0$    /// @brief comparison: less than or equal
+0$
+0$    // need to be overloaded to emulate the legacy comparison behavior
+0$    // all operators that are computed as an odd number of inverses of others
+0$#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
+0$
+0$    }
+0$        return *this <=> basic_json(rhs); // *NOPAD*
+0$    {
+0$    std::partial_ordering operator<=>(ScalarType rhs) const noexcept // *NOPAD*
+0$    requires std::is_scalar_v<ScalarType>
+0$    template<typename ScalarType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
+0$    /// @brief comparison: 3-way
+0$
+0$    }
+0$                                lhs_type <=> rhs_type) // *NOPAD*
+0$                                std::partial_ordering::unordered,
+0$                                std::partial_ordering::equivalent,
+0$        JSON_IMPLEMENT_OPERATOR(<=>, // *NOPAD*
+0$        // we compare types.
+0$        // default_result is used if we cannot compare values. In that case,
+0$        const_reference lhs = *this;
+0$    {
+0$    std::partial_ordering operator<=>(const_reference rhs) const noexcept // *NOPAD*
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
+0$    /// @brief comparison: 3-way
+0$
+0$    }
+0$        return !operator==(rhs);
+0$        }
+0$            return false;
+0$        {
+0$        if (compares_unordered(rhs, true))
+0$    {
+0$    bool operator!=(const_reference rhs) const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
+0$    /// @brief comparison: not equal
+0$
+0$    }
+0$        return *this == basic_json(rhs);
+0$    {
+0$    bool operator==(ScalarType rhs) const noexcept
+0$    requires std::is_scalar_v<ScalarType>
+0$    template<typename ScalarType>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
+0$    /// @brief comparison: equal
+0$
+0$    }
+0$#endif
+0$#pragma GCC diagnostic pop
+0$#ifdef __GNUC__
+0$        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
+0$        const_reference lhs = *this;
+0$#endif
+0$#pragma GCC diagnostic ignored "-Wfloat-equal"
+0$#pragma GCC diagnostic push
+0$#ifdef __GNUC__
+0$    {
+0$    bool operator==(const_reference rhs) const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
+0$    /// @brief comparison: equal
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$  public:
+0$
+0$    }
+0$        return compares_unordered(*this, rhs, inverse);
+0$    {
+0$    bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
+0$  private:
+0$
+0$    }
+0$#endif
+0$        return lhs.is_discarded() || rhs.is_discarded();
+0$        static_cast<void>(inverse);
+0$#else
+0$        return (lhs.is_discarded() || rhs.is_discarded()) && !inverse;
+0$#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
+0$        }
+0$            return true;
+0$        {
+0$                || (rhs.is_number_float() && std::isnan(rhs.m_data.m_value.number_float) && lhs.is_number()))
+0$        if ((lhs.is_number_float() && std::isnan(lhs.m_data.m_value.number_float) && rhs.is_number())
+0$    {
+0$    static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
+0$    // an operation is computed as an odd number of inverses of others
+0$    // in legacy mode, discarded values are considered ordered if
+0$    // - any operand is discarded
+0$    // - any operand is NaN and the other operand is of number type
+0$    // returns true if:
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    return (default_result);
+0$    \
+0$    }\
+0$        return (unordered_result);\
+0$    {\
+0$    else if(compares_unordered(lhs, rhs))\
+0$    }                                                                                                    \
+0$        return lhs.m_data.m_value.number_integer op static_cast<number_integer_t>(rhs.m_data.m_value.number_unsigned); \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)                \
+0$    }                                                                                                    \
+0$        return static_cast<number_integer_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_integer; \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)                \
+0$    }                                                                                                    \
+0$        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_unsigned);     \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)                  \
+0$    }                                                                                                    \
+0$        return static_cast<number_float_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_float;     \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)                  \
+0$    }                                                                                                    \
+0$        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_integer);      \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)                   \
+0$    }                                                                                                    \
+0$        return static_cast<number_float_t>(lhs.m_data.m_value.number_integer) op rhs.m_data.m_value.number_float;      \
+0$    {                                                                                                    \
+0$    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)                   \
+0$    }                                                                                                    \
+0$        }                                                                                                \
+0$                return (unordered_result);                                                               \
+0$            default:                                                                                     \
+0$            case value_t::discarded:                                                                     \
+0$                \
+0$                return (*lhs.m_data.m_value.binary) op (*rhs.m_data.m_value.binary);                                   \
+0$            case value_t::binary:                                                                        \
+0$                \
+0$                return (lhs.m_data.m_value.number_float) op (rhs.m_data.m_value.number_float);                         \
+0$            case value_t::number_float:                                                                  \
+0$                \
+0$                return (lhs.m_data.m_value.number_unsigned) op (rhs.m_data.m_value.number_unsigned);                   \
+0$            case value_t::number_unsigned:                                                               \
+0$                \
+0$                return (lhs.m_data.m_value.number_integer) op (rhs.m_data.m_value.number_integer);                     \
+0$            case value_t::number_integer:                                                                \
+0$                \
+0$                return (lhs.m_data.m_value.boolean) op (rhs.m_data.m_value.boolean);                                   \
+0$            case value_t::boolean:                                                                       \
+0$                \
+0$                return (*lhs.m_data.m_value.string) op (*rhs.m_data.m_value.string);                                   \
+0$            case value_t::string:                                                                        \
+0$                \
+0$                return (null_result);                                                                    \
+0$            case value_t::null:                                                                          \
+0$                \
+0$                return (*lhs.m_data.m_value.object) op (*rhs.m_data.m_value.object);                                   \
+0$            case value_t::object:                                                                        \
+0$                \
+0$                return (*lhs.m_data.m_value.array) op (*rhs.m_data.m_value.array);                                     \
+0$            case value_t::array:                                                                         \
+0$        {                                                                                                \
+0$        switch (lhs_type)                                                                                \
+0$    {                                                                                                    \
+0$    if (lhs_type == rhs_type) /* NOLINT(readability/braces) */                                           \
+0$    \
+0$    const auto rhs_type = rhs.type();                                                                    \
+0$    const auto lhs_type = lhs.type();                                                                    \
+0$#define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
+0$    // https://github.com/nlohmann/json/issues/1530
+0$    // note parentheses around operands are necessary; see
+0$
+0$    /// @{
+0$    /// @name lexicographical comparison operators
+0$
+0$    //////////////////////////////////////////
+0$    // lexicographical comparison operators //
+0$    //////////////////////////////////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t::container_type&) with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            swap(*(m_data.m_value.binary), other);
+0$            using std::swap;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_binary()))
+0$        // swap only works for strings
+0$    {
+0$    void swap(typename binary_t::container_type& other) // NOLINT(bugprone-exception-escape)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t&) with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            swap(*(m_data.m_value.binary), other);
+0$            using std::swap;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_binary()))
+0$        // swap only works for strings
+0$    {
+0$    void swap(binary_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(string_t&) with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            swap(*(m_data.m_value.string), other);
+0$            using std::swap;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_string()))
+0$        // swap only works for strings
+0$    {
+0$    void swap(string_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(object_t&) with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            swap(*(m_data.m_value.object), other);
+0$            using std::swap;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // swap only works for objects
+0$    {
+0$    void swap(object_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(array_t&) with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            swap(*(m_data.m_value.array), other);
+0$            using std::swap;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // swap only works for arrays
+0$    {
+0$    void swap(array_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        left.swap(right);
+0$    {
+0$    )
+0$        std::is_nothrow_move_assignable<json_value>::value
+0$        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$        std::is_nothrow_move_assignable<value_t>::value&&
+0$        std::is_nothrow_move_constructible<value_t>::value&&
+0$    friend void swap(reference left, reference right) noexcept (
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        assert_invariant();
+0$        other.set_parents();
+0$        set_parents();
+0$
+0$        std::swap(m_data.m_value, other.m_data.m_value);
+0$        std::swap(m_data.m_type, other.m_data.m_type);
+0$    {
+0$    )
+0$        std::is_nothrow_move_assignable<json_value>::value
+0$        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
+0$        std::is_nothrow_move_assignable<value_t>::value&&
+0$        std::is_nothrow_move_constructible<value_t>::value&&
+0$    void swap(reference other) noexcept (
+0$    /// @sa https://json.nlohmann.me/api/basic_json/swap/
+0$    /// @brief exchanges the values
+0$
+0$    }
+0$        }
+0$#endif
+0$            m_data.m_value.object->operator[](it.key()).m_parent = this;
+0$#if JSON_DIAGNOSTICS
+0$            m_data.m_value.object->operator[](it.key()) = it.value();
+0$            }
+0$                }
+0$                    continue;
+0$                    it2->second.update(it.value(), true);
+0$                {
+0$                if (it2 != m_data.m_value.object->end())
+0$                auto it2 = m_data.m_value.object->find(it.key());
+0$            {
+0$            if (merge_objects && it.value().is_object())
+0$        {
+0$        for (auto it = first; it != last; ++it)
+0$
+0$        }
+0$            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", first.m_object->type_name()), first.m_object));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
+0$        // passed iterators must belong to objects
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
+0$        // check if range iterators belong to the same JSON object
+0$
+0$        }
+0$            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value.object = create<object_t>();
+0$            m_data.m_type = value_t::object;
+0$        {
+0$        if (is_null())
+0$        // implicitly convert null value to an empty object
+0$    {
+0$    void update(const_iterator first, const_iterator last, bool merge_objects = false)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/update/
+0$    /// @brief updates a JSON object from another object, overwriting existing keys
+0$
+0$    }
+0$        update(j.begin(), j.end(), merge_objects);
+0$    {
+0$    void update(const_reference j, bool merge_objects = false)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/update/
+0$    /// @brief updates a JSON object from another object, overwriting existing keys
+0$
+0$    }
+0$        m_data.m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
+0$        // passed iterators must belong to objects
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
+0$        // check if range iterators belong to the same JSON object
+0$
+0$        }
+0$            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // insert only works for objects
+0$    {
+0$    void insert(const_iterator first, const_iterator last)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts range of elements into object
+0$
+0$    }
+0$        return insert_iterator(pos, ilist.begin(), ilist.end());
+0$        // insert to array and return iterator
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
+0$        // check if iterator pos fits to this JSON value
+0$
+0$        }
+0$            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_array()))
+0$        // insert only works for arrays
+0$    {
+0$    iterator insert(const_iterator pos, initializer_list_t ilist)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts elements from initializer list into array
+0$
+0$    }
+0$        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
+0$        // insert to array and return iterator
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
+0$        // check if range iterators belong to the same JSON object
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
+0$        // check if iterator pos fits to this JSON value
+0$
+0$        }
+0$            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_array()))
+0$        // insert only works for arrays
+0$    {
+0$    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts range of elements into array
+0$
+0$    }
+0$        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
+0$
+0$        }
+0$            return insert_iterator(pos, cnt, val);
+0$            // insert to array and return iterator
+0$
+0$            }
+0$                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
+0$            // check if iterator pos fits to this JSON value
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // insert only works for arrays
+0$    {
+0$    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts copies of element into array
+0$
+0$    }
+0$        return insert(pos, val);
+0$    {
+0$    iterator insert(const_iterator pos, basic_json&& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts element into array
+0$
+0$    }
+0$        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
+0$
+0$        }
+0$            return insert_iterator(pos, val);
+0$            // insert to array and return iterator
+0$
+0$            }
+0$                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
+0$            // check if iterator pos fits to this JSON value
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // insert only works for arrays
+0$    {
+0$    iterator insert(const_iterator pos, const basic_json& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/insert/
+0$    /// @brief inserts element into array
+0$
+0$    }
+0$        return result;
+0$        set_parents();
+0$
+0$        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.
+0$        // result.m_it.array_iterator = m_data.m_value.array->insert(pos.m_it.array_iterator, cnt, val);
+0$        // This could have been written as:
+0$
+0$        result.m_it.array_iterator = m_data.m_value.array->begin() + insert_pos;
+0$        m_data.m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
+0$        auto insert_pos = std::distance(m_data.m_value.array->begin(), pos.m_it.array_iterator);
+0$
+0$        JSON_ASSERT(m_data.m_value.array != nullptr);
+0$        iterator result(this);
+0$    {
+0$    iterator insert_iterator(const_iterator pos, Args&& ... args)
+0$    template<typename... Args>
+0$    ///        see https://github.com/nlohmann/json/pull/1257
+0$    /// @note: This uses std::distance to support GCC 4.8,
+0$    /// Helper for insertion of an iterator
+0$
+0$    }
+0$        return {it, res.second};
+0$        // return pair of iterator and boolean
+0$
+0$        it.m_it.object_iterator = res.first;
+0$        auto it = begin();
+0$        // create result iterator and set iterator to the result of emplace
+0$
+0$        set_parent(res.first->second);
+0$        auto res = m_data.m_value.object->emplace(std::forward<Args>(args)...);
+0$        // add element to array (perfect forwarding)
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value = value_t::object;
+0$            m_data.m_type = value_t::object;
+0$        {
+0$        if (is_null())
+0$        // transform null object into an object
+0$
+0$        }
+0$            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
+0$        // emplace only works for null objects or arrays
+0$    {
+0$    std::pair<iterator, bool> emplace(Args&& ... args)
+0$    template<class... Args>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/emplace/
+0$    /// @brief add an object to an object if key does not exist
+0$
+0$    }
+0$        return set_parent(m_data.m_value.array->back(), old_capacity);
+0$        m_data.m_value.array->emplace_back(std::forward<Args>(args)...);
+0$        const auto old_capacity = m_data.m_value.array->capacity();
+0$        // add element to array (perfect forwarding)
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value = value_t::array;
+0$            m_data.m_type = value_t::array;
+0$        {
+0$        if (is_null())
+0$        // transform null object into an array
+0$
+0$        }
+0$            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace_back() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
+0$        // emplace_back only works for null objects or arrays
+0$    {
+0$    reference emplace_back(Args&& ... args)
+0$    template<class... Args>
+0$    /// @sa https://json.nlohmann.me/api/basic_json/emplace_back/
+0$    /// @brief add an object to an array
+0$
+0$    }
+0$        return *this;
+0$        push_back(init);
+0$    {
+0$    reference operator+=(initializer_list_t init)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
+0$    /// @brief add an object to an object
+0$
+0$    }
+0$        }
+0$            push_back(basic_json(init));
+0$        {
+0$        else
+0$        }
+0$                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
+0$            push_back(typename object_t::value_type(
+0$            basic_json&& key = init.begin()->moved_or_copied();
+0$        {
+0$        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
+0$    {
+0$    void push_back(initializer_list_t init)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
+0$    /// @brief add an object to an object
+0$
+0$    }
+0$        return *this;
+0$        push_back(val);
+0$    {
+0$    reference operator+=(const typename object_t::value_type& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
+0$    /// @brief add an object to an object
+0$
+0$    }
+0$        set_parent(res.first->second);
+0$        auto res = m_data.m_value.object->insert(val);
+0$        // add element to object
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value = value_t::object;
+0$            m_data.m_type = value_t::object;
+0$        {
+0$        if (is_null())
+0$        // transform null object into an object
+0$
+0$        }
+0$            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
+0$        // push_back only works for null objects or objects
+0$    {
+0$    void push_back(const typename object_t::value_type& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
+0$    /// @brief add an object to an object
+0$
+0$    }
+0$        return *this;
+0$        push_back(val);
+0$    {
+0$    reference operator+=(const basic_json& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
+0$    /// @brief add an object to an array
+0$
+0$    }
+0$        set_parent(m_data.m_value.array->back(), old_capacity);
+0$        m_data.m_value.array->push_back(val);
+0$        const auto old_capacity = m_data.m_value.array->capacity();
+0$        // add element to array
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value = value_t::array;
+0$            m_data.m_type = value_t::array;
+0$        {
+0$        if (is_null())
+0$        // transform null object into an array
+0$
+0$        }
+0$            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
+0$        // push_back only works for null objects or arrays
+0$    {
+0$    void push_back(const basic_json& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
+0$    /// @brief add an object to an array
+0$
+0$    }
+0$        return *this;
+0$        push_back(std::move(val));
+0$    {
+0$    reference operator+=(basic_json&& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
+0$    /// @brief add an object to an array
+0$
+0$    }
+0$        // if val is moved from, basic_json move constructor marks it null, so we do not call the destructor
+0$        set_parent(m_data.m_value.array->back(), old_capacity);
+0$        m_data.m_value.array->push_back(std::move(val));
+0$        const auto old_capacity = m_data.m_value.array->capacity();
+0$        // add element to array (move semantics)
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value = value_t::array;
+0$            m_data.m_type = value_t::array;
+0$        {
+0$        if (is_null())
+0$        // transform null object into an array
+0$
+0$        }
+0$            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
+0$        // push_back only works for null objects or arrays
+0$    {
+0$    void push_back(basic_json&& val)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
+0$    /// @brief add an object to an array
+0$
+0$    }
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.object->clear();
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.array->clear();
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.binary->clear();
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.string->clear();
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.boolean = false;
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_float = 0.0;
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_unsigned = 0;
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_integer = 0;
+0$            {
+0$            case value_t::number_integer:
+0$        {
+0$        switch (m_data.m_type)
+0$    {
+0$    void clear() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/clear/
+0$    /// @brief clears the contents
+0$
+0$    /// @{
+0$    /// @name modifiers
+0$
+0$    ///////////////
+0$    // modifiers //
+0$    ///////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        }
+0$            }
+0$                return size();
+0$                // all other types have max_size() == size()
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                return m_data.m_value.object->max_size();
+0$                // delegate call to object_t::max_size()
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                return m_data.m_value.array->max_size();
+0$                // delegate call to array_t::max_size()
+0$            {
+0$            case value_t::array:
+0$        {
+0$        switch (m_data.m_type)
+0$    {
+0$    size_type max_size() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/max_size/
+0$    /// @brief returns the maximum possible number of elements
+0$
+0$    }
+0$        }
+0$            }
+0$                return 1;
+0$                // all other types have size 1
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$
+0$            }
+0$                return m_data.m_value.object->size();
+0$                // delegate call to object_t::size()
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                return m_data.m_value.array->size();
+0$                // delegate call to array_t::size()
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                return 0;
+0$                // null values are empty
+0$            {
+0$            case value_t::null:
+0$        {
+0$        switch (m_data.m_type)
+0$    {
+0$    size_type size() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/size/
+0$    /// @brief returns the number of elements
+0$
+0$    }
+0$        }
+0$            }
+0$                return false;
+0$                // all other types are nonempty
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$
+0$            }
+0$                return m_data.m_value.object->empty();
+0$                // delegate call to object_t::empty()
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                return m_data.m_value.array->empty();
+0$                // delegate call to array_t::empty()
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                return true;
+0$                // null values are empty
+0$            {
+0$            case value_t::null:
+0$        {
+0$        switch (m_data.m_type)
+0$    {
+0$    bool empty() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/empty/
+0$    /// @brief checks whether the container is empty.
+0$
+0$    /// @{
+0$    /// @name capacity
+0$
+0$    //////////////
+0$    // capacity //
+0$    //////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        return iteration_proxy<const_iterator>(*this);
+0$    {
+0$    iteration_proxy<const_iterator> items() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/items/
+0$    /// @brief helper to access iterator member functions in range-based for
+0$
+0$    }
+0$        return iteration_proxy<iterator>(*this);
+0$    {
+0$    iteration_proxy<iterator> items() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/items/
+0$    /// @brief helper to access iterator member functions in range-based for
+0$
+0$    }
+0$        return ref.items();
+0$    {
+0$    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
+0$    ///         that is, replace `json::iterator_wrapper(j)` with `j.items()`.
+0$    ///         version 4.0.0 of the library. Please use @ref items() instead;
+0$    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
+0$    /// @sa https://json.nlohmann.me/api/basic_json/items/
+0$    /// @brief wrapper to access iterator member functions in range-based for
+0$
+0$    }
+0$        return ref.items();
+0$    {
+0$    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
+0$    ///             that is, replace `json::iterator_wrapper(j)` with `j.items()`.
+0$    ///             version 4.0.0 of the library. Please use @ref items() instead;
+0$    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
+0$    /// @sa https://json.nlohmann.me/api/basic_json/items/
+0$    /// @brief wrapper to access iterator member functions in range-based for
+0$  public:
+0$
+0$    }
+0$        return const_reverse_iterator(cbegin());
+0$    {
+0$    const_reverse_iterator crend() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/crend/
+0$    /// @brief returns a const reverse iterator to one before the first
+0$
+0$    }
+0$        return const_reverse_iterator(cend());
+0$    {
+0$    const_reverse_iterator crbegin() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/crbegin/
+0$    /// @brief returns a const reverse iterator to the last element
+0$
+0$    }
+0$        return crend();
+0$    {
+0$    const_reverse_iterator rend() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/rend/
+0$    /// @brief returns an iterator to the reverse-end
+0$
+0$    }
+0$        return reverse_iterator(begin());
+0$    {
+0$    reverse_iterator rend() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/rend/
+0$    /// @brief returns an iterator to the reverse-end
+0$
+0$    }
+0$        return crbegin();
+0$    {
+0$    const_reverse_iterator rbegin() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
+0$    /// @brief returns an iterator to the reverse-beginning
+0$
+0$    }
+0$        return reverse_iterator(end());
+0$    {
+0$    reverse_iterator rbegin() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
+0$    /// @brief returns an iterator to the reverse-beginning
+0$
+0$    }
+0$        return result;
+0$        result.set_end();
+0$        const_iterator result(this);
+0$    {
+0$    const_iterator cend() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/cend/
+0$    /// @brief returns an iterator to one past the last element
+0$
+0$    }
+0$        return cend();
+0$    {
+0$    const_iterator end() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/end/
+0$    /// @brief returns an iterator to one past the last element
+0$
+0$    }
+0$        return result;
+0$        result.set_end();
+0$        iterator result(this);
+0$    {
+0$    iterator end() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/end/
+0$    /// @brief returns an iterator to one past the last element
+0$
+0$    }
+0$        return result;
+0$        result.set_begin();
+0$        const_iterator result(this);
+0$    {
+0$    const_iterator cbegin() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/cbegin/
+0$    /// @brief returns a const iterator to the first element
+0$
+0$    }
+0$        return cbegin();
+0$    {
+0$    const_iterator begin() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/begin/
+0$    /// @brief returns an iterator to the first element
+0$
+0$    }
+0$        return result;
+0$        result.set_begin();
+0$        iterator result(this);
+0$    {
+0$    iterator begin() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/begin/
+0$    /// @brief returns an iterator to the first element
+0$
+0$    /// @{
+0$    /// @name iterators
+0$
+0$    ///////////////
+0$    // iterators //
+0$    ///////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        return ptr.contains(this);
+0$    {
+0$    bool contains(const typename ::nlohmann::json_pointer<BasicJsonType>& ptr) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
+0$
+0$    }
+0$        return ptr.contains(this);
+0$    {
+0$    bool contains(const json_pointer& ptr) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/contains/
+0$    /// @brief check the existence of an element in a JSON object given a JSON pointer
+0$
+0$    }
+0$        return is_object() && m_data.m_value.object->find(std::forward<KeyType>(key)) != m_data.m_value.object->end();
+0$    {
+0$    bool contains(KeyType && key) const
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/contains/
+0$    /// @brief check the existence of an element in a JSON object
+0$
+0$    }
+0$        return is_object() && m_data.m_value.object->find(key) != m_data.m_value.object->end();
+0$    {
+0$    bool contains(const typename object_t::key_type& key) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/contains/
+0$    /// @brief check the existence of an element in a JSON object
+0$
+0$    }
+0$        return is_object() ? m_data.m_value.object->count(std::forward<KeyType>(key)) : 0;
+0$        // return 0 for all nonobject types
+0$    {
+0$    size_type count(KeyType && key) const
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/count/
+0$    /// @brief returns the number of occurrences of a key in a JSON object
+0$
+0$    }
+0$        return is_object() ? m_data.m_value.object->count(key) : 0;
+0$        // return 0 for all nonobject types
+0$    {
+0$    size_type count(const typename object_t::key_type& key) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/count/
+0$    /// @brief returns the number of occurrences of a key in a JSON object
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$        {
+0$        if (is_object())
+0$
+0$        auto result = cend();
+0$    {
+0$    const_iterator find(KeyType && key) const
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/find/
+0$    /// @brief find an element in a JSON object
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$        {
+0$        if (is_object())
+0$
+0$        auto result = end();
+0$    {
+0$    iterator find(KeyType && key)
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/find/
+0$    /// @brief find an element in a JSON object
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            result.m_it.object_iterator = m_data.m_value.object->find(key);
+0$        {
+0$        if (is_object())
+0$
+0$        auto result = cend();
+0$    {
+0$    const_iterator find(const typename object_t::key_type& key) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/find/
+0$    /// @brief find an element in a JSON object
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            result.m_it.object_iterator = m_data.m_value.object->find(key);
+0$        {
+0$        if (is_object())
+0$
+0$        auto result = end();
+0$    {
+0$    iterator find(const typename object_t::key_type& key)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/find/
+0$    /// @brief find an element in a JSON object
+0$
+0$    /// @{
+0$    /// @name lookup
+0$
+0$    ////////////
+0$    // lookup //
+0$    ////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            m_data.m_value.array->erase(m_data.m_value.array->begin() + static_cast<difference_type>(idx));
+0$
+0$            }
+0$                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // this erase only works for arrays
+0$    {
+0$    void erase(const size_type idx)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/erase/
+0$    /// @brief remove element from a JSON array given an index
+0$
+0$    }
+0$        return erase_internal(std::forward<KeyType>(key));
+0$    {
+0$    size_type erase(KeyType && key)
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/erase/
+0$    /// @brief remove element from a JSON object given a key
+0$
+0$    }
+0$        return erase_internal(key);
+0$        // function a template and thus de-rank it during overload resolution
+0$        // the indirection via erase_internal() is added to avoid making this
+0$    {
+0$    size_type erase(const typename object_t::key_type& key)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/erase/
+0$    /// @brief remove element from a JSON object given a key
+0$
+0$  public:
+0$
+0$    }
+0$        return 0;
+0$        }
+0$            return 1;
+0$            m_data.m_value.object->erase(it);
+0$        {
+0$        if (it != m_data.m_value.object->end())
+0$        const auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$
+0$        }
+0$            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // this erase only works for objects
+0$    {
+0$    size_type erase_internal(KeyType && key)
+0$                   !detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
+0$    template < typename KeyType, detail::enable_if_t <
+0$
+0$    }
+0$        return m_data.m_value.object->erase(std::forward<KeyType>(key));
+0$
+0$        }
+0$            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // this erase only works for objects
+0$    {
+0$    size_type erase_internal(KeyType && key)
+0$                   detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
+0$    template < typename KeyType, detail::enable_if_t <
+0$  private:
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                                             last.m_it.array_iterator);
+0$                result.m_it.array_iterator = m_data.m_value.array->erase(first.m_it.array_iterator,
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                                              last.m_it.object_iterator);
+0$                result.m_it.object_iterator = m_data.m_value.object->erase(first.m_it.object_iterator,
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$                assert_invariant();
+0$                m_data.m_type = value_t::null;
+0$
+0$                }
+0$                    m_data.m_value.binary = nullptr;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
+0$                    AllocatorType<binary_t> alloc;
+0$                {
+0$                else if (is_binary())
+0$                }
+0$                    m_data.m_value.string = nullptr;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
+0$                    AllocatorType<string_t> alloc;
+0$                {
+0$                if (is_string())
+0$
+0$                }
+0$                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", this));
+0$                {
+0$                                       || !last.m_it.primitive_iterator.is_end()))
+0$                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
+0$            {
+0$            case value_t::binary:
+0$            case value_t::string:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::number_float:
+0$            case value_t::boolean:
+0$        {
+0$        switch (m_data.m_type)
+0$
+0$        IteratorType result = end();
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
+0$        // make sure iterator fits the current value
+0$    {
+0$    IteratorType erase(IteratorType first, IteratorType last)
+0$                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
+0$                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
+0$    template < class IteratorType, detail::enable_if_t <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/erase/
+0$    /// @brief remove elements given an iterator range
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                result.m_it.array_iterator = m_data.m_value.array->erase(pos.m_it.array_iterator);
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                result.m_it.object_iterator = m_data.m_value.object->erase(pos.m_it.object_iterator);
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$                assert_invariant();
+0$                m_data.m_type = value_t::null;
+0$
+0$                }
+0$                    m_data.m_value.binary = nullptr;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
+0$                    AllocatorType<binary_t> alloc;
+0$                {
+0$                else if (is_binary())
+0$                }
+0$                    m_data.m_value.string = nullptr;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
+0$                    AllocatorType<string_t> alloc;
+0$                {
+0$                if (is_string())
+0$
+0$                }
+0$                    JSON_THROW(invalid_iterator::create(205, "iterator out of range", this));
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
+0$            {
+0$            case value_t::binary:
+0$            case value_t::string:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::number_float:
+0$            case value_t::boolean:
+0$        {
+0$        switch (m_data.m_type)
+0$
+0$        IteratorType result = end();
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
+0$        // make sure iterator fits the current value
+0$    {
+0$    IteratorType erase(IteratorType pos)
+0$                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
+0$                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
+0$    template < class IteratorType, detail::enable_if_t <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/erase/
+0$    /// @brief remove element given an iterator
+0$
+0$    }
+0$        return *tmp;
+0$        --tmp;
+0$        auto tmp = cend();
+0$    {
+0$    const_reference back() const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/back/
+0$    /// @brief access the last element
+0$
+0$    }
+0$        return *tmp;
+0$        --tmp;
+0$        auto tmp = end();
+0$    {
+0$    reference back()
+0$    /// @sa https://json.nlohmann.me/api/basic_json/back/
+0$    /// @brief access the last element
+0$
+0$    }
+0$        return *cbegin();
+0$    {
+0$    const_reference front() const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/front/
+0$    /// @brief access the first element
+0$
+0$    }
+0$        return *begin();
+0$    {
+0$    reference front()
+0$    /// @sa https://json.nlohmann.me/api/basic_json/front/
+0$    /// @brief access the first element
+0$
+0$    }
+0$        return value(ptr.convert(), std::forward<ValueType>(default_value));
+0$    {
+0$    ReturnType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, ValueType && default_value) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ReturnType>::value
+0$                   detail::is_basic_json<BasicJsonType>::value
+0$               detail::enable_if_t <
+0$    template < class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type,
+0$
+0$    }
+0$        return value(ptr.convert(), default_value);
+0$    {
+0$    ValueType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, const ValueType& default_value) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ValueType>::value
+0$                   detail::is_basic_json<BasicJsonType>::value
+0$    template < class ValueType, class BasicJsonType, detail::enable_if_t <
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            }
+0$                return std::forward<ValueType>(default_value);
+0$            {
+0$            JSON_INTERNAL_CATCH (out_of_range&)
+0$            }
+0$                return ptr.get_checked(this).template get<ReturnType>();
+0$            {
+0$            JSON_TRY
+0$            // if pointer resolves a value, return it or use default value
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ReturnType value(const json_pointer& ptr, ValueType && default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   detail::is_getable<basic_json_t, ReturnType>::value
+0$               detail::enable_if_t <
+0$    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element via JSON Pointer with default value
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            }
+0$                return default_value;
+0$            {
+0$            JSON_INTERNAL_CATCH (out_of_range&)
+0$            }
+0$                return ptr.get_checked(this).template get<ValueType>();
+0$            {
+0$            JSON_TRY
+0$            // if pointer resolves a value, return it or use default value
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   detail::is_getable<basic_json_t, ValueType>::value
+0$    template < class ValueType, detail::enable_if_t <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element via JSON Pointer with default value
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            return std::forward<ValueType>(default_value);
+0$
+0$            }
+0$                return it->template get<ReturnType>();
+0$            {
+0$            if (it != end())
+0$            const auto it = find(std::forward<KeyType>(key));
+0$            // if key is found, return value and given default value otherwise
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ReturnType value(KeyType && key, ValueType && default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ReturnType>::value
+0$                   && is_comparable_with_object_key<KeyType>::value
+0$                   && !detail::is_json_pointer<KeyType>::value
+0$                   detail::is_transparent<object_comparator_t>::value
+0$               detail::enable_if_t <
+0$    template < class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element via JSON Pointer with default value
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            return default_value;
+0$
+0$            }
+0$                return it->template get<ValueType>();
+0$            {
+0$            if (it != end())
+0$            const auto it = find(std::forward<KeyType>(key));
+0$            // if key is found, return value and given default value otherwise
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ValueType value(KeyType && key, const ValueType& default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ValueType>::value
+0$                   && is_comparable_with_object_key<KeyType>::value
+0$                   && !detail::is_json_pointer<KeyType>::value
+0$                   detail::is_transparent<object_comparator_t>::value
+0$    template < class ValueType, class KeyType, detail::enable_if_t <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element with default value
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            return std::forward<ValueType>(default_value);
+0$
+0$            }
+0$                return it->template get<ReturnType>();
+0$            {
+0$            if (it != end())
+0$            const auto it = find(key);
+0$            // if key is found, return value and given default value otherwise
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ReturnType value(const typename object_t::key_type& key, ValueType && default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ReturnType>::value
+0$                   !detail::is_transparent<object_comparator_t>::value
+0$               detail::enable_if_t <
+0$    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element with default value
+0$
+0$    }
+0$        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
+0$
+0$        }
+0$            return default_value;
+0$
+0$            }
+0$                return it->template get<ValueType>();
+0$            {
+0$            if (it != end())
+0$            const auto it = find(key);
+0$            // if key is found, return value and given default value otherwise
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // value only works for objects
+0$    {
+0$    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
+0$                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
+0$                   && detail::is_getable<basic_json_t, ValueType>::value
+0$                   !detail::is_transparent<object_comparator_t>::value
+0$    template < class ValueType, detail::enable_if_t <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/value/
+0$    /// @brief access specified object element with default value
+0$  public:
+0$
+0$        string_t, typename std::decay<ValueType>::type >;
+0$        detail::is_c_string_uncvref<ValueType>::value,
+0$    using value_return_type = std::conditional <
+0$    template<typename ValueType>
+0$
+0$        object_comparator_t, const typename object_t::key_type&, KeyType >;
+0$    using is_comparable_with_object_key = detail::is_comparable <
+0$    template<typename KeyType>
+0$  private:
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
+0$
+0$        }
+0$            return it->second;
+0$            JSON_ASSERT(it != m_data.m_value.object->end());
+0$            auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // const operator[] only works for objects
+0$    {
+0$    const_reference operator[](KeyType && key) const
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified object element
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
+0$
+0$        }
+0$            return set_parent(result.first->second);
+0$            auto result = m_data.m_value.object->emplace(std::forward<KeyType>(key), nullptr);
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // operator[] only works for objects
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value.object = create<object_t>();
+0$            m_data.m_type = value_t::object;
+0$        {
+0$        if (is_null())
+0$        // implicitly convert null value to an empty object
+0$    {
+0$    reference operator[](KeyType && key)
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified object element
+0$
+0$    }
+0$        return operator[](typename object_t::key_type(key));
+0$    {
+0$    const_reference operator[](T* key) const
+0$    template<typename T>
+0$
+0$    }
+0$        return operator[](typename object_t::key_type(key));
+0$    {
+0$    reference operator[](T* key)
+0$    template<typename T>
+0$    // (they seemingly cannot be constrained to resolve the ambiguity)
+0$    // these two functions resolve a (const) char * ambiguity affecting Clang and MSVC
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
+0$
+0$        }
+0$            return it->second;
+0$            JSON_ASSERT(it != m_data.m_value.object->end());
+0$            auto it = m_data.m_value.object->find(key);
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // const operator[] only works for objects
+0$    {
+0$    const_reference operator[](const typename object_t::key_type& key) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified object element
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
+0$
+0$        }
+0$            return set_parent(result.first->second);
+0$            auto result = m_data.m_value.object->emplace(std::move(key), nullptr);
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_object()))
+0$        // operator[] only works for objects
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value.object = create<object_t>();
+0$            m_data.m_type = value_t::object;
+0$        {
+0$        if (is_null())
+0$        // implicitly convert null value to an empty object
+0$    {
+0$    reference operator[](typename object_t::key_type key)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified object element
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
+0$
+0$        }
+0$            return m_data.m_value.array->operator[](idx);
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // const operator[] only works for arrays
+0$    {
+0$    const_reference operator[](size_type idx) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified array element
+0$
+0$    }
+0$        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
+0$
+0$        }
+0$            return m_data.m_value.array->operator[](idx);
+0$
+0$            }
+0$                assert_invariant();
+0$#endif
+0$                }
+0$                    set_parents(begin() + static_cast<typename iterator::difference_type>(old_size), static_cast<typename iterator::difference_type>(idx + 1 - old_size));
+0$                    // set parent for values added above
+0$                {
+0$                else
+0$                }
+0$                    set_parents();
+0$                    // capacity has changed: update all parents
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
+0$#if JSON_DIAGNOSTICS
+0$
+0$                m_data.m_value.array->resize(idx + 1);
+0$#endif
+0$                const auto old_capacity = m_data.m_value.array->capacity();
+0$                const auto old_size = m_data.m_value.array->size();
+0$                // remember array size & capacity before resizing
+0$#if JSON_DIAGNOSTICS
+0$            {
+0$            if (idx >= m_data.m_value.array->size())
+0$            // fill up array with null values if given idx is outside range
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // operator[] only works for arrays
+0$
+0$        }
+0$            assert_invariant();
+0$            m_data.m_value.array = create<array_t>();
+0$            m_data.m_type = value_t::array;
+0$        {
+0$        if (is_null())
+0$        // implicitly convert null value to an empty array
+0$    {
+0$    reference operator[](size_type idx)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
+0$    /// @brief access specified array element
+0$
+0$    }
+0$        return it->second;
+0$        }
+0$            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
+0$        {
+0$        if (it == m_data.m_value.object->end())
+0$        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // at only works for objects
+0$    {
+0$    const_reference at(KeyType && key) const
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified object element with bounds checking
+0$
+0$    }
+0$        return it->second;
+0$        }
+0$            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
+0$        {
+0$        if (it == m_data.m_value.object->end())
+0$        auto it = m_data.m_value.object->find(key);
+0$
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // at only works for objects
+0$    {
+0$    const_reference at(const typename object_t::key_type& key) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified object element with bounds checking
+0$
+0$    }
+0$        return set_parent(it->second);
+0$        }
+0$            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
+0$        {
+0$        if (it == m_data.m_value.object->end())
+0$        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
+0$
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // at only works for objects
+0$    {
+0$    reference at(KeyType && key)
+0$                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified object element with bounds checking
+0$
+0$    }
+0$        return set_parent(it->second);
+0$        }
+0$            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
+0$        {
+0$        if (it == m_data.m_value.object->end())
+0$        auto it = m_data.m_value.object->find(key);
+0$
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!is_object()))
+0$        // at only works for objects
+0$    {
+0$    reference at(const typename object_t::key_type& key)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified object element with bounds checking
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            }
+0$                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
+0$                // create better exception explanation
+0$            {
+0$            JSON_CATCH (std::out_of_range&)
+0$            }
+0$                return m_data.m_value.array->at(idx);
+0$            {
+0$            JSON_TRY
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // at only works for arrays
+0$    {
+0$    const_reference at(size_type idx) const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified array element with bounds checking
+0$
+0$    }
+0$        }
+0$            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
+0$        {
+0$        else
+0$        }
+0$            }
+0$                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
+0$                // create better exception explanation
+0$            {
+0$            JSON_CATCH (std::out_of_range&)
+0$            }
+0$                return set_parent(m_data.m_value.array->at(idx));
+0$            {
+0$            JSON_TRY
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_array()))
+0$        // at only works for arrays
+0$    {
+0$    reference at(size_type idx)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/at/
+0$    /// @brief access specified array element with bounds checking
+0$
+0$    /// @{
+0$    /// Access to the JSON value.
+0$    /// @name element access
+0$
+0$    ////////////////////
+0$    // element access //
+0$    ////////////////////
+0$
+0$    /// @}
+0$
+0$    }
+0$        return *get_ptr<const binary_t*>();
+0$
+0$        }
+0$            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
+0$        {
+0$        if (!is_binary())
+0$    {
+0$    const binary_t& get_binary() const
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
+0$    /// @brief get a binary value
+0$
+0$    }
+0$        return *get_ptr<binary_t*>();
+0$
+0$        }
+0$            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
+0$        {
+0$        if (!is_binary())
+0$    {
+0$    binary_t& get_binary()
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
+0$    /// @brief get a binary value
+0$
+0$    }
+0$        return get<ValueType>();
+0$        // delegate the call to get<>() const
+0$    {
+0$                                        JSON_EXPLICIT operator ValueType() const
+0$                                                >::value, int >::type = 0 >
+0$                                                detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
+0$#endif
+0$                                                detail::negation<std::is_same<ValueType, std::any>>,
+0$#if defined(JSON_HAS_CPP_17) && JSON_HAS_STATIC_RTTI
+0$#endif
+0$                                                detail::negation<std::is_same<ValueType, std::string_view>>,
+0$#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
+0$                                        detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
+0$                                        detail::negation<detail::is_basic_json<ValueType>>,
+0$                                        detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
+0$                       detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
+0$                       detail::negation<std::is_same<ValueType, std::nullptr_t>>,
+0$                       detail::negation<std::is_pointer<ValueType>>,
+0$                   detail::conjunction <
+0$    template < typename ValueType, typename std::enable_if <
+0$    */
+0$    @since version 1.0.0
+0$
+0$    json>`.,operator__ValueType}
+0$    associative containers such as `std::unordered_map<std::string\,
+0$    `std::vector<short>`\, (3) A JSON object can be converted to C++
+0$    be converted to integers\, (2) A JSON array can be converted to a standard
+0$    to other types. There a few things to note: (1) Floating-point numbers can
+0$    @liveexample{The example below shows several conversions from JSON values
+0$
+0$    @complexity Linear in the size of the JSON value.
+0$
+0$    string is requested); see example below
+0$    to the JSON value type (e.g., the JSON value is of type boolean, but a
+0$    @throw type_error.302 in case passed type @a ValueType is incompatible
+0$
+0$    @return copy of the JSON value, converted to type @a ValueType
+0$
+0$    ambiguities as these types implicitly convert to `std::string`.
+0$    as well as an initializer list of this type is excluded to avoid
+0$    `std::vector` types for JSON arrays. The character type of @ref string_t
+0$    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
+0$    @tparam ValueType non-pointer type compatible to the JSON value, for
+0$
+0$    The call is realized by calling @ref get() const.
+0$    Implicit type conversion between the JSON value and a compatible value.
+0$
+0$    @brief get a value (implicit)
+0$    /*!
+0$
+0$    }
+0$        return get_ref_impl<ReferenceType>(*this);
+0$        // delegate call to get_ref_impl
+0$    {
+0$    ReferenceType get_ref() const
+0$                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
+0$                   std::is_reference<ReferenceType>::value&&
+0$    template < typename ReferenceType, typename std::enable_if <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
+0$    /// @brief get a reference value (implicit)
+0$
+0$    }
+0$        return get_ref_impl<ReferenceType>(*this);
+0$        // delegate call to get_ref_impl
+0$    {
+0$    ReferenceType get_ref()
+0$                 std::is_reference<ReferenceType>::value, int>::type = 0>
+0$    template<typename ReferenceType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
+0$    /// @brief get a reference value (implicit)
+0$
+0$    }
+0$        return v;
+0$        JSONSerializer<Array>::from_json(*this, v);
+0$    {
+0$                          std::declval<const basic_json_t&>(), v)))
+0$    noexcept(noexcept(JSONSerializer<Array>::from_json(
+0$    Array get_to(T (&v)[N]) const // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
+0$        detail::enable_if_t <
+0$        typename Array = T (&)[N], // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$        typename T, std::size_t N,
+0$    template <
+0$
+0$    }
+0$        return v;
+0$        v = *this;
+0$    {
+0$    ValueType & get_to(ValueType& v) const
+0$                 int> = 0>
+0$                 detail::is_basic_json<ValueType>::value,
+0$             detail::enable_if_t <
+0$    template<typename ValueType,
+0$    // see https://github.com/nlohmann/json/issues/2175
+0$    // specialization to allow calling get_to with a basic_json value
+0$
+0$    }
+0$        return v;
+0$        JSONSerializer<ValueType>::from_json(*this, v);
+0$    {
+0$                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
+0$    ValueType & get_to(ValueType& v) const noexcept(noexcept(
+0$                   int > = 0 >
+0$                   detail::has_from_json<basic_json_t, ValueType>::value,
+0$                   !detail::is_basic_json<ValueType>::value&&
+0$               detail::enable_if_t <
+0$    template < typename ValueType,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_to/
+0$    /// @brief get a value (explicit)
+0$
+0$    }
+0$        return get_ptr<PointerType>();
+0$        // delegate the call to get_ptr
+0$    {
+0$    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
+0$                 std::is_pointer<PointerType>::value, int>::type = 0>
+0$    template<typename PointerType, typename std::enable_if<
+0$    */
+0$    @since version 1.0.0
+0$
+0$    @sa see @ref get_ptr() for explicit pointer-member access
+0$
+0$    match.,get__PointerType}
+0$    `nullptr` is returned if the value and the requested pointer type does not
+0$    JSON value can be requested. Note that no type conversions are made and a
+0$    @liveexample{The example below shows how pointers to internal values of a
+0$
+0$    @complexity Constant.
+0$
+0$    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise
+0$    @return pointer to the internally stored JSON value if the requested
+0$
+0$    @ref number_unsigned_t, or @ref number_float_t.
+0$    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
+0$    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
+0$
+0$    changes.
+0$    @warning The pointer becomes invalid if the underlying JSON object
+0$
+0$    made.
+0$    Explicit pointer access to the internally stored JSON value. No copies are
+0$
+0$    @brief get a pointer value (explicit)
+0$    /*!
+0$
+0$    }
+0$        return get_impl<ValueType>(detail::priority_tag<4> {});
+0$                      "get() cannot be used with reference types, you might want to use get_ref()");
+0$        static_assert(!std::is_reference<ValueTypeCV>::value,
+0$        // still need the uncvref
+0$        // there is support for get<const basic_json_t>(), which is why we
+0$        // we cannot static_assert on ValueTypeCV being non-const, because
+0$    {
+0$    -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
+0$    noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
+0$    auto get() const noexcept(
+0$#endif
+0$    constexpr
+0$#if defined(JSON_HAS_CPP_14)
+0$    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
+0$    */
+0$    @since version 2.1.0
+0$
+0$    @throw what @ref json_serializer<ValueType> `from_json()` method throws if conversion is required
+0$
+0$    @return copy of the JSON value, converted to @tparam ValueType if necessary
+0$
+0$    @tparam ValueType the returned value type
+0$    @tparam ValueTypeCV the provided value type
+0$
+0$    method.
+0$    - Otherwise the value is converted by calling the @ref json_serializer<ValueType> `from_json()`
+0$
+0$    from the current @ref basic_json.
+0$    - If the requested type is the current @ref basic_json, or a different @ref basic_json convertible
+0$
+0$    No copies are made.
+0$    - If the requested type is a pointer to the internally stored JSON value that pointer is returned.
+0$
+0$    Performs explicit type conversion between the JSON value and a compatible value if required.
+0$
+0$    @brief get a (pointer) value (explicit)
+0$    /*!
+0$  public:
+0$
+0$    }
+0$        return get_ptr<PointerType>();
+0$        // delegate the call to get_ptr
+0$    {
+0$    -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
+0$    constexpr auto get_impl(detail::priority_tag<4> /*unused*/) const noexcept
+0$                 int> = 0>
+0$                 std::is_pointer<PointerType>::value,
+0$             detail::enable_if_t<
+0$    template<typename PointerType,
+0$    */
+0$    @copydoc get()
+0$    @brief get a pointer value (explicit)
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$    {
+0$    basic_json get_impl(detail::priority_tag<3> /*unused*/) const
+0$                 int> = 0>
+0$                 std::is_same<BasicJsonType, basic_json_t>::value,
+0$             detail::enable_if_t<
+0$    template<typename BasicJsonType,
+0$    */
+0$    @since version 2.1.0
+0$
+0$    @complexity Constant.
+0$
+0$    @return a copy of *this
+0$
+0$    @tparam BasicJsonType == @ref basic_json
+0$
+0$    identity method
+0$    This overloads avoids a lot of template boilerplate, it can be seen as the
+0$
+0$    @brief get special-case overload
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$    {
+0$    BasicJsonType get_impl(detail::priority_tag<2> /*unused*/) const
+0$                   int > = 0 >
+0$                   detail::is_basic_json<BasicJsonType>::value,
+0$               detail::enable_if_t <
+0$    template < typename BasicJsonType,
+0$    */
+0$    @since version 3.2.0
+0$
+0$                method.
+0$    @complexity Depending on the implementation of the called `from_json()`
+0$
+0$    @return a copy of *this, converted into @a BasicJsonType
+0$
+0$    @tparam BasicJsonType == @ref basic_json
+0$
+0$    @ref basic_json type
+0$    This overloads converts the current @ref basic_json in a different
+0$
+0$    @brief get special-case overload
+0$    /*!
+0$
+0$    }
+0$        return JSONSerializer<ValueType>::from_json(*this);
+0$    {
+0$                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
+0$    ValueType get_impl(detail::priority_tag<1> /*unused*/) const noexcept(noexcept(
+0$                   int > = 0 >
+0$                   detail::has_non_default_from_json<basic_json_t, ValueType>::value,
+0$               detail::enable_if_t <
+0$    template < typename ValueType,
+0$    */
+0$    @since version 2.1.0
+0$
+0$    @throw what @ref json_serializer<ValueType> `from_json()` method throws
+0$
+0$    @return copy of the JSON value, converted to @a ValueType
+0$
+0$    @tparam ValueType the returned value type
+0$
+0$    `from_json()`, this one is chosen.
+0$    @note If @ref json_serializer<ValueType> has both overloads of
+0$
+0$      `ValueType from_json(const basic_json&)`
+0$    - @ref json_serializer<ValueType> has a `from_json()` method of the form
+0$    - @a ValueType is not @ref basic_json and
+0$    This overloads is chosen if:
+0$
+0$    @endcode
+0$    return JSONSerializer<ValueType>::from_json(*this);
+0$    @code {.cpp}
+0$    The function is equivalent to executing
+0$
+0$    `from_json()` method.
+0$    The value is converted by calling the @ref json_serializer<ValueType>
+0$    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
+0$    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
+0$    Explicit type conversion between the JSON value and a compatible value
+0$
+0$    @brief get a value (explicit); special case
+0$    /*!
+0$
+0$    }
+0$        return ret;
+0$        JSONSerializer<ValueType>::from_json(*this, ret);
+0$        auto ret = ValueType();
+0$    {
+0$                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
+0$    ValueType get_impl(detail::priority_tag<0> /*unused*/) const noexcept(noexcept(
+0$                   int > = 0 >
+0$                   detail::has_from_json<basic_json_t, ValueType>::value,
+0$                   detail::is_default_constructible<ValueType>::value&&
+0$               detail::enable_if_t <
+0$    template < typename ValueType,
+0$    */
+0$    @since version 2.1.0
+0$
+0$    json>`.,get__ValueType_const}
+0$    associative containers such as `std::unordered_map<std::string\,
+0$    `std::vector<short>`\, (3) A JSON object can be converted to C++
+0$    be converted to integers\, (2) A JSON array can be converted to a standard
+0$    to other types. There a few things to note: (1) Floating-point numbers can
+0$    @liveexample{The example below shows several conversions from JSON values
+0$
+0$    @throw what @ref json_serializer<ValueType> `from_json()` method throws
+0$
+0$    @return copy of the JSON value, converted to @a ValueType
+0$
+0$    @tparam ValueType the returned value type
+0$
+0$      the form `ValueType from_json(const basic_json&)`
+0$    - @ref json_serializer<ValueType> does not have a `from_json()` method of
+0$      `void from_json(const basic_json&, ValueType&)`, and
+0$    - @ref json_serializer<ValueType> has a `from_json()` method of the form
+0$    - @a ValueType is not @ref basic_json,
+0$    This overloads is chosen if:
+0$
+0$    @endcode
+0$    return ret;
+0$    JSONSerializer<ValueType>::from_json(*this, ret);
+0$    ValueType ret;
+0$    @code {.cpp}
+0$    The function is equivalent to executing
+0$
+0$    `from_json()` method.
+0$    The value is converted by calling the @ref json_serializer<ValueType>
+0$    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
+0$    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
+0$    Explicit type conversion between the JSON value and a compatible value
+0$
+0$    @brief get a value (explicit)
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return get_impl_ptr(static_cast<PointerType>(nullptr));
+0$        // delegate the call to get_impl_ptr<>() const
+0$    {
+0$    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
+0$                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
+0$                   std::is_pointer<PointerType>::value&&
+0$    template < typename PointerType, typename std::enable_if <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
+0$    /// @brief get a pointer value (implicit)
+0$
+0$    }
+0$        return get_impl_ptr(static_cast<PointerType>(nullptr));
+0$        // delegate the call to get_impl_ptr<>()
+0$    {
+0$    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
+0$                 std::is_pointer<PointerType>::value, int>::type = 0>
+0$    template<typename PointerType, typename std::enable_if<
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
+0$    /// @brief get a pointer value (implicit)
+0$
+0$    /// @{
+0$    /// Direct access to the stored value of a JSON value.
+0$    /// @name value access
+0$  public:
+0$
+0$    }
+0$        JSON_THROW(type_error::create(303, detail::concat("incompatible ReferenceType for get_ref, actual type is ", obj.type_name()), &obj));
+0$
+0$        }
+0$            return *ptr;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
+0$
+0$        auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();
+0$        // delegate the call to get_ptr<>()
+0$    {
+0$    static ReferenceType get_ref_impl(ThisType& obj)
+0$    template<typename ReferenceType, typename ThisType>
+0$    */
+0$    type of the current JSON
+0$    @throw type_error.303 if ReferenceType does not match underlying value
+0$
+0$    @tparam ThisType will be deduced as `basic_json` or `const basic_json`
+0$
+0$    const and non-const overloads
+0$    This function helps to implement get_ref() without code duplication for
+0$
+0$    @brief helper function to implement get_ref()
+0$    /*!
+0$
+0$    }
+0$        return is_binary() ? m_data.m_value.binary : nullptr;
+0$    {
+0$    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (binary)
+0$
+0$    }
+0$        return is_binary() ? m_data.m_value.binary : nullptr;
+0$    {
+0$    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (binary)
+0$
+0$    }
+0$        return is_number_float() ? &m_data.m_value.number_float : nullptr;
+0$    {
+0$    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (floating-point number)
+0$
+0$    }
+0$        return is_number_float() ? &m_data.m_value.number_float : nullptr;
+0$    {
+0$    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (floating-point number)
+0$
+0$    }
+0$        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
+0$    {
+0$    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (unsigned number)
+0$
+0$    }
+0$        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
+0$    {
+0$    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (unsigned number)
+0$
+0$    }
+0$        return is_number_integer() ? &m_data.m_value.number_integer : nullptr;
+0$    {
+0$    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (integer number)
+0$
+0$    }
+0$        return is_number_integer() ? &m_data.m_value.number_integer : nullptr;
+0$    {
+0$    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (integer number)
+0$
+0$    }
+0$        return is_boolean() ? &m_data.m_value.boolean : nullptr;
+0$    {
+0$    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (boolean)
+0$
+0$    }
+0$        return is_boolean() ? &m_data.m_value.boolean : nullptr;
+0$    {
+0$    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (boolean)
+0$
+0$    }
+0$        return is_string() ? m_data.m_value.string : nullptr;
+0$    {
+0$    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (string)
+0$
+0$    }
+0$        return is_string() ? m_data.m_value.string : nullptr;
+0$    {
+0$    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (string)
+0$
+0$    }
+0$        return is_array() ? m_data.m_value.array : nullptr;
+0$    {
+0$    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (array)
+0$
+0$    }
+0$        return is_array() ? m_data.m_value.array : nullptr;
+0$    {
+0$    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (array)
+0$
+0$    }
+0$        return is_object() ? m_data.m_value.object : nullptr;
+0$    {
+0$    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
+0$    /// get a pointer to the value (object)
+0$
+0$    }
+0$        return is_object() ? m_data.m_value.object : nullptr;
+0$    {
+0$    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
+0$    /// get a pointer to the value (object)
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, detail::concat("type must be boolean, but is ", type_name()), this));
+0$
+0$        }
+0$            return m_data.m_value.boolean;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(is_boolean()))
+0$    {
+0$    boolean_t get_impl(boolean_t* /*unused*/) const
+0$    /// get a boolean (explicit)
+0$
+0$    //////////////////
+0$    // value access //
+0$    //////////////////
+0$  private:
+0$
+0$    /// @}
+0$
+0$    }
+0$        return m_data.m_type;
+0$    {
+0$    constexpr operator value_t() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_value_t/
+0$    /// @brief return the type of the JSON value (implicit)
+0$
+0$    }
+0$        return m_data.m_type == value_t::discarded;
+0$    {
+0$    constexpr bool is_discarded() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_discarded/
+0$    /// @brief return whether value is discarded
+0$
+0$    }
+0$        return m_data.m_type == value_t::binary;
+0$    {
+0$    constexpr bool is_binary() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_binary/
+0$    /// @brief return whether value is a binary array
+0$
+0$    }
+0$        return m_data.m_type == value_t::string;
+0$    {
+0$    constexpr bool is_string() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_string/
+0$    /// @brief return whether value is a string
+0$
+0$    }
+0$        return m_data.m_type == value_t::array;
+0$    {
+0$    constexpr bool is_array() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_array/
+0$    /// @brief return whether value is an array
+0$
+0$    }
+0$        return m_data.m_type == value_t::object;
+0$    {
+0$    constexpr bool is_object() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_object/
+0$    /// @brief return whether value is an object
+0$
+0$    }
+0$        return m_data.m_type == value_t::number_float;
+0$    {
+0$    constexpr bool is_number_float() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_number_float/
+0$    /// @brief return whether value is a floating-point number
+0$
+0$    }
+0$        return m_data.m_type == value_t::number_unsigned;
+0$    {
+0$    constexpr bool is_number_unsigned() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_number_unsigned/
+0$    /// @brief return whether value is an unsigned integer number
+0$
+0$    }
+0$        return m_data.m_type == value_t::number_integer || m_data.m_type == value_t::number_unsigned;
+0$    {
+0$    constexpr bool is_number_integer() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_number_integer/
+0$    /// @brief return whether value is an integer number
+0$
+0$    }
+0$        return is_number_integer() || is_number_float();
+0$    {
+0$    constexpr bool is_number() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_number/
+0$    /// @brief return whether value is a number
+0$
+0$    }
+0$        return m_data.m_type == value_t::boolean;
+0$    {
+0$    constexpr bool is_boolean() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_boolean/
+0$    /// @brief return whether value is a boolean
+0$
+0$    }
+0$        return m_data.m_type == value_t::null;
+0$    {
+0$    constexpr bool is_null() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_null/
+0$    /// @brief return whether value is null
+0$
+0$    }
+0$        return is_array() || is_object();
+0$    {
+0$    constexpr bool is_structured() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_structured/
+0$    /// @brief return whether type is structured
+0$
+0$    }
+0$        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
+0$    {
+0$    constexpr bool is_primitive() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/is_primitive/
+0$    /// @brief return whether type is primitive
+0$
+0$    }
+0$        return m_data.m_type;
+0$    {
+0$    constexpr value_t type() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/type/
+0$    /// @brief return the type of the JSON value (explicit)
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            s.dump(*this, false, ensure_ascii, 0);
+0$        {
+0$        else
+0$        }
+0$            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
+0$        {
+0$        if (indent >= 0)
+0$
+0$        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);
+0$        string_t result;
+0$    {
+0$                  const error_handler_t error_handler = error_handler_t::strict) const
+0$                  const bool ensure_ascii = false,
+0$                  const char indent_char = ' ',
+0$    string_t dump(const int indent = -1,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/dump/
+0$    /// @brief serialization
+0$
+0$    /// @{
+0$    /// Functions to inspect the type of a JSON value.
+0$    /// @name object inspection
+0$
+0$    ///////////////////////
+0$    // object inspection //
+0$    ///////////////////////
+0$  public:
+0$
+0$    /// @}
+0$
+0$    }
+0$        assert_invariant(false);
+0$    {
+0$    ~basic_json() noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/~basic_json/
+0$    /// @brief destructor
+0$
+0$    }
+0$        return *this;
+0$        assert_invariant();
+0$        set_parents();
+0$
+0$        json_base_class_t::operator=(std::move(other));
+0$        swap(m_data.m_value, other.m_data.m_value);
+0$        swap(m_data.m_type, other.m_data.m_type);
+0$        using std::swap;
+0$
+0$        other.assert_invariant();
+0$        // check that passed value is valid
+0$    {
+0$    )
+0$        std::is_nothrow_move_assignable<json_base_class_t>::value
+0$        std::is_nothrow_move_assignable<json_value>::value&&
+0$        std::is_nothrow_move_constructible<json_value>::value&&
+0$        std::is_nothrow_move_assignable<value_t>::value&&
+0$        std::is_nothrow_move_constructible<value_t>::value&&
+0$    basic_json& operator=(basic_json other) noexcept (
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator=/
+0$    /// @brief copy assignment
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$
+0$        other.m_data.m_value = {};
+0$        other.m_data.m_type = value_t::null;
+0$        // invalidate payload
+0$
+0$        other.assert_invariant(false);
+0$        // check that passed value is valid
+0$    {
+0$          m_data(std::move(other.m_data))
+0$        : json_base_class_t(std::forward<json_base_class_t>(other)),
+0$    basic_json(basic_json&& other) noexcept
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief move constructor
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *other.m_data.m_value.binary;
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = other.m_data.m_value.number_float;
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = other.m_data.m_value.number_unsigned;
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = other.m_data.m_value.number_integer;
+0$            {
+0$            case value_t::number_integer:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = other.m_data.m_value.boolean;
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *other.m_data.m_value.string;
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *other.m_data.m_value.array;
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *other.m_data.m_value.object;
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_data.m_type)
+0$
+0$        other.assert_invariant();
+0$        // check of passed value is valid
+0$        m_data.m_type = other.m_data.m_type;
+0$    {
+0$        : json_base_class_t(other)
+0$    basic_json(const basic_json& other)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief copy constructor
+0$
+0$    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}
+0$                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
+0$             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
+0$    template<typename JsonRef,
+0$
+0$    ///////////////////////////////////////
+0$    // other constructors and destructor //
+0$    ///////////////////////////////////////
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$
+0$        }
+0$                JSON_THROW(invalid_iterator::create(206, detail::concat("cannot construct with iterators from ", first.m_object->type_name()), first.m_object));
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *first.m_object->m_data.m_value.binary;
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$                                                       last.m_it.array_iterator);
+0$                m_data.m_value.array = create<array_t>(first.m_it.array_iterator,
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                                        last.m_it.object_iterator);
+0$                m_data.m_value.object = create<object_t>(first.m_it.object_iterator,
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value = *first.m_object->m_data.m_value.string;
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.boolean = first.m_object->m_data.m_value.boolean;
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_float = first.m_object->m_data.m_value.number_float;
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_unsigned = first.m_object->m_data.m_value.number_unsigned;
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                m_data.m_value.number_integer = first.m_object->m_data.m_value.number_integer;
+0$            {
+0$            case value_t::number_integer:
+0$        {
+0$        switch (m_data.m_type)
+0$
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::array:
+0$            case value_t::object:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", first.m_object));
+0$                {
+0$                                         || !last.m_it.primitive_iterator.is_end()))
+0$                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
+0$            {
+0$            case value_t::string:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::number_float:
+0$            case value_t::boolean:
+0$        {
+0$        switch (m_data.m_type)
+0$        // check if iterator range is complete for primitive values
+0$
+0$        m_data.m_type = first.m_object->m_data.m_type;
+0$        // copy type from first iterator
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
+0$        // make sure iterator fits the current value
+0$
+0$        JSON_ASSERT(last.m_object != nullptr);
+0$        JSON_ASSERT(first.m_object != nullptr);
+0$    {
+0$    basic_json(InputIT first, InputIT last)
+0$                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
+0$                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
+0$    template < class InputIT, typename std::enable_if <
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief construct a JSON container given an iterator range
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$    {
+0$        m_data{cnt, val}
+0$    basic_json(size_type cnt, const basic_json& val):
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief construct an array with count copies of given value
+0$
+0$    }
+0$        return basic_json(init, false, value_t::object);
+0$    {
+0$    static basic_json object(initializer_list_t init = {})
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/object/
+0$    /// @brief explicitly create an object from an initializer list
+0$
+0$    }
+0$        return basic_json(init, false, value_t::array);
+0$    {
+0$    static basic_json array(initializer_list_t init = {})
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/array/
+0$    /// @brief explicitly create an array from an initializer list
+0$
+0$    }
+0$        return res;
+0$        res.m_data.m_value = binary_t(std::move(init), subtype);
+0$        res.m_data.m_type = value_t::binary;
+0$        auto res = basic_json();
+0$    {
+0$    static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/binary/
+0$    /// @brief explicitly create a binary array (with subtype)
+0$
+0$    }
+0$        return res;
+0$        res.m_data.m_value = std::move(init);
+0$        res.m_data.m_type = value_t::binary;
+0$        auto res = basic_json();
+0$    {
+0$    static basic_json binary(typename binary_t::container_type&& init)
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/binary/
+0$    /// @brief explicitly create a binary array
+0$
+0$    }
+0$        return res;
+0$        res.m_data.m_value = binary_t(init, subtype);
+0$        res.m_data.m_type = value_t::binary;
+0$        auto res = basic_json();
+0$    {
+0$    static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/binary/
+0$    /// @brief explicitly create a binary array (with subtype)
+0$
+0$    }
+0$        return res;
+0$        res.m_data.m_value = init;
+0$        res.m_data.m_type = value_t::binary;
+0$        auto res = basic_json();
+0$    {
+0$    static basic_json binary(const typename binary_t::container_type& init)
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/binary/
+0$    /// @brief explicitly create a binary array (without subtype)
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$
+0$        }
+0$            m_data.m_value.array = create<array_t>(init.begin(), init.end());
+0$            m_data.m_type = value_t::array;
+0$            // the initializer list describes an array -> create array
+0$        {
+0$        else
+0$        }
+0$            }
+0$                    std::move((*element.m_data.m_value.array)[1]));
+0$                    std::move(*((*element.m_data.m_value.array)[0].m_data.m_value.string)),
+0$                m_data.m_value.object->emplace(
+0$                auto element = element_ref.moved_or_copied();
+0$            {
+0$            for (auto& element_ref : init)
+0$
+0$            m_data.m_value = value_t::object;
+0$            m_data.m_type = value_t::object;
+0$            // the initializer list is a list of pairs -> create object
+0$        {
+0$        if (is_an_object)
+0$
+0$        }
+0$            }
+0$                JSON_THROW(type_error::create(301, "cannot create object from initializer list", nullptr));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
+0$            // if object is wanted but impossible, throw an exception
+0$
+0$            }
+0$                is_an_object = false;
+0$            {
+0$            if (manual_type == value_t::array)
+0$            // if array is wanted, do not create an object though possible
+0$        {
+0$        if (!type_deduction)
+0$        // adjust type if type deduction is not wanted
+0$
+0$        });
+0$            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[static_cast<size_type>(0)].is_string();
+0$            // broken call to op[key_type], the wrong semantics and a 4804 warning on Windows)
+0$            // (many string types can be constructed from 0 via its null-pointer guise, so we get a
+0$            // The cast is to ensure op[size_type] is called, bearing in mind size_type may not be int;
+0$        {
+0$                                        [](const detail::json_ref<basic_json>& element_ref)
+0$        bool is_an_object = std::all_of(init.begin(), init.end(),
+0$        // element is a string
+0$        // check if each element is an array with two elements whose first
+0$    {
+0$               value_t manual_type = value_t::array)
+0$               bool type_deduction = true,
+0$    basic_json(initializer_list_t init,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief create a container (array or object) from an initializer list
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$        JSON_ASSERT(m_data.m_type == val.type());
+0$        }
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$            default:            // LCOV_EXCL_LINE
+0$                break;
+0$                m_data.m_type = value_t::discarded;
+0$            case value_t::discarded:
+0$                break;
+0$                *this = nullptr;
+0$            case value_t::null:
+0$                break;
+0$                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
+0$            case value_t::binary:
+0$                break;
+0$                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
+0$            case value_t::array:
+0$                break;
+0$                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
+0$            case value_t::object:
+0$                break;
+0$                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
+0$            case value_t::string:
+0$                break;
+0$                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
+0$            case value_t::number_unsigned:
+0$                break;
+0$                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
+0$            case value_t::number_integer:
+0$                break;
+0$                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
+0$            case value_t::number_float:
+0$                break;
+0$                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
+0$            case value_t::boolean:
+0$        {
+0$        switch (val.type())
+0$
+0$        using other_binary_t = typename BasicJsonType::binary_t;
+0$        using other_array_t = typename BasicJsonType::array_t;
+0$        using other_object_t = typename BasicJsonType::object_t;
+0$        using other_string_t = typename BasicJsonType::string_t;
+0$        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$        using other_number_integer_t = typename BasicJsonType::number_integer_t;
+0$        using other_number_float_t = typename BasicJsonType::number_float_t;
+0$        using other_boolean_t = typename BasicJsonType::boolean_t;
+0$    {
+0$    basic_json(const BasicJsonType& val)
+0$                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
+0$               detail::enable_if_t <
+0$    template < typename BasicJsonType,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief create a JSON value from an existing one
+0$
+0$    }
+0$        assert_invariant();
+0$        set_parents();
+0$        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
+0$    {
+0$                                           std::forward<CompatibleType>(val))))
+0$                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
+0$    basic_json(CompatibleType && val) noexcept(noexcept( // NOLINT(bugprone-forwarding-reference-overload,bugprone-exception-escape)
+0$                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
+0$               detail::enable_if_t <
+0$               typename U = detail::uncvref_t<CompatibleType>,
+0$    template < typename CompatibleType,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief create a JSON value from compatible types
+0$
+0$    }
+0$        assert_invariant();
+0$    {
+0$        : basic_json(value_t::null)
+0$    basic_json(std::nullptr_t = nullptr) noexcept // NOLINT(bugprone-exception-escape)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief create a null object
+0$
+0$    }
+0$        assert_invariant();
+0$    {
+0$        : m_data(v)
+0$    basic_json(const value_t v)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
+0$    /// @brief create an empty value with a given type
+0$
+0$    /// @{
+0$    /// assignment, static functions creating objects, and the destructor.
+0$    /// Constructors of class @ref basic_json, copy/move constructor, copy
+0$    /// @name constructors and destructors
+0$
+0$    //////////////////
+0$    // constructors //
+0$    //////////////////
+0$
+0$    using parser_callback_t = detail::parser_callback_t<basic_json>;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/parser_callback_t/
+0$    /// @brief per-element parser callback type
+0$
+0$    using parse_event_t = detail::parse_event_t;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/parse_event_t/
+0$    /// @brief parser event types
+0$
+0$    //////////////////////////
+0$    // JSON parser callback //
+0$    //////////////////////////
+0$  public:
+0$
+0$    }
+0$        return j;
+0$#endif
+0$        static_cast<void>(old_capacity);
+0$        static_cast<void>(j);
+0$#else
+0$        j.m_parent = this;
+0$
+0$#endif
+0$#pragma warning( pop )
+0$#ifdef JSON_HEDLEY_MSVC_VERSION
+0$        }
+0$            return j;
+0$            set_parents();
+0$        {
+0$        if (detail::is_ordered_map<object_t>::value)
+0$#endif
+0$#pragma warning(disable : 4127) // ignore warning to replace if with if constexpr
+0$#pragma warning(push )
+0$#ifdef JSON_HEDLEY_MSVC_VERSION
+0$        // been invalidated; see https://github.com/nlohmann/json/issues/2962
+0$        // ordered_json uses a vector internally, so pointers could have
+0$
+0$        }
+0$            }
+0$                return j;
+0$                set_parents();
+0$                // capacity has changed: update all parents
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
+0$            JSON_ASSERT(type() == value_t::array);
+0$            // see https://github.com/nlohmann/json/issues/2838
+0$        {
+0$        if (old_capacity != static_cast<std::size_t>(-1))
+0$#if JSON_DIAGNOSTICS
+0$    {
+0$    reference set_parent(reference j, std::size_t old_capacity = static_cast<std::size_t>(-1))
+0$
+0$    }
+0$        return it;
+0$#endif
+0$        static_cast<void>(count_set_parents);
+0$#else
+0$        }
+0$            (it + i)->m_parent = this;
+0$        {
+0$        for (typename iterator::difference_type i = 0; i < count_set_parents; ++i)
+0$#if JSON_DIAGNOSTICS
+0$    {
+0$    iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
+0$
+0$    }
+0$#endif
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    element.second.m_parent = this;
+0$                {
+0$                for (auto& element : *m_data.m_value.object)
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    element.m_parent = this;
+0$                {
+0$                for (auto& element : *m_data.m_value.array)
+0$            {
+0$            case value_t::array:
+0$        {
+0$        switch (m_data.m_type)
+0$#if JSON_DIAGNOSTICS
+0$    {
+0$    void set_parents()
+0$
+0$    }
+0$        static_cast<void>(check_parents);
+0$#endif
+0$        JSON_CATCH(...) {} // LCOV_EXCL_LINE
+0$        }
+0$            }));
+0$                return j.m_parent == this;
+0$            {
+0$            JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
+0$            // cppcheck-suppress assertWithSideEffect
+0$        {
+0$        JSON_TRY
+0$#if JSON_DIAGNOSTICS
+0$
+0$        JSON_ASSERT(m_data.m_type != value_t::binary || m_data.m_value.binary != nullptr);
+0$        JSON_ASSERT(m_data.m_type != value_t::string || m_data.m_value.string != nullptr);
+0$        JSON_ASSERT(m_data.m_type != value_t::array || m_data.m_value.array != nullptr);
+0$        JSON_ASSERT(m_data.m_type != value_t::object || m_data.m_value.object != nullptr);
+0$    {
+0$    void assert_invariant(bool check_parents = true) const noexcept
+0$    */
+0$               need to hold.
+0$               during destruction of objects when the invariant does not
+0$               The value is true by default and should only be set to false
+0$    @param[in] check_parents  whether the parent relation should be checked.
+0$
+0$    container's elements must have the current value as parent.
+0$    @a check_parents true and the value is an array or object, then the
+0$    Furthermore, the parent relation is checked for arrays and objects: If
+0$
+0$    @a m_type and @a m_value.
+0$    value is changed, because the invariant expresses a relationship between
+0$    invariant. Furthermore, it has to be called each time the type of a JSON
+0$    end of every constructor to make sure that created objects respect the
+0$    This function asserts the class invariants. It needs to be called at the
+0$
+0$    @brief checks the class invariants
+0$    /*!
+0$  private:
+0$
+0$    };
+0$        }
+0$            }
+0$                }
+0$                    break;
+0$                {
+0$                default:
+0$                case value_t::discarded:
+0$                case value_t::number_float:
+0$                case value_t::number_unsigned:
+0$                case value_t::number_integer:
+0$                case value_t::boolean:
+0$                case value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
+0$                    AllocatorType<binary_t> alloc;
+0$                {
+0$                case value_t::binary:
+0$
+0$                }
+0$                    break;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
+0$                    AllocatorType<string_t> alloc;
+0$                {
+0$                case value_t::string:
+0$
+0$                }
+0$                    break;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
+0$                    AllocatorType<array_t> alloc;
+0$                {
+0$                case value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
+0$                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
+0$                    AllocatorType<object_t> alloc;
+0$                {
+0$                case value_t::object:
+0$            {
+0$            switch (t)
+0$
+0$            }
+0$                }
+0$                    // since it doesn't have any children
+0$                    // it's now safe that current_item get destructed
+0$
+0$                    }
+0$                        current_item.m_data.m_value.object->clear();
+0$
+0$                        }
+0$                            stack.push_back(std::move(it.second));
+0$                        {
+0$                        for (auto&& it : *current_item.m_data.m_value.object)
+0$                    {
+0$                    else if (current_item.is_object())
+0$                    }
+0$                        current_item.m_data.m_value.array->clear();
+0$
+0$                        std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));
+0$                    {
+0$                    if (current_item.is_array())
+0$                    // its children to the stack to be processed later
+0$                    // if current_item is array/object, move
+0$
+0$                    stack.pop_back();
+0$                    basic_json current_item(std::move(stack.back()));
+0$                    // move the last item to local variable to be processed
+0$                {
+0$                while (!stack.empty())
+0$
+0$                }
+0$                    }
+0$                        stack.push_back(std::move(it.second));
+0$                    {
+0$                    for (auto&& it : *object)
+0$                    stack.reserve(object->size());
+0$                {
+0$                else
+0$                }
+0$                    std::move(array->begin(), array->end(), std::back_inserter(stack));
+0$                    stack.reserve(array->size());
+0$                {
+0$                if (t == value_t::array)
+0$                // move the top-level items to stack
+0$
+0$                std::vector<basic_json> stack;
+0$                // flatten the current json_value to a heap-allocated stack
+0$            {
+0$            if (t == value_t::array || t == value_t::object)
+0$            }
+0$                return;
+0$                //not initialized (e.g. due to exception in the ctor)
+0$            {
+0$            )
+0$                (t == value_t::binary && binary == nullptr)
+0$                (t == value_t::string && string == nullptr) ||
+0$                (t == value_t::array && array == nullptr) ||
+0$                (t == value_t::object && object == nullptr) ||
+0$            if (
+0$        {
+0$        void destroy(value_t t)
+0$
+0$        json_value(binary_t&& value) : binary(create<binary_t>(std::move(value))) {}
+0$        /// constructor for rvalue binary arrays (internal type)
+0$
+0$        json_value(const binary_t& value) : binary(create<binary_t>(value)) {}
+0$        /// constructor for binary arrays (internal type)
+0$
+0$        json_value(typename binary_t::container_type&& value) : binary(create<binary_t>(std::move(value))) {}
+0$        /// constructor for rvalue binary arrays
+0$
+0$        json_value(const typename binary_t::container_type& value) : binary(create<binary_t>(value)) {}
+0$        /// constructor for binary arrays
+0$
+0$        json_value(array_t&& value) : array(create<array_t>(std::move(value))) {}
+0$        /// constructor for rvalue arrays
+0$
+0$        json_value(const array_t& value) : array(create<array_t>(value)) {}
+0$        /// constructor for arrays
+0$
+0$        json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}
+0$        /// constructor for rvalue objects
+0$
+0$        json_value(const object_t& value) : object(create<object_t>(value)) {}
+0$        /// constructor for objects
+0$
+0$        json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}
+0$        /// constructor for rvalue strings
+0$
+0$        json_value(const string_t& value) : string(create<string_t>(value)) {}
+0$        /// constructor for strings
+0$
+0$        }
+0$            }
+0$                }
+0$                    break;
+0$                    }
+0$                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.3", nullptr)); // LCOV_EXCL_LINE
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
+0$                    object = nullptr;  // silence warning, see #821
+0$                {
+0$                default:
+0$                case value_t::discarded:
+0$
+0$                }
+0$                    break;
+0$                    object = nullptr;  // silence warning, see #821
+0$                {
+0$                case value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    number_float = static_cast<number_float_t>(0.0);
+0$                {
+0$                case value_t::number_float:
+0$
+0$                }
+0$                    break;
+0$                    number_unsigned = static_cast<number_unsigned_t>(0);
+0$                {
+0$                case value_t::number_unsigned:
+0$
+0$                }
+0$                    break;
+0$                    number_integer = static_cast<number_integer_t>(0);
+0$                {
+0$                case value_t::number_integer:
+0$
+0$                }
+0$                    break;
+0$                    boolean = static_cast<boolean_t>(false);
+0$                {
+0$                case value_t::boolean:
+0$
+0$                }
+0$                    break;
+0$                    binary = create<binary_t>();
+0$                {
+0$                case value_t::binary:
+0$
+0$                }
+0$                    break;
+0$                    string = create<string_t>("");
+0$                {
+0$                case value_t::string:
+0$
+0$                }
+0$                    break;
+0$                    array = create<array_t>();
+0$                {
+0$                case value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    object = create<object_t>();
+0$                {
+0$                case value_t::object:
+0$            {
+0$            switch (t)
+0$        {
+0$        json_value(value_t t)
+0$        /// constructor for empty values of a given type
+0$        json_value(number_float_t v) noexcept : number_float(v) {}
+0$        /// constructor for numbers (floating-point)
+0$        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
+0$        /// constructor for numbers (unsigned)
+0$        json_value(number_integer_t v) noexcept : number_integer(v) {}
+0$        /// constructor for numbers (integer)
+0$        json_value(boolean_t v) noexcept : boolean(v) {}
+0$        /// constructor for booleans
+0$        json_value() = default;
+0$        /// default constructor (for null values)
+0$
+0$        number_float_t number_float;
+0$        /// number (floating-point)
+0$        number_unsigned_t number_unsigned;
+0$        /// number (unsigned integer)
+0$        number_integer_t number_integer;
+0$        /// number (integer)
+0$        boolean_t boolean;
+0$        /// boolean
+0$        binary_t* binary;
+0$        /// binary (stored with pointer to save storage)
+0$        string_t* string;
+0$        /// string (stored with pointer to save storage)
+0$        array_t* array;
+0$        /// array (stored with pointer to save storage)
+0$        object_t* object;
+0$        /// object (stored with pointer to save storage)
+0$    {
+0$    union json_value
+0$    */
+0$    @since version 1.0.0
+0$
+0$    value types are used.
+0$    pointers. The size of the union should not exceed 64 bits if the default
+0$    @note Variable-length types (objects, arrays, and strings) are stored as
+0$
+0$    null      | null            | *no value is stored*
+0$    binary    | binary          | pointer to @ref binary_t
+0$    number    | number_float    | @ref number_float_t
+0$    number    | number_unsigned | @ref number_unsigned_t
+0$    number    | number_integer  | @ref number_integer_t
+0$    boolean   | boolean         | @ref boolean_t
+0$    string    | string          | pointer to @ref string_t
+0$    array     | array           | pointer to @ref array_t
+0$    object    | object          | pointer to @ref object_t
+0$    --------- | --------------- | ------------------------
+0$    JSON type | value_t type    | used type
+0$
+0$    defined in @ref value_t.
+0$    union combines the different storage types for the JSON value types
+0$    The actual storage for a JSON value of the @ref basic_json class. This
+0$
+0$    @brief a JSON value
+0$    /*!
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    ////////////////////////
+0$    // JSON value storage //
+0$    ////////////////////////
+0$
+0$    }
+0$        return obj.release();
+0$        JSON_ASSERT(obj != nullptr);
+0$        AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
+0$        std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
+0$        };
+0$            AllocatorTraits::deallocate(alloc, obj, 1);
+0$        {
+0$        auto deleter = [&](T * obj)
+0$
+0$        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;
+0$        AllocatorType<T> alloc;
+0$    {
+0$    static T* create(Args&& ... args)
+0$    JSON_HEDLEY_RETURNS_NON_NULL
+0$    template<typename T, typename... Args>
+0$    /// helper for exception-safe object creation
+0$
+0$  private:
+0$
+0$    /// @}
+0$
+0$    using object_comparator_t = detail::actual_object_comparator_t<basic_json>;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/object_comparator_t/
+0$    /// @brief object key comparator type
+0$
+0$    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/binary_t/
+0$    /// @brief a type for a packed binary type
+0$
+0$    using number_float_t = NumberFloatType;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/number_float_t/
+0$    /// @brief a type for a number (floating-point)
+0$
+0$    using number_unsigned_t = NumberUnsignedType;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/number_unsigned_t/
+0$    /// @brief a type for a number (unsigned)
+0$
+0$    using number_integer_t = NumberIntegerType;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/number_integer_t/
+0$    /// @brief a type for a number (integer)
+0$
+0$    using boolean_t = BooleanType;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/boolean_t/
+0$    /// @brief a type for a boolean
+0$
+0$    using string_t = StringType;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/string_t/
+0$    /// @brief a type for a string
+0$
+0$    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
+0$    /// @sa https://json.nlohmann.me/api/basic_json/array_t/
+0$    /// @brief a type for an array
+0$
+0$          basic_json>>>;
+0$          AllocatorType<std::pair<const StringType,
+0$          default_object_comparator_t,
+0$          basic_json,
+0$    using object_t = ObjectType<StringType,
+0$    /// @sa https://json.nlohmann.me/api/basic_json/object_t/
+0$    /// @brief a type for an object
+0$
+0$#endif
+0$    using default_object_comparator_t = std::less<StringType>;
+0$#else
+0$    using default_object_comparator_t = std::less<>;
+0$    // in functions involving lookup by key with types other than object_t::key_type (aka. StringType)
+0$    // use of transparent comparator avoids unnecessary repeated construction of temporaries
+0$#if defined(JSON_HAS_CPP_14)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/default_object_comparator_t/
+0$    /// different.
+0$    /// The actual object key comparator type (@ref object_comparator_t) may be
+0$    /// @brief default object key comparator type
+0$
+0$    /// @{
+0$    /// the template arguments passed to class @ref basic_json.
+0$    /// The data types to store a JSON value. These types are derived from
+0$    /// @name JSON value data types
+0$
+0$    ///////////////////////////
+0$    // JSON value data types //
+0$    ///////////////////////////
+0$
+0$    }
+0$        return result;
+0$#endif
+0$        result["compiler"]["c++"] = "unknown";
+0$#else
+0$        result["compiler"]["c++"] = std::to_string(__cplusplus);
+0$#elif defined(__cplusplus)
+0$        result["compiler"]["c++"] = std::to_string(_MSVC_LANG);
+0$#if defined(_MSVC_LANG)
+0$
+0$#endif
+0$        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
+0$#else
+0$        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
+0$#elif defined(__SUNPRO_CC)
+0$        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
+0$#elif defined(__PGI)
+0$        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
+0$#elif defined(_MSC_VER)
+0$        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
+0$#elif defined(__IBMCPP__)
+0$        result["compiler"] = "hp"
+0$#elif defined(__HP_cc) || defined(__HP_aCC)
+0$        };
+0$            }
+0$                    std::to_string(__GNUC_PATCHLEVEL__))
+0$                    std::to_string(__GNUC_MINOR__), '.',
+0$                    std::to_string(__GNUC__), '.',
+0$        result["compiler"] = {{"family", "gcc"}, {"version", detail::concat(
+0$#elif defined(__GNUC__) || defined(__GNUG__)
+0$        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
+0$#elif defined(__clang__)
+0$        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
+0$#if defined(__ICC) || defined(__INTEL_COMPILER)
+0$
+0$#endif
+0$        result["platform"] = "unknown";
+0$#else
+0$        result["platform"] = "unix";
+0$#elif defined __unix__
+0$        result["platform"] = "apple";
+0$#elif defined __APPLE__
+0$        result["platform"] = "linux";
+0$#elif defined __linux__
+0$        result["platform"] = "win32";
+0$#ifdef _WIN32
+0$
+0$        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;
+0$        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
+0$        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
+0$                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));
+0$                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',
+0$            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',
+0$        result["version"]["string"] =
+0$        result["url"] = "https://github.com/nlohmann/json";
+0$        result["name"] = "JSON for Modern C++";
+0$        result["copyright"] = "(C) 2013-2023 Niels Lohmann";
+0$
+0$        basic_json result;
+0$    {
+0$    static basic_json meta()
+0$    JSON_HEDLEY_WARN_UNUSED_RESULT
+0$    /// @sa https://json.nlohmann.me/api/basic_json/meta/
+0$    /// @brief returns version information on the library
+0$
+0$    }
+0$        return allocator_type();
+0$    {
+0$    static allocator_type get_allocator()
+0$    /// @sa https://json.nlohmann.me/api/basic_json/get_allocator/
+0$    /// @brief returns the allocator associated with the container
+0$
+0$    /// @}
+0$
+0$    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;
+0$    /// a const reverse iterator for a basic_json container
+0$    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
+0$    /// a reverse iterator for a basic_json container
+0$    using const_iterator = iter_impl<const basic_json>;
+0$    /// a const iterator for a basic_json container
+0$    using iterator = iter_impl<basic_json>;
+0$    /// an iterator for a basic_json container
+0$
+0$    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;
+0$    /// the type of an element const pointer
+0$    using pointer = typename std::allocator_traits<allocator_type>::pointer;
+0$    /// the type of an element pointer
+0$
+0$    using allocator_type = AllocatorType<basic_json>;
+0$    /// the allocator type
+0$
+0$    using size_type = std::size_t;
+0$    /// a type to represent container sizes
+0$    using difference_type = std::ptrdiff_t;
+0$    /// a type to represent differences between iterators
+0$
+0$    using const_reference = const value_type&;
+0$    /// the type of an element const reference
+0$    using reference = value_type&;
+0$    /// the type of an element reference
+0$
+0$    using value_type = basic_json;
+0$    /// the type of elements in a basic_json container
+0$
+0$    /// @{
+0$    /// container.
+0$    /// The canonic container types to use @ref basic_json like any other STL
+0$    /// @name container types
+0$
+0$    /////////////////////
+0$    // container types //
+0$    /////////////////////
+0$
+0$    /// @}
+0$
+0$    using other_error = detail::other_error;
+0$    using out_of_range = detail::out_of_range;
+0$    using type_error = detail::type_error;
+0$    using invalid_iterator = detail::invalid_iterator;
+0$    using parse_error = detail::parse_error;
+0$    using exception = detail::exception;
+0$
+0$    /// @{
+0$    /// Classes to implement user-defined exceptions.
+0$    /// @name exceptions
+0$
+0$    ////////////////
+0$    // exceptions //
+0$    ////////////////
+0$
+0$    using json_sax_t = json_sax<basic_json>;
+0$    /// SAX interface type, see @ref nlohmann::json_sax
+0$    using input_format_t = detail::input_format_t;
+0$
+0$    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;
+0$    /// helper type for initializer lists of basic_json values
+0$    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
+0$    /// how to treat CBOR tags
+0$    using error_handler_t = detail::error_handler_t;
+0$    /// how to treat decoding errors
+0$    using json_serializer = JSONSerializer<T, SFINAE>;
+0$    template<typename T, typename SFINAE>
+0$    using json_pointer = ::nlohmann::json_pointer<StringType>;
+0$    /// JSON Pointer, see @ref nlohmann::json_pointer
+0$    using value_t = detail::value_t;
+0$  public:
+0$
+0$    using serializer = ::nlohmann::detail::serializer<basic_json>;
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;
+0$    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
+0$    template<typename InputType>
+0$
+0$    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;
+0$    template<typename CharType>
+0$
+0$    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;
+0$    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
+0$    template<typename Iterator>
+0$    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
+0$    template<typename BasicJsonType>
+0$    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
+0$    template<typename BasicJsonType>
+0$    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
+0$  private:
+0$
+0$    }
+0$                std::move(cb), allow_exceptions, ignore_comments);
+0$        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
+0$    {
+0$                                 )
+0$        const bool ignore_comments = false
+0$        const bool allow_exceptions = true,
+0$        detail::parser_callback_t<basic_json>cb = nullptr,
+0$        InputAdapterType adapter,
+0$    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
+0$    template<typename InputAdapterType>
+0$
+0$    using lexer = ::nlohmann::detail::lexer_base<basic_json>;
+0$    // convenience aliases for types residing in namespace detail;
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    using json_base_class_t = ::nlohmann::detail::json_base_class<CustomBaseClass>;
+0$    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
+0$    /// workaround type for MSVC
+0$
+0$    friend class ::nlohmann::detail::exception;
+0$    friend class ::nlohmann::detail::json_sax_dom_callback_parser;
+0$    template<typename BasicJsonType>
+0$    friend class ::nlohmann::detail::json_sax_dom_parser;
+0$    template<typename BasicJsonType>
+0$    friend class ::nlohmann::detail::binary_reader;
+0$    template<typename BasicJsonType, typename InputType, typename SAX>
+0$    friend class ::nlohmann::detail::binary_writer;
+0$    template<typename BasicJsonType, typename CharType>
+0$    friend class ::nlohmann::detail::iter_impl;
+0$    template<typename BasicJsonType>
+0$    friend ::nlohmann::detail::serializer<basic_json>;
+0$    friend class ::nlohmann::detail::parser;
+0$    template<typename BasicJsonType, typename InputType>
+0$
+0$    // friend ::nlohmann::json_pointer<StringType>;
+0$    // can be restored when json_pointer backwards compatibility is removed
+0$    friend class ::nlohmann::json_pointer;
+0$    template<typename>
+0$
+0$    template<detail::value_t> friend struct detail::external_constructor;
+0$  private:
+0${
+0$    : public ::nlohmann::detail::json_base_class<CustomBaseClass>
+0$class basic_json // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
+0$NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$*/
+0$@nosubgrouping
+0$
+0$@since version 1.0.0
+0$
+0$@endinternal
+0$@note ObjectType trick from https://stackoverflow.com/a/9860911
+0$
+0$The invariants are checked by member function assert_invariant().
+0$- If `m_type == value_t::string`, then `m_value.string != nullptr`.
+0$- If `m_type == value_t::array`, then `m_value.array != nullptr`.
+0$- If `m_type == value_t::object`, then `m_value.object != nullptr`.
+0$relationship:
+0$@invariant The member variables @a m_value and @a m_type have the following
+0$@internal
+0$
+0$@brief a class to store JSON values
+0$/*!
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$*/
+0$@since version 1.0.0
+0$@see https://github.com/nlohmann
+0$@brief namespace for Niels Lohmann
+0$/*!
+0$
+0$#endif
+0$    #include <string_view>
+0$    #endif
+0$        #include <any>
+0$    #if JSON_HAS_STATIC_RTTI
+0$#if defined(JSON_HAS_CPP_17)
+0$
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$};
+0$    JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
+0$private:
+0$
+0$    }
+0$        }
+0$            insert(*it);
+0$        {
+0$        for (auto it = first; it != last; ++it)
+0$    {
+0$    void insert(InputIt first, InputIt last)
+0$    template<typename InputIt, typename = require_input_iter<InputIt>>
+0$
+0$            std::input_iterator_tag>::value>::type;
+0$    using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
+0$    template<typename InputIt>
+0$
+0$    }
+0$        return {--this->end(), true};
+0$        Container::push_back(value);
+0$        }
+0$            }
+0$                return {it, false};
+0$            {
+0$            if (m_compare(it->first, value.first))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    std::pair<iterator, bool> insert( const value_type& value )
+0$
+0$    }
+0$        return emplace(value.first, std::move(value.second));
+0$    {
+0$    std::pair<iterator, bool> insert( value_type&& value )
+0$
+0$    }
+0$        return Container::end();
+0$        }
+0$            }
+0$                return it;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    const_iterator find(const key_type& key) const
+0$
+0$    }
+0$        return Container::end();
+0$        }
+0$            }
+0$                return it;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    iterator find(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return Container::end();
+0$        }
+0$            }
+0$                return it;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    iterator find(const key_type& key)
+0$
+0$    }
+0$        return 0;
+0$        }
+0$            }
+0$                return 1;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    size_type count(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return 0;
+0$        }
+0$            }
+0$                return 1;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    size_type count(const key_type& key) const
+0$
+0$    }
+0$        return Container::begin() + offset;
+0$        // resize call. Instead, we can return begin() + offset.
+0$        // use this iterator, because it may have been invalidated by the
+0$        // first is now pointing past the last deleted element, but we cannot
+0$
+0$        //             first    last
+0$        //               ^        ^
+0$        // [ a, b, c, d, h, i, j ]
+0$
+0$        Container::resize(this->size() - static_cast<size_type>(elements_affected));
+0$        // remove the unneeded elements at the end of the vector
+0$
+0$        //             first    last
+0$        //               ^        ^
+0$        // [ a, b, c, d, h, i, j, h, i, j ]
+0$
+0$        }
+0$            new (&*it) value_type{std::move(*std::next(it, elements_affected))}; // "move" next element to it
+0$            it->~value_type(); // destroy but keep allocation
+0$        {
+0$        for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
+0$
+0$        //               it       it + elements_affected
+0$        //               ^        ^
+0$        // [ a, b, c, d, e, f, g, h, i, j ]
+0$        //               v        |   destroy e and re-construct with h
+0$        //               ,--------.
+0$
+0$        // the back of the vector. Example for first iteration:
+0$        // We start at first and re-construct (viz. copy) the elements from
+0$        // Since we cannot move const Keys, we re-construct them in place.
+0$
+0$        //             first    last
+0$        //               ^        ^
+0$        // [ a, b, c, d, e, f, g, h, i, j ]
+0$
+0$        // to first. We will need this later.
+0$        // Note that offset is the distance from the start of the vector
+0$        // iterator past the last deleted element (h in this example).
+0$        // elements (3 in this example: e, f, g), and need to return an
+0$        // This is the start situation. We need to delete elements_affected
+0$
+0$        const auto offset = std::distance(Container::begin(), first);
+0$        const auto elements_affected = std::distance(first, last);
+0$
+0$        }
+0$            return first;
+0$        {
+0$        if (first == last)
+0$    {
+0$    iterator erase(iterator first, iterator last)
+0$
+0$    }
+0$        return erase(pos, std::next(pos));
+0$    {
+0$    iterator erase(iterator pos)
+0$
+0$    }
+0$        return 0;
+0$        }
+0$            }
+0$                return 1;
+0$                Container::pop_back();
+0$                }
+0$                    new (&*it) value_type{std::move(*next)};
+0$                    it->~value_type(); // Destroy but keep allocation
+0$                {
+0$                for (auto next = it; ++next != this->end(); ++it)
+0$                // Since we cannot move const Keys, re-construct them in place
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    size_type erase(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return 0;
+0$        }
+0$            }
+0$                return 1;
+0$                Container::pop_back();
+0$                }
+0$                    new (&*it) value_type{std::move(*next)};
+0$                    it->~value_type(); // Destroy but keep allocation
+0$                {
+0$                for (auto next = it; ++next != this->end(); ++it)
+0$                // Since we cannot move const Keys, re-construct them in place
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    size_type erase(const key_type& key)
+0$
+0$    }
+0$        JSON_THROW(std::out_of_range("key not found"));
+0$
+0$        }
+0$            }
+0$                return it->second;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    const T & at(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        JSON_THROW(std::out_of_range("key not found"));
+0$
+0$        }
+0$            }
+0$                return it->second;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    const T& at(const key_type& key) const
+0$
+0$    }
+0$        JSON_THROW(std::out_of_range("key not found"));
+0$
+0$        }
+0$            }
+0$                return it->second;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    T & at(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        JSON_THROW(std::out_of_range("key not found"));
+0$
+0$        }
+0$            }
+0$                return it->second;
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    T& at(const key_type& key)
+0$
+0$    }
+0$        return at(std::forward<KeyType>(key));
+0$    {
+0$    const T & operator[](KeyType && key) const
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return at(key);
+0$    {
+0$    const T& operator[](const key_type& key) const
+0$
+0$    }
+0$        return emplace(std::forward<KeyType>(key), T{}).first->second;
+0$    {
+0$    T & operator[](KeyType && key)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return emplace(key, T{}).first->second;
+0$    {
+0$    T& operator[](const key_type& key)
+0$
+0$    }
+0$        return {std::prev(this->end()), true};
+0$        Container::emplace_back(std::forward<KeyType>(key), std::forward<T>(t));
+0$        }
+0$            }
+0$                return {it, false};
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    std::pair<iterator, bool> emplace(KeyType && key, T && t)
+0$                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
+0$    template<class KeyType, detail::enable_if_t<
+0$
+0$    }
+0$        return {std::prev(this->end()), true};
+0$        Container::emplace_back(key, std::forward<T>(t));
+0$        }
+0$            }
+0$                return {it, false};
+0$            {
+0$            if (m_compare(it->first, key))
+0$        {
+0$        for (auto it = this->begin(); it != this->end(); ++it)
+0$    {
+0$    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
+0$
+0$        : Container{init, alloc} {}
+0$    ordered_map(std::initializer_list<value_type> init, const Allocator& alloc = Allocator() )
+0$        : Container{first, last, alloc} {}
+0$    ordered_map(It first, It last, const Allocator& alloc = Allocator())
+0$    template <class It>
+0$    explicit ordered_map(const Allocator& alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
+0$    ordered_map() noexcept(noexcept(Container())) : Container{} {}
+0$    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
+0$    // Explicit constructors instead of `using Container::Container`
+0$
+0$#endif
+0$    using key_compare = std::equal_to<Key>;
+0$#else
+0$    using key_compare = std::equal_to<>;
+0$#ifdef JSON_HAS_CPP_14
+0$    using value_type = typename Container::value_type;
+0$    using size_type = typename Container::size_type;
+0$    using const_iterator = typename Container::const_iterator;
+0$    using iterator = typename Container::iterator;
+0$    using Container = std::vector<std::pair<const Key, T>, Allocator>;
+0$    using mapped_type = T;
+0$    using key_type = Key;
+0${
+0$                  struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
+0$          class Allocator = std::allocator<std::pair<const Key, T>>>
+0$template <class Key, class T, class IgnoredLess = std::less<Key>,
+0$/// for use within nlohmann::basic_json<ordered_map>
+0$/// ordered_map: a minimal map-like container that preserves insertion order
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // pair
+0$#include <type_traits> // enable_if, is_convertible
+0$#include <stdexcept> // for out_of_range
+0$#include <memory> // allocator
+0$#include <iterator> // input_iterator_tag, iterator_traits
+0$#include <initializer_list> // initializer_list
+0$#include <functional> // equal_to, less
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/ordered_map.hpp>
+0$
+0$// #include <nlohmann/json_fwd.hpp>
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    const error_handler_t error_handler;
+0$    /// error_handler how to react on decoding errors
+0$
+0$    string_t indent_string;
+0$    /// the indentation string
+0$    const char indent_char;
+0$    /// the indentation character
+0$
+0$    std::array<char, 512> string_buffer{{}};
+0$    /// string buffer
+0$
+0$    const char decimal_point = '\0';
+0$    /// the locale's decimal point character
+0$    const char thousands_sep = '\0';
+0$    /// the locale's thousand separator character
+0$    const std::lconv* loc = nullptr;
+0$    /// the locale
+0$
+0$    std::array<char, 64> number_buffer{{}};
+0$    /// a (hopefully) large enough character buffer
+0$
+0$    output_adapter_t<char> o = nullptr;
+0$    /// the output of the serializer
+0$  private:
+0$
+0$    }
+0$        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
+0$        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); // NOLINT(misc-redundant-expression)
+0$    {
+0$    inline number_unsigned_t remove_sign(number_integer_t x) noexcept
+0$     */
+0$     * #1708 for details.
+0$     * absolute values of INT_MIN and INT_MAX are usually not the same. See
+0$     * not directly remove the sign of an arbitrary signed integer as the
+0$     * value as unsigned integer. The plus/minus shuffling is necessary as we can
+0$     * This function takes a negative signed integer and returns its absolute
+0$     *
+0$     * Helper function for dump_integer
+0$    /*
+0$
+0$    }
+0$        return x; // LCOV_EXCL_LINE
+0$        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$    {
+0$    number_unsigned_t remove_sign(number_unsigned_t x)
+0$     */
+0$     * Must never be called.
+0$     * dump_integer for number_unsigned_t.
+0$     * Overload to make the compiler happy while it is instantiating
+0$    /*
+0$
+0$    }
+0$        return state;
+0$        state = utf8d[index];
+0$        JSON_ASSERT(index < utf8d.size());
+0$        const std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
+0$
+0$                : (0xFFu >> type) & (byte);
+0$                ? (byte & 0x3fu) | (codep << 6u)
+0$        codep = (state != UTF8_ACCEPT)
+0$
+0$        const std::uint8_t type = utf8d[byte];
+0$        JSON_ASSERT(byte < utf8d.size());
+0$
+0$        };
+0$            }
+0$                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
+0$                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
+0$                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
+0$                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
+0$                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
+0$                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
+0$                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
+0$                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
+0$                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
+0$                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
+0$                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
+0$                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
+0$                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
+0$                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
+0$            {
+0$        {
+0$        static const std::array<std::uint8_t, 400> utf8d =
+0$    {
+0$    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
+0$    */
+0$    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
+0$    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
+0$
+0$    @note The function has been edited: a std::array is used.
+0$
+0$    @return               new state
+0$    @param[in] byte       next byte to decode
+0$    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
+0$    @param[in,out] state  the state of the decoding
+0$
+0$    followed.
+0$    prematurely; that is, the last byte indicated more bytes should have
+0$    completely processed, but the state is non-zero, the string ended
+0$    be rejected, because the current byte is not allowed. If the string is
+0$    be called initially with state 0 (accept). State 1 means the string must
+0$    result of the check is stored in the @a state parameter. The function must
+0$    The function checks each byte of a string whether it is UTF-8 encoded. The
+0$
+0$    @brief check whether a string is UTF-8 encoded
+0$    /*!
+0$
+0$    }
+0$        }
+0$            o->write_characters(".0", 2);
+0$        {
+0$        if (value_is_int_like)
+0$
+0$        });
+0$            return c == '.' || c == 'e';
+0$        {
+0$                         [](char c)
+0$            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
+0$        const bool value_is_int_like =
+0$        // determine if we need to append ".0"
+0$
+0$        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));
+0$
+0$        }
+0$            }
+0$                *dec_pos = '.';
+0$            {
+0$            if (dec_pos != number_buffer.end())
+0$            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
+0$            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::find returns an iterator, see https://github.com/nlohmann/json/issues/3081
+0$        {
+0$        if (decimal_point != '\0' && decimal_point != '.')
+0$        // convert decimal point to '.'
+0$
+0$        }
+0$            len = (end - number_buffer.begin());
+0$            JSON_ASSERT((end - number_buffer.begin()) <= len);
+0$            std::fill(end, number_buffer.end(), '\0');
+0$            const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
+0$            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::remove returns an iterator, see https://github.com/nlohmann/json/issues/3081
+0$        {
+0$        if (thousands_sep != '\0')
+0$        // erase thousands separator
+0$
+0$        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());
+0$        // check if buffer was large enough
+0$        JSON_ASSERT(len > 0);
+0$        // negative value indicates an error
+0$
+0$        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);
+0$        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$        // the actual conversion
+0$
+0$        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;
+0$        // get number of digits for a float -> text -> float round-trip
+0$    {
+0$    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
+0$
+0$    }
+0$        o->write_characters(begin, static_cast<size_t>(end - begin));
+0$
+0$        auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);
+0$        auto* begin = number_buffer.data();
+0$    {
+0$    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
+0$
+0$    }
+0$        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
+0$
+0$              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);
+0$            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
+0$        static constexpr bool is_ieee_single_or_double
+0$        // NB: The test below works if <long double> == <double>.
+0$        //
+0$        // guaranteed to round-trip, using strtof and strtod, resp.
+0$        // use the Grisu2 algorithm to produce short numbers which are
+0$        // If number_float_t is an IEEE-754 single or double precision number,
+0$
+0$        }
+0$            return;
+0$            o->write_characters("null", 4);
+0$        {
+0$        if (!std::isfinite(x))
+0$        // NaN / inf
+0$    {
+0$    void dump_float(number_float_t x)
+0$    */
+0$    @param[in] x  floating-point number to dump
+0$
+0$    with @a number_buffer.
+0$    Dump a given floating-point number to output stream @a o. Works internally
+0$
+0$    @brief dump a floating-point number
+0$    /*!
+0$
+0$    }
+0$        o->write_characters(number_buffer.data(), n_chars);
+0$
+0$        }
+0$            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
+0$        {
+0$        else
+0$        }
+0$            *(--buffer_ptr) = digits_to_99[digits_index][0];
+0$            *(--buffer_ptr) = digits_to_99[digits_index][1];
+0$            const auto digits_index = static_cast<unsigned>(abs_value);
+0$        {
+0$        if (abs_value >= 10)
+0$
+0$        }
+0$            *(--buffer_ptr) = digits_to_99[digits_index][0];
+0$            *(--buffer_ptr) = digits_to_99[digits_index][1];
+0$            abs_value /= 100;
+0$            const auto digits_index = static_cast<unsigned>((abs_value % 100));
+0$        {
+0$        while (abs_value >= 100)
+0$        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
+0$        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
+0$
+0$        buffer_ptr += n_chars;
+0$        // so we later avoid reversing the result
+0$        // jump to the end to generate the string from backward,
+0$
+0$        JSON_ASSERT(n_chars < number_buffer.size() - 1);
+0$        // spare 1 byte for '\0'
+0$
+0$        }
+0$            n_chars = count_digits(abs_value);
+0$            abs_value = static_cast<number_unsigned_t>(x);
+0$        {
+0$        else
+0$        }
+0$            n_chars = 1 + count_digits(abs_value);
+0$            // account one more byte for the minus sign
+0$
+0$            abs_value = remove_sign(static_cast<number_integer_t>(x));
+0$            *buffer_ptr = '-';
+0$        {
+0$        if (is_negative_number(x))
+0$
+0$        unsigned int n_chars{};
+0$
+0$        number_unsigned_t abs_value;
+0$
+0$        auto buffer_ptr = number_buffer.begin(); // NOLINT(llvm-qualified-auto,readability-qualified-auto,cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$        // use a pointer to fill the buffer
+0$
+0$        }
+0$            return;
+0$            o->write_character('0');
+0$        {
+0$        if (x == 0)
+0$        // special case for "0"
+0$
+0$        };
+0$            }
+0$                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
+0$                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
+0$                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
+0$                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
+0$                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
+0$                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
+0$                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
+0$                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
+0$                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
+0$                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
+0$            {
+0$        {
+0$        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
+0$    {
+0$    void dump_integer(NumberType x)
+0$                   int > = 0 >
+0$                   std::is_same<NumberType, binary_char_t>::value,
+0$                   std::is_same<NumberType, number_integer_t>::value ||
+0$                   std::is_same<NumberType, number_unsigned_t>::value ||
+0$                   std::is_integral<NumberType>::value ||
+0$    template < typename NumberType, detail::enable_if_t <
+0$    */
+0$    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
+0$    @param[in] x  integer number (signed or unsigned) to dump
+0$
+0$    @a number_buffer.
+0$    Dump a given integer to output stream @a o. Works internally with
+0$
+0$    @brief dump an integer
+0$    /*!
+0$
+0$    }
+0$        return false;
+0$    {
+0$    bool is_negative_number(NumberType /*unused*/)
+0$    template < typename NumberType, enable_if_t <std::is_unsigned<NumberType>::value, int > = 0 >
+0$
+0$    }
+0$        return x < 0;
+0$    {
+0$    bool is_negative_number(NumberType x)
+0$    template <typename NumberType, enable_if_t<std::is_signed<NumberType>::value, int> = 0>
+0$    // templates to avoid warnings about useless casts
+0$
+0$    }
+0$        return result;
+0$        result[1] = nibble_to_hex[byte % 16];
+0$        result[0] = nibble_to_hex[byte / 16];
+0$        constexpr const char* nibble_to_hex = "0123456789ABCDEF";
+0$        std::string result = "FF";
+0$    {
+0$    static std::string hex_bytes(std::uint8_t byte)
+0$     */
+0$     * @return representation ("00".."FF")
+0$     * @param[in] byte byte to represent
+0$     * @brief convert a byte to a uppercase hex representation
+0$    /*!
+0$
+0$    }
+0$        }
+0$            n_digits += 4;
+0$            x = x / 10000u;
+0$            }
+0$                return n_digits + 3;
+0$            {
+0$            if (x < 10000)
+0$            }
+0$                return n_digits + 2;
+0$            {
+0$            if (x < 1000)
+0$            }
+0$                return n_digits + 1;
+0$            {
+0$            if (x < 100)
+0$            }
+0$                return n_digits;
+0$            {
+0$            if (x < 10)
+0$        {
+0$        for (;;)
+0$        unsigned int n_digits = 1;
+0$    {
+0$    inline unsigned int count_digits(number_unsigned_t x) noexcept
+0$    */
+0$    @return    number of decimal digits
+0$    @param[in] x  unsigned integer number to count its digits
+0$
+0$    Count the number of decimal (base 10) digits for an input unsigned integer.
+0$
+0$    @brief count digits
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        }
+0$            }
+0$                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$                default:            // LCOV_EXCL_LINE
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        o->write_characters("\xEF\xBF\xBD", 3);
+0$                    {
+0$                    else
+0$                    }
+0$                        o->write_characters("\\ufffd", 6);
+0$                    {
+0$                    if (ensure_ascii)
+0$                    // add a replacement character
+0$                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
+0$                    // write all accepted bytes
+0$                {
+0$                case error_handler_t::replace:
+0$
+0$                }
+0$                    break;
+0$                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
+0$                    // write all accepted bytes
+0$                {
+0$                case error_handler_t::ignore:
+0$
+0$                }
+0$                    JSON_THROW(type_error::create(316, concat("incomplete UTF-8 string; last byte: 0x", hex_bytes(static_cast<std::uint8_t>(s.back() | 0))), nullptr));
+0$                {
+0$                case error_handler_t::strict:
+0$            {
+0$            switch (error_handler)
+0$            // we finish reading, but do not accept: string was incomplete
+0$        {
+0$        else
+0$        }
+0$            }
+0$                o->write_characters(string_buffer.data(), bytes);
+0$            {
+0$            if (bytes > 0)
+0$            // write buffer
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
+0$        // we finished processing the string
+0$
+0$        }
+0$            }
+0$                }
+0$                    break;
+0$                    ++undumped_chars;
+0$                    }
+0$                        string_buffer[bytes++] = s[i];
+0$                        // code point will not be escaped - copy byte to buffer
+0$                    {
+0$                    if (!ensure_ascii)
+0$                {
+0$                default:  // decode found yet incomplete multi-byte code point
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$                        default:            // LCOV_EXCL_LINE
+0$
+0$                        }
+0$                            break;
+0$                            state = UTF8_ACCEPT;
+0$                            // continue processing the string
+0$
+0$                            undumped_chars = 0;
+0$
+0$                            }
+0$                                bytes_after_last_accept = bytes;
+0$
+0$                                }
+0$                                    bytes = 0;
+0$                                    o->write_characters(string_buffer.data(), bytes);
+0$                                {
+0$                                if (string_buffer.size() - bytes < 13)
+0$                                // written ("\uxxxx\uxxxx\0") for one code point
+0$                                // left, as this is the maximal number of bytes to be
+0$                                // write buffer and reset index; there must be 13 bytes
+0$
+0$                                }
+0$                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
+0$                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
+0$                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
+0$                                {
+0$                                else
+0$                                }
+0$                                    string_buffer[bytes++] = 'd';
+0$                                    string_buffer[bytes++] = 'f';
+0$                                    string_buffer[bytes++] = 'f';
+0$                                    string_buffer[bytes++] = 'f';
+0$                                    string_buffer[bytes++] = 'u';
+0$                                    string_buffer[bytes++] = '\\';
+0$                                {
+0$                                if (ensure_ascii)
+0$                                // add a replacement character
+0$                            {
+0$                            if (error_handler == error_handler_t::replace)
+0$
+0$                            bytes = bytes_after_last_accept;
+0$                            // thus removing/ignoring the invalid characters
+0$                            // reset length buffer to the last accepted index;
+0$
+0$                            }
+0$                                --i;
+0$                            {
+0$                            if (undumped_chars > 0)
+0$                            // previous sequence
+0$                            // may be OK for itself, but just not OK for the
+0$                            // would like to read it again, because the byte
+0$                            // in case we saw this character the first time, we
+0$                        {
+0$                        case error_handler_t::replace:
+0$                        case error_handler_t::ignore:
+0$
+0$                        }
+0$                            JSON_THROW(type_error::create(316, concat("invalid UTF-8 byte at index ", std::to_string(i), ": 0x", hex_bytes(byte | 0)), nullptr));
+0$                        {
+0$                        case error_handler_t::strict:
+0$                    {
+0$                    switch (error_handler)
+0$                {
+0$                case UTF8_REJECT:  // decode found invalid UTF-8 byte
+0$
+0$                }
+0$                    break;
+0$                    undumped_chars = 0;
+0$                    bytes_after_last_accept = bytes;
+0$                    // remember the byte position of this accept
+0$
+0$                    }
+0$                        bytes = 0;
+0$                        o->write_characters(string_buffer.data(), bytes);
+0$                    {
+0$                    if (string_buffer.size() - bytes < 13)
+0$                    // written ("\uxxxx\uxxxx\0") for one code point
+0$                    // left, as this is the maximal number of bytes to be
+0$                    // write buffer and reset index; there must be 13 bytes
+0$
+0$                    }
+0$                        }
+0$                            break;
+0$                            }
+0$                                string_buffer[bytes++] = s[i];
+0$                                // been copied have in default case above)
+0$                                // copy byte to buffer (all previous bytes
+0$                            {
+0$                            else
+0$                            }
+0$                                }
+0$                                    bytes += 12;
+0$                                                                      static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu))));
+0$                                                                      static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
+0$                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
+0$                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$                                {
+0$                                else
+0$                                }
+0$                                    bytes += 6;
+0$                                                                      static_cast<std::uint16_t>(codepoint)));
+0$                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
+0$                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$                                {
+0$                                if (codepoint <= 0xFFFF)
+0$                            {
+0$                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
+0$                            // ensure_ascii parameter is used, non-ASCII characters
+0$                            // escape control characters (0x00..0x1F) or, if
+0$                        {
+0$                        default:
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = '\\';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x5C: // reverse solidus
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = '\"';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x22: // quotation mark
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = 'r';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x0D: // carriage return
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = 'f';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x0C: // formfeed
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = 'n';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x0A: // newline
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = 't';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x09: // horizontal tab
+0$
+0$                        }
+0$                            break;
+0$                            string_buffer[bytes++] = 'b';
+0$                            string_buffer[bytes++] = '\\';
+0$                        {
+0$                        case 0x08: // backspace
+0$                    {
+0$                    switch (codepoint)
+0$                {
+0$                case UTF8_ACCEPT:  // decode found a new code point
+0$            {
+0$            switch (decode(state, codepoint, byte))
+0$
+0$            const auto byte = static_cast<std::uint8_t>(s[i]);
+0$        {
+0$        for (std::size_t i = 0; i < s.size(); ++i)
+0$
+0$        std::size_t undumped_chars = 0;
+0$        std::size_t bytes_after_last_accept = 0;
+0$        // number of bytes written at the point of the last valid byte
+0$
+0$        std::size_t bytes = 0;  // number of bytes written to string_buffer
+0$        std::uint8_t state = UTF8_ACCEPT;
+0$        std::uint32_t codepoint{};
+0$    {
+0$    void dump_escaped(const string_t& s, const bool ensure_ascii)
+0$    */
+0$    @complexity Linear in the length of string @a s.
+0$
+0$                             \uXXXX sequences
+0$    @param[in] ensure_ascii  whether to escape non-ASCII characters with
+0$    @param[in] s  the string to escape
+0$
+0$    representation. The escaped string is written to output stream @a o.
+0$    characters by a sequence of "\u" followed by a four-digit hex
+0$    escape character (backslash) and another character and other control
+0$    Escape a string by replacing certain special characters by a sequence of an
+0$
+0$    @brief dump escaped string
+0$    /*!
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    }
+0$        }
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$            default:            // LCOV_EXCL_LINE
+0$
+0$            }
+0$                return;
+0$                o->write_characters("null", 4);
+0$            {
+0$            case value_t::null:
+0$
+0$            }
+0$                return;
+0$                o->write_characters("<discarded>", 11);
+0$            {
+0$            case value_t::discarded:
+0$
+0$            }
+0$                return;
+0$                dump_float(val.m_data.m_value.number_float);
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                return;
+0$                dump_integer(val.m_data.m_value.number_unsigned);
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                return;
+0$                dump_integer(val.m_data.m_value.number_integer);
+0$            {
+0$            case value_t::number_integer:
+0$
+0$            }
+0$                return;
+0$                }
+0$                    o->write_characters("false", 5);
+0$                {
+0$                else
+0$                }
+0$                    o->write_characters("true", 4);
+0$                {
+0$                if (val.m_data.m_value.boolean)
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                return;
+0$                }
+0$                    }
+0$                        o->write_characters("null}", 5);
+0$                    {
+0$                    else
+0$                    }
+0$                        o->write_character('}');
+0$                        dump_integer(val.m_data.m_value.binary->subtype());
+0$                    {
+0$                    if (val.m_data.m_value.binary->has_subtype())
+0$                    o->write_characters("],\"subtype\":", 12);
+0$
+0$                    }
+0$                        dump_integer(val.m_data.m_value.binary->back());
+0$                        }
+0$                            o->write_character(',');
+0$                            dump_integer(*i);
+0$                        {
+0$                                i != val.m_data.m_value.binary->cend() - 1; ++i)
+0$                        for (auto i = val.m_data.m_value.binary->cbegin();
+0$                    {
+0$                    if (!val.m_data.m_value.binary->empty())
+0$
+0$                    o->write_characters("{\"bytes\":[", 10);
+0$                {
+0$                else
+0$                }
+0$                    o->write_character('}');
+0$                    o->write_characters(indent_string.c_str(), current_indent);
+0$                    o->write_character('\n');
+0$                    }
+0$                        o->write_characters("null", 4);
+0$                    {
+0$                    else
+0$                    }
+0$                        dump_integer(val.m_data.m_value.binary->subtype());
+0$                    {
+0$                    if (val.m_data.m_value.binary->has_subtype())
+0$                    o->write_characters("\"subtype\": ", 11);
+0$
+0$                    o->write_characters(indent_string.c_str(), new_indent);
+0$                    o->write_characters("],\n", 3);
+0$
+0$                    }
+0$                        dump_integer(val.m_data.m_value.binary->back());
+0$                        }
+0$                            o->write_characters(", ", 2);
+0$                            dump_integer(*i);
+0$                        {
+0$                                i != val.m_data.m_value.binary->cend() - 1; ++i)
+0$                        for (auto i = val.m_data.m_value.binary->cbegin();
+0$                    {
+0$                    if (!val.m_data.m_value.binary->empty())
+0$
+0$                    o->write_characters("\"bytes\": [", 10);
+0$
+0$                    o->write_characters(indent_string.c_str(), new_indent);
+0$
+0$                    }
+0$                        indent_string.resize(indent_string.size() * 2, ' ');
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
+0$                    const auto new_indent = current_indent + indent_step;
+0$                    // variable to hold indentation for recursive calls
+0$
+0$                    o->write_characters("{\n", 2);
+0$                {
+0$                if (pretty_print)
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                return;
+0$                o->write_character('\"');
+0$                dump_escaped(*val.m_data.m_value.string, ensure_ascii);
+0$                o->write_character('\"');
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                return;
+0$
+0$                }
+0$                    o->write_character(']');
+0$
+0$                    dump(val.m_data.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);
+0$                    JSON_ASSERT(!val.m_data.m_value.array->empty());
+0$                    // last element
+0$
+0$                    }
+0$                        o->write_character(',');
+0$                        dump(*i, false, ensure_ascii, indent_step, current_indent);
+0$                    {
+0$                            i != val.m_data.m_value.array->cend() - 1; ++i)
+0$                    for (auto i = val.m_data.m_value.array->cbegin();
+0$                    // first n-1 elements
+0$
+0$                    o->write_character('[');
+0$                {
+0$                else
+0$                }
+0$                    o->write_character(']');
+0$                    o->write_characters(indent_string.c_str(), current_indent);
+0$                    o->write_character('\n');
+0$
+0$                    dump(val.m_data.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);
+0$                    o->write_characters(indent_string.c_str(), new_indent);
+0$                    JSON_ASSERT(!val.m_data.m_value.array->empty());
+0$                    // last element
+0$
+0$                    }
+0$                        o->write_characters(",\n", 2);
+0$                        dump(*i, true, ensure_ascii, indent_step, new_indent);
+0$                        o->write_characters(indent_string.c_str(), new_indent);
+0$                    {
+0$                            i != val.m_data.m_value.array->cend() - 1; ++i)
+0$                    for (auto i = val.m_data.m_value.array->cbegin();
+0$                    // first n-1 elements
+0$
+0$                    }
+0$                        indent_string.resize(indent_string.size() * 2, ' ');
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
+0$                    const auto new_indent = current_indent + indent_step;
+0$                    // variable to hold indentation for recursive calls
+0$
+0$                    o->write_characters("[\n", 2);
+0$                {
+0$                if (pretty_print)
+0$
+0$                }
+0$                    return;
+0$                    o->write_characters("[]", 2);
+0$                {
+0$                if (val.m_data.m_value.array->empty())
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                return;
+0$
+0$                }
+0$                    o->write_character('}');
+0$
+0$                    dump(i->second, false, ensure_ascii, indent_step, current_indent);
+0$                    o->write_characters("\":", 2);
+0$                    dump_escaped(i->first, ensure_ascii);
+0$                    o->write_character('\"');
+0$                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
+0$                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
+0$                    // last element
+0$
+0$                    }
+0$                        o->write_character(',');
+0$                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
+0$                        o->write_characters("\":", 2);
+0$                        dump_escaped(i->first, ensure_ascii);
+0$                        o->write_character('\"');
+0$                    {
+0$                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
+0$                    auto i = val.m_data.m_value.object->cbegin();
+0$                    // first n-1 elements
+0$
+0$                    o->write_character('{');
+0$                {
+0$                else
+0$                }
+0$                    o->write_character('}');
+0$                    o->write_characters(indent_string.c_str(), current_indent);
+0$                    o->write_character('\n');
+0$
+0$                    dump(i->second, true, ensure_ascii, indent_step, new_indent);
+0$                    o->write_characters("\": ", 3);
+0$                    dump_escaped(i->first, ensure_ascii);
+0$                    o->write_character('\"');
+0$                    o->write_characters(indent_string.c_str(), new_indent);
+0$                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
+0$                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
+0$                    // last element
+0$
+0$                    }
+0$                        o->write_characters(",\n", 2);
+0$                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
+0$                        o->write_characters("\": ", 3);
+0$                        dump_escaped(i->first, ensure_ascii);
+0$                        o->write_character('\"');
+0$                        o->write_characters(indent_string.c_str(), new_indent);
+0$                    {
+0$                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
+0$                    auto i = val.m_data.m_value.object->cbegin();
+0$                    // first n-1 elements
+0$
+0$                    }
+0$                        indent_string.resize(indent_string.size() * 2, ' ');
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
+0$                    const auto new_indent = current_indent + indent_step;
+0$                    // variable to hold indentation for recursive calls
+0$
+0$                    o->write_characters("{\n", 2);
+0$                {
+0$                if (pretty_print)
+0$
+0$                }
+0$                    return;
+0$                    o->write_characters("{}", 2);
+0$                {
+0$                if (val.m_data.m_value.object->empty())
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (val.m_data.m_type)
+0$    {
+0$              const unsigned int current_indent = 0)
+0$              const unsigned int indent_step,
+0$              const bool ensure_ascii,
+0$              const bool pretty_print,
+0$    void dump(const BasicJsonType& val,
+0$    */
+0$    @param[in] current_indent    the current indent level (only used internally)
+0$    @param[in] indent_step       the indent level
+0$    of ASCII characters only.
+0$    in the output are escaped with `\uXXXX` sequences, and the result consists
+0$    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
+0$    @param[in] pretty_print      whether the output shall be pretty-printed
+0$    @param[in] val               value to serialize
+0$
+0$      byte array
+0$    - binary values are serialized as objects containing the subtype and the
+0$    - floating-point numbers are converted to a string using `"%g"` format
+0$    - integer numbers are converted implicitly via `operator<<`
+0$    - strings and object keys are escaped using `escape_string()`
+0$
+0$    called recursively.
+0$    additional parameter. In case of arrays and objects, the function is
+0$    the serialization internally. The indentation level is propagated as
+0$    This function is called by the public member function dump and organizes
+0$
+0$    @brief internal implementation of the serialization function
+0$    /*!
+0$
+0$    ~serializer() = default;
+0$    serializer& operator=(serializer&&) = delete;
+0$    serializer(serializer&&) = delete;
+0$    serializer& operator=(const serializer&) = delete;
+0$    serializer(const serializer&) = delete;
+0$    // delete because of pointer members
+0$
+0$    {}
+0$        , error_handler(error_handler_)
+0$        , indent_string(512, indent_char)
+0$        , indent_char(ichar)
+0$        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
+0$        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
+0$        , loc(std::localeconv())
+0$        : o(std::move(s))
+0$               error_handler_t error_handler_ = error_handler_t::strict)
+0$    serializer(output_adapter_t<char> s, const char ichar,
+0$    */
+0$    @param[in] error_handler_  how to react on decoding errors
+0$    @param[in] ichar  indentation character to use
+0$    @param[in] s  output stream to serialize to
+0$    /*!
+0$  public:
+0$
+0$    static constexpr std::uint8_t UTF8_REJECT = 1;
+0$    static constexpr std::uint8_t UTF8_ACCEPT = 0;
+0$    using binary_char_t = typename BasicJsonType::binary_t::value_type;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0${
+0$class serializer
+0$template<typename BasicJsonType>
+0$
+0$};
+0$    ignore   ///< ignore invalid UTF-8 sequences
+0$    replace, ///< replace invalid UTF-8 sequences with U+FFFD
+0$    strict,  ///< throw a type_error exception in case of invalid UTF-8
+0${
+0$enum class error_handler_t
+0$/// how to treat decoding errors
+0$
+0$///////////////////
+0$// serialization //
+0$///////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/output/output_adapters.hpp>
+0$
+0$// #include <nlohmann/detail/output/binary_writer.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
+0$
+0$    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);
+0$    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
+0$    JSON_ASSERT(last - first >= kMaxExp + 2);
+0$
+0$    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;
+0$    // Use digits10 here to increase compatibility with version 2.
+0$    constexpr int kMinExp = -4;
+0$    // Format the buffer like printf("%.*g", prec, value)
+0$
+0$    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);
+0$
+0$    dtoa_impl::grisu2(first, len, decimal_exponent, value);
+0$    int decimal_exponent = 0;
+0$    int len = 0;
+0$    // len is the length of the buffer, i.e. the number of decimal digits.
+0$    // as an unsigned decimal integer.
+0$    // The decimal digits are stored in the buffer, which needs to be interpreted
+0$    // Compute v = buffer * 10^decimal_exponent.
+0$
+0$    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);
+0$
+0$#endif
+0$#pragma GCC diagnostic pop
+0$#ifdef __GNUC__
+0$    }
+0$        return first;
+0$        *first++ = '0';
+0$        *first++ = '.';
+0$        // Make it look like a floating-point number (#362, #378)
+0$        *first++ = '0';
+0$    {
+0$    if (value == 0) // +-0
+0$#endif
+0$#pragma GCC diagnostic ignored "-Wfloat-equal"
+0$#pragma GCC diagnostic push
+0$#ifdef __GNUC__
+0$
+0$    }
+0$        *first++ = '-';
+0$        value = -value;
+0$    {
+0$    if (std::signbit(value))
+0$    // Use signbit(value) instead of (value < 0) since signbit works for -0.
+0$
+0$    JSON_ASSERT(std::isfinite(value));
+0$    static_cast<void>(last); // maybe unused - fix warning
+0${
+0$char* to_chars(char* first, const char* last, FloatType value)
+0$JSON_HEDLEY_RETURNS_NON_NULL
+0$JSON_HEDLEY_NON_NULL(1, 2)
+0$template<typename FloatType>
+0$*/
+0$@note The result is NOT null-terminated.
+0$@note The buffer must be large enough.
+0$@note The input number must be finite, i.e. NaN's and Inf's are not supported.
+0$
+0$format. Returns an iterator pointing past-the-end of the decimal representation.
+0$The format of the resulting decimal representation is similar to printf's %g
+0$
+0$@brief generates a decimal representation of the floating-point number value in [first, last).
+0$/*!
+0$
+0$}  // namespace dtoa_impl
+0$
+0$}
+0$    return append_exponent(buf, n - 1);
+0$    *buf++ = 'e';
+0$
+0$    }
+0$        buf += 1 + static_cast<size_t>(k);
+0$        buf[1] = '.';
+0$        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
+0$
+0$        // len <= max_digits10 + 1 + 5
+0$        // d.igitsE+123
+0$    {
+0$    else
+0$    }
+0$        buf += 1;
+0$
+0$        // len <= 1 + 5
+0$        // dE+123
+0$    {
+0$    if (k == 1)
+0$
+0$    }
+0$        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
+0$        std::memset(buf + 2, '0', static_cast<size_t>(-n));
+0$        buf[1] = '.';
+0$        buf[0] = '0';
+0$        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
+0$
+0$        // len <= 2 + (-min_exp - 1) + max_digits10
+0$        // 0.[000]digits
+0$    {
+0$    if (min_exp < n && n <= 0)
+0$
+0$    }
+0$        return buf + (static_cast<size_t>(k) + 1U);
+0$        buf[n] = '.';
+0$        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
+0$
+0$        JSON_ASSERT(k > n);
+0$
+0$        // len <= max_digits10 + 1
+0$        // dig.its
+0$    {
+0$    if (0 < n && n <= max_exp)
+0$
+0$    }
+0$        return buf + (static_cast<size_t>(n) + 2);
+0$        buf[n + 1] = '0';
+0$        buf[n + 0] = '.';
+0$        // Make it look like a floating-point number (#362, #378)
+0$        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
+0$
+0$        // len <= max_exp + 2
+0$        // digits[000]
+0$    {
+0$    if (k <= n && n <= max_exp)
+0$
+0$    // n is the position of the decimal point relative to the start of the buffer.
+0$    // k is the length of the buffer (number of decimal digits)
+0$    // v = buf * 10^(n-k)
+0$
+0$    const int n = len + decimal_exponent;
+0$    const int k = len;
+0$
+0$    JSON_ASSERT(max_exp > 0);
+0$    JSON_ASSERT(min_exp < 0);
+0${
+0$                           int min_exp, int max_exp)
+0$inline char* format_buffer(char* buf, int len, int decimal_exponent,
+0$JSON_HEDLEY_RETURNS_NON_NULL
+0$JSON_HEDLEY_NON_NULL(1)
+0$*/
+0$@pre max_exp > 0
+0$@pre min_exp < 0
+0$
+0$notation. Otherwise it will be printed in exponential notation.
+0$If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
+0$
+0$@brief prettify v = buf * 10^decimal_exponent
+0$/*!
+0$
+0$}
+0$    return buf;
+0$
+0$    }
+0$        *buf++ = static_cast<char>('0' + k);
+0$        k %= 10;
+0$        *buf++ = static_cast<char>('0' + k / 10);
+0$        k %= 100;
+0$        *buf++ = static_cast<char>('0' + k / 100);
+0$    {
+0$    else
+0$    }
+0$        *buf++ = static_cast<char>('0' + k);
+0$        k %= 10;
+0$        *buf++ = static_cast<char>('0' + k / 10);
+0$    {
+0$    else if (k < 100)
+0$    }
+0$        *buf++ = static_cast<char>('0' + k);
+0$        *buf++ = '0';
+0$        // This is for compatibility with printf("%g").
+0$        // Always print at least two digits in the exponent.
+0$    {
+0$    if (k < 10)
+0$    auto k = static_cast<std::uint32_t>(e);
+0$
+0$    }
+0$        *buf++ = '+';
+0$    {
+0$    else
+0$    }
+0$        *buf++ = '-';
+0$        e = -e;
+0$    {
+0$    if (e < 0)
+0$
+0$    JSON_ASSERT(e <  1000);
+0$    JSON_ASSERT(e > -1000);
+0${
+0$inline char* append_exponent(char* buf, int e)
+0$JSON_HEDLEY_RETURNS_NON_NULL
+0$JSON_HEDLEY_NON_NULL(1)
+0$*/
+0$@pre -1000 < e < 1000
+0$@return a pointer to the element following the exponent.
+0$@brief appends a decimal representation of e to buf
+0$/*!
+0$
+0$}
+0$    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
+0$
+0$#endif
+0$    const boundaries w = compute_boundaries(value);
+0$#else
+0$    const boundaries w = compute_boundaries(static_cast<double>(value));
+0$#if 0 // NOLINT(readability-avoid-unconditional-preprocessor-if)
+0$    //     value is off by 1 ulp.
+0$    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
+0$    // NB: If the neighbors are computed for single-precision numbers, there is a single float
+0$    //
+0$    // 'std::strtof'.
+0$    // indicates that single precision floating-point numbers should be recovered using
+0$    // representation using the corresponding std::from_chars function recovers value exactly". That
+0$    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
+0$    // does.
+0$    // and since sprintf promotes floats to doubles, I think this is exactly what 'std::to_chars'
+0$    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
+0$    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
+0$    //
+0$    // decimal representations are not exactly "short".
+0$    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
+0$    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
+0$
+0$    JSON_ASSERT(value > 0);
+0$    JSON_ASSERT(std::isfinite(value));
+0$
+0$                  "internal error: not enough precision");
+0$    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
+0${
+0$void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
+0$JSON_HEDLEY_NON_NULL(1)
+0$template<typename FloatType>
+0$*/
+0$The buffer must be large enough, i.e. >= max_digits10.
+0$len is the length of the buffer (number of decimal digits)
+0$v = buf * 10^decimal_exponent
+0$/*!
+0$
+0$}
+0$    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
+0$
+0$    decimal_exponent = -cached.k; // = -(-k) = k
+0$
+0$    const diyfp M_plus (w_plus.f  - 1, w_plus.e );
+0$    const diyfp M_minus(w_minus.f + 1, w_minus.e);
+0$    // possible number in the interval (m-, m+).
+0$    // Note that this does not mean that Grisu2 always generates the shortest
+0$    // And digit_gen generates the shortest possible such number in [M-, M+].
+0$    //
+0$    // regardless of how the input rounding algorithm breaks ties.
+0$    // Now any number in [M-, M+] (bounds included) will round to w when input,
+0$    //
+0$    //          w-  M-                  w                   M+  w+
+0$    //  --------+---[---------------(---+---)---------------]---+--------
+0$    //
+0$    // To account for this inaccuracy, add resp. subtract 1 ulp.
+0$    //
+0$    //      w - v * 10^k < 1 ulp
+0$    //
+0$    // In fact:
+0$    // w+ are now off by a small amount.
+0$    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
+0$    //
+0$    //          = c*m-                  = c*v                   = c*m+
+0$    //          w-                      w                       w+
+0$    //  ----(---+---)---------------(---+---)---------------(---+---)----
+0$
+0$    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);
+0$    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
+0$    const diyfp w       = diyfp::mul(v,       c_minus_k);
+0$    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
+0$
+0$    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k
+0$
+0$    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);
+0$
+0$    // [alpha, gamma].
+0$    // First scale v (and m- and m+) such that the exponent is in the range
+0$    //
+0$    //                      m-          v                       m+
+0$    //  --------------------(-----------+-----------------------)--------    (B)
+0$    //
+0$    //          m-                      v                       m+
+0$    //  --------(-----------------------+-----------------------)--------    (A)
+0$
+0$    JSON_ASSERT(m_plus.e == v.e);
+0$    JSON_ASSERT(m_plus.e == m_minus.e);
+0${
+0$                   diyfp m_minus, diyfp v, diyfp m_plus)
+0$inline void grisu2(char* buf, int& len, int& decimal_exponent,
+0$JSON_HEDLEY_NON_NULL(1)
+0$*/
+0$The buffer must be large enough, i.e. >= max_digits10.
+0$len is the length of the buffer (number of decimal digits)
+0$v = buf * 10^decimal_exponent
+0$/*!
+0$
+0$}
+0$    //      N = 9  for p = 24 (IEEE single precision)
+0$    //      N = 17 for p = 53 (IEEE double precision)
+0$    //
+0$    // digits.
+0$    // This implies that the algorithm does not produce more than N decimal
+0$    // numbers (Matula, "In-and-Out conversions").
+0$    // decimal digits are sufficient to identify all binary floating-point
+0$    //
+0$    //      N = 1 + ceil(p * log_10(2))
+0$    //
+0$    // For an input number of precision p, at least
+0$    // number (Loitsch, Theorem 6.2) which rounds back to w.
+0$    // By construction this algorithm generates the shortest possible decimal
+0$
+0$    grisu2_round(buffer, length, dist, delta, p2, ten_m);
+0$    const std::uint64_t ten_m = one.f;
+0$    //
+0$    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
+0$    //
+0$    // same with ulp in order to keep the units in sync.
+0$    // Since delta and dist are now scaled by 10^m, we need to do the
+0$    // 1 ulp in the decimal representation is now 10^-m.
+0$
+0$    decimal_exponent -= m;
+0$
+0$    // V = buffer * 10^-m, with M- <= V <= M+.
+0$
+0$    }
+0$        }
+0$            break;
+0$        {
+0$        if (p2 <= delta)
+0$        dist  *= 10;
+0$        delta *= 10;
+0$        //                    p2 <= 10^m * delta
+0$        //              p2 * 2^e <= 10^m * delta * 2^e
+0$        //      10^-m * p2 * 2^e <= delta * 2^e
+0$        //
+0$        // Check if enough digits have been generated.
+0$
+0$        // Invariant restored.
+0$        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
+0$        //
+0$        m++;
+0$        p2 = r;
+0$        //
+0$        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
+0$        //
+0$        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
+0$        JSON_ASSERT(d <= 9);
+0$        //
+0$        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
+0$        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
+0$        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
+0$        //
+0$        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
+0$        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
+0$        p2 *= 10;
+0$        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
+0$        //
+0$        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
+0$        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
+0$        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
+0$        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
+0$        // Invariant:
+0$    {
+0$    for (;;)
+0$    int m = 0;
+0$
+0$    JSON_ASSERT(p2 > delta);
+0$
+0$    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e
+0$    //
+0$    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
+0$    //         = buffer + 10^-m * (d + r * 2^e)
+0$    //      M+ = buffer + p2 * 2^e
+0$    //
+0$    // i.e.
+0$    //
+0$    //      10^m * p2 * 2^e = d + r * 2^e
+0$    // or
+0$    //
+0$    //                = (                   d) * 2^-e + (                   r)
+0$    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
+0$    //
+0$    // using
+0$    //
+0$    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
+0$    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
+0$    //
+0$    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
+0$    //
+0$    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
+0$    //          = p2 / 2^-e
+0$    //      p2 * 2^e
+0$    //
+0$    // p2 actually represents the fraction
+0$    //
+0$    // No decimal point is generated: the exponent is adjusted instead.
+0$    // Note:
+0$    //
+0$    // Now generate the digits of the fractional part p2 * 2^e.
+0$    //
+0$    //         = buffer            + p2 * 2^e
+0$    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
+0$    //
+0$    // The digits of the integral part have been generated:
+0$    //
+0$    // 2)
+0$
+0$    }
+0$        // Invariants restored.
+0$        //      pow10 = 10^(n-1) <= p1 < 10^n
+0$        //
+0$        pow10 /= 10;
+0$
+0$        }
+0$            return;
+0$
+0$            grisu2_round(buffer, length, dist, delta, rest, ten_n);
+0$            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
+0$            //
+0$            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
+0$            //
+0$            // exponent of e.
+0$            // The rounding procedure works with diyfp's with an implicit
+0$            // pow10 = 10^n is now 1 ulp in the decimal representation V.
+0$            //
+0$            // decremented to bring V closer to w.
+0$            // We may now just stop. But instead look if the buffer could be
+0$
+0$            decimal_exponent += n;
+0$
+0$            // V = buffer * 10^n, with M- <= V <= M+.
+0$        {
+0$        if (rest <= delta)
+0$        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
+0$        // compare the significands.
+0$        // Since rest and delta share the same exponent e, it suffices to
+0$        // Note:
+0$        //
+0$        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
+0$        //
+0$        // Compute
+0$        // Now check if enough digits have been generated.
+0$
+0$        //
+0$        //      pow10 = 10^n
+0$        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
+0$        //
+0$        n--;
+0$        p1 = r;
+0$        //
+0$        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
+0$        //
+0$        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
+0$        JSON_ASSERT(d <= 9);
+0$        //
+0$        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
+0$        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
+0$        //
+0$        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
+0$        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
+0$        //
+0$        //      pow10 = 10^(n-1) <= p1 < 10^n
+0$        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
+0$        // Invariants:
+0$    {
+0$    while (n > 0)
+0$    int n = k;
+0$
+0$    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e
+0$    //
+0$    // but stop as soon as
+0$    //
+0$    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
+0$    //
+0$    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
+0$    //
+0$    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
+0$    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
+0$    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
+0$    //      M+ = p1                                             + p2 * 2^e
+0$    //
+0$    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
+0$    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
+0$    //
+0$    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
+0$
+0$    const int k = find_largest_pow10(p1, pow10);
+0$    std::uint32_t pow10{};
+0$
+0$    JSON_ASSERT(p1 > 0);
+0$
+0$    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]
+0$    //
+0$    // 1)
+0$
+0$    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e
+0$    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
+0$
+0$    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);
+0$
+0$    //         = p1 + p2 * 2^e
+0$    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
+0$    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
+0$    //      M+ = f * 2^e
+0$    //
+0$    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
+0$
+0$    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)
+0$    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
+0$
+0$    JSON_ASSERT(M_plus.e <= kGamma);
+0$    JSON_ASSERT(M_plus.e >= kAlpha);
+0$
+0$    // V is in [M-,M+].
+0$    // Grisu2 generates the digits of M+ from left to right and stops as soon as
+0$    //
+0$    //               M-                 w                   M+
+0$    // --------------[------------------+-------------------]--------------
+0$    //                                  <---- dist --------->
+0$    //               <--------------------------- delta ---->
+0$    //
+0$    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
+0$    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
+0$    // Generates the digits (and the exponent) of a decimal floating-point
+0$
+0$    static_assert(kGamma <= -32, "internal error");
+0$    static_assert(kAlpha >= -60, "internal error");
+0${
+0$                             diyfp M_minus, diyfp w, diyfp M_plus)
+0$inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
+0$*/
+0$M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
+0$Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
+0$/*!
+0$
+0$}
+0$    }
+0$        rest += ten_k;
+0$        buf[len - 1]--;
+0$        JSON_ASSERT(buf[len - 1] != '0');
+0$    {
+0$            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
+0$            && delta - rest >= ten_k
+0$    while (rest < dist
+0$
+0$    // integer arithmetic.
+0$    // The tests are written in this order to avoid overflow in unsigned
+0$
+0$    // Decrement buf by ten_k while this takes buf closer to w.
+0$    // stored in buf.
+0$    // ten_k represents a unit-in-the-last-place in the decimal representation
+0$    //
+0$    //                                       = buf * 10^k
+0$    //                                  w    V
+0$    // --------------[------------------+----+--------------]--------------
+0$    //                                       <---- rest ---->
+0$    //                                <------>
+0$    //                                  ten_k
+0$    //
+0$    //               M-                 w                   M+
+0$    // --------------[------------------+-------------------]--------------
+0$    //                                  <---- dist --------->
+0$    //               <--------------------------- delta ---->
+0$
+0$    JSON_ASSERT(ten_k > 0);
+0$    JSON_ASSERT(rest <= delta);
+0$    JSON_ASSERT(dist <= delta);
+0$    JSON_ASSERT(len >= 1);
+0${
+0$                         std::uint64_t rest, std::uint64_t ten_k)
+0$inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
+0$
+0$}
+0$    return 1;
+0$    pow10 = 1;
+0$
+0$    }
+0$        return  2;
+0$        pow10 = 10;
+0$    {
+0$    if (n >= 10)
+0$    }
+0$        return  3;
+0$        pow10 = 100;
+0$    {
+0$    if (n >= 100)
+0$    }
+0$        return  4;
+0$        pow10 = 1000;
+0$    {
+0$    if (n >= 1000)
+0$    }
+0$        return  5;
+0$        pow10 = 10000;
+0$    {
+0$    if (n >= 10000)
+0$    }
+0$        return  6;
+0$        pow10 = 100000;
+0$    {
+0$    if (n >= 100000)
+0$    }
+0$        return  7;
+0$        pow10 = 1000000;
+0$    {
+0$    if (n >= 1000000)
+0$    }
+0$        return  8;
+0$        pow10 = 10000000;
+0$    {
+0$    if (n >= 10000000)
+0$    }
+0$        return  9;
+0$        pow10 = 100000000;
+0$    {
+0$    if (n >= 100000000)
+0$    // LCOV_EXCL_STOP
+0$    }
+0$        return 10;
+0$        pow10 = 1000000000;
+0$    {
+0$    if (n >= 1000000000)
+0$    // LCOV_EXCL_START
+0${
+0$inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
+0$*/
+0$For n == 0, returns 1 and sets pow10 := 1.
+0$For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
+0$/*!
+0$
+0$}
+0$    return cached;
+0$
+0$    JSON_ASSERT(kGamma >= cached.e + e + 64);
+0$    JSON_ASSERT(kAlpha <= cached.e + e + 64);
+0$    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
+0$
+0$    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());
+0$    JSON_ASSERT(index >= 0);
+0$    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
+0$
+0$    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);
+0$    const int f = kAlpha - e - 1;
+0$    JSON_ASSERT(e <=  1500);
+0$    JSON_ASSERT(e >= -1500);
+0$    // NB: log_10(2) ~= 78913 / 2^18
+0$    // for |e| <= 1500, but doesn't require floating-point operations.
+0$    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
+0$    // This computation gives exactly the same results for k as
+0$
+0$    };
+0$        }
+0$            { 0x9E19DB92B4E31BA9,  1013,  324 },
+0$            { 0xD433179D9C8CB841,   986,  316 },
+0$            { 0x8E679C2F5E44FF8F,   960,  308 },
+0$            { 0xBF21E44003ACDD2D,   933,  300 },
+0$            { 0x80444B5E7AA7CF85,   907,  292 },
+0$            { 0xAC2820D9623BF429,   880,  284 },
+0$            { 0xE7109BFBA19C0C9D,   853,  276 },
+0$            { 0x9B10A4E5E9913129,   827,  268 },
+0$            { 0xD01FEF10A657842C,   800,  260 },
+0$            { 0x8BAB8EEFB6409C1A,   774,  252 },
+0$            { 0xBB764C4CA7A44410,   747,  244 },
+0$            { 0xFB9B7CD9A4A7443C,   720,  236 },
+0$            { 0xA8D9D1535CE3B396,   694,  228 },
+0$            { 0xE2A0B5DC971F303A,   667,  220 },
+0$            { 0x98165AF37B2153DF,   641,  212 },
+0$            { 0xCC20CE9BD35C78A5,   614,  204 },
+0$            { 0x88FCF317F22241E2,   588,  196 },
+0$            { 0xB7DCBF5354E9BECE,   561,  188 },
+0$            { 0xF6C69A72A3989F5C,   534,  180 },
+0$            { 0xA59BC234DB398C25,   508,  172 },
+0$            { 0xDE469FBD99A05FE3,   481,  164 },
+0$            { 0x952AB45CFA97A0B3,   455,  156 },
+0$            { 0xC83553C5C8965D3D,   428,  148 },
+0$            { 0x865B86925B9BC5C2,   402,  140 },
+0$            { 0xB454E4A179DD1877,   375,  132 },
+0$            { 0xF209787BB47D6B85,   348,  124 },
+0$            { 0xA26DA3999AEF774A,   322,  116 },
+0$            { 0xDA01EE641A708DEA,   295,  108 },
+0$            { 0x924D692CA61BE758,   269,  100 },
+0$            { 0xC45D1DF942711D9A,   242,   92 },
+0$            { 0x83C7088E1AAB65DB,   216,   84 },
+0$            { 0xB0DE65388CC8ADA8,   189,   76 },
+0$            { 0xED63A231D4C4FB27,   162,   68 },
+0$            { 0x9F4F2726179A2245,   136,   60 },
+0$            { 0xD5D238A4ABE98068,   109,   52 },
+0$            { 0x8F7E32CE7BEA5C70,    83,   44 },
+0$            { 0xC097CE7BC90715B3,    56,   36 },
+0$            { 0x813F3978F8940984,    30,   28 },
+0$            { 0xAD78EBC5AC620000,     3,   20 },
+0$            { 0xE8D4A51000000000,   -24,   12 },
+0$            { 0x9C40000000000000,   -50,    4 },
+0$            { 0xD1B71758E219652C,   -77,   -4 },
+0$            { 0x8CBCCC096F5088CC,  -103,  -12 },
+0$            { 0xBCE5086492111AEB,  -130,  -20 },
+0$            { 0xFD87B5F28300CA0E,  -157,  -28 },
+0$            { 0xAA242499697392D3,  -183,  -36 },
+0$            { 0xE45C10C42A2B3B06,  -210,  -44 },
+0$            { 0x993FE2C6D07B7FAC,  -236,  -52 },
+0$            { 0xCDB02555653131B6,  -263,  -60 },
+0$            { 0x8A08F0F8BF0F156B,  -289,  -68 },
+0$            { 0xB94470938FA89BCF,  -316,  -76 },
+0$            { 0xF8A95FCF88747D94,  -343,  -84 },
+0$            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
+0$            { 0xDFF9772470297EBD,  -396, -100 },
+0$            { 0x964E858C91BA2655,  -422, -108 },
+0$            { 0xC9BCFF6034C13053,  -449, -116 },
+0$            { 0x87625F056C7C4A8B,  -475, -124 },
+0$            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
+0$            { 0xF3E2F893DEC3F126,  -529, -140 },
+0$            { 0xA3AB66580D5FDAF6,  -555, -148 },
+0$            { 0xDBAC6C247D62A584,  -582, -156 },
+0$            { 0x936B9FCEBB25C996,  -608, -164 },
+0$            { 0xC5DD44271AD3CDBA,  -635, -172 },
+0$            { 0x84C8D4DFD2C63F3B,  -661, -180 },
+0$            { 0xB23867FB2A35B28E,  -688, -188 },
+0$            { 0xEF340A98172AACE5,  -715, -196 },
+0$            { 0xA086CFCD97BF97F4,  -741, -204 },
+0$            { 0xD77485CB25823AC7,  -768, -212 },
+0$            { 0x9096EA6F3848984F,  -794, -220 },
+0$            { 0xC21094364DFB5637,  -821, -228 },
+0$            { 0x823C12795DB6CE57,  -847, -236 },
+0$            { 0xAECC49914078536D,  -874, -244 },
+0$            { 0xEA9C227723EE8BCB,  -901, -252 },
+0$            { 0x9D71AC8FADA6C9B5,  -927, -260 },
+0$            { 0xD3515C2831559A83,  -954, -268 },
+0$            { 0x8DD01FAD907FFC3C,  -980, -276 },
+0$            { 0xBE5691EF416BD60C, -1007, -284 },
+0$            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
+0$            { 0xAB70FE17C79AC6CA, -1060, -300 },
+0$        {
+0$    {
+0$    static constexpr std::array<cached_power, 79> kCachedPowers =
+0$
+0$    constexpr int kCachedPowersDecStep = 8;
+0$    constexpr int kCachedPowersMinDecExp = -300;
+0$
+0$    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.
+0$    // NB:
+0$
+0$    // (A smaller distance gamma-alpha would require a larger table.)
+0$    //
+0$    //      floor( (gamma - alpha) * log_10(2) ) = 8.
+0$    //
+0$    // table entries must be less than or equal to
+0$    // This implies that the difference of the decimal exponents of adjacent
+0$    // such that the exponent of the product lies in [alpha,gamma].
+0$    // k in this range. For each such k it suffices to find a cached power
+0$    // range [-307,324]. One does not need to store a cached power for each
+0$    // This binary exponent range [-1137,960] results in a decimal exponent
+0$    //
+0$    //         = 960
+0$    //           -11        (normalize the diyfp)
+0$    //           -52        (p - 1)
+0$    //      e <= +1023      (max IEEE exponent)
+0$    //
+0$    // and
+0$    //
+0$    //         = -1137
+0$    //           -11        (normalize the diyfp)
+0$    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
+0$    //           -52        (p - 1)
+0$    //      e >= -1022      (min IEEE exponent)
+0$    //
+0$    // normalized diyfp's w = f * 2^e, with q = 64,
+0$    // For IEEE double precision floating-point numbers converted into
+0$    //
+0$    //  this simple function is sufficient."
+0$    //  and the computation itself is approximated [...]. In practice, however,
+0$    // "In theory the result of the procedure could be wrong since c is rounded,
+0$    // From the paper:
+0$    //
+0$    //        = ceil( (alpha - e - 1) * log_10(2) )
+0$    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
+0$    //
+0$    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
+0$    //
+0$    //      ==> 2^(alpha - e - 1) <= c
+0$    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
+0$    //
+0$    // and since the c's are normalized, 2^(q-1) <= f_c,
+0$    //
+0$    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
+0$    //      alpha <= e_c + e + q <= gamma                                    (1)
+0$    //
+0$    // Now
+0${
+0$inline cached_power get_cached_power_for_binary_exponent(int e)
+0$*/
+0$     alpha <= e_c + e + q <= gamma.
+0$
+0$satisfies (Definition 3.2 from [1])
+0$power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
+0$For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
+0$/*!
+0$
+0$};
+0$    int k;
+0$    int e;
+0$    std::uint64_t f;
+0${
+0$struct cached_power // c = f * 2^e ~= 10^k
+0$
+0$constexpr int kGamma = -32;
+0$constexpr int kAlpha = -60;
+0$
+0$//      -e <= 60   or   e >= -60 := alpha
+0$//
+0$// Since p2 = f mod 2^-e < 2^-e,
+0$//
+0$//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
+0$//
+0$// The multiplication by 10 must not overflow. It is sufficient to choose
+0$//
+0$//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
+0$//      (10 * p2) div 2^-e = d[-1]
+0$//
+0$// d[-i] are extracted in order:
+0$// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
+0$//
+0$//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
+0$//
+0$// In order to convert the fractional part
+0$//
+0$//      -e >= 32   or   e <= -32 := gamma
+0$//
+0$// achieved by choosing
+0$// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
+0$// modulos by (a power of) 10. These operations are faster for 32-bit than for
+0$// The conversion of p1 into decimal form requires a series of divisions and
+0$//
+0$//              = p1 + p2 * 2^e
+0$//              = (f div 2^-e) + (f mod 2^-e) * 2^e
+0$//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
+0$//
+0$// processed independently: An integral part p1, and a fractional part p2:
+0$// The idea is to cut the number c * w = f * 2^e into two parts, which can be
+0$//
+0$// in practice:
+0$// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
+0$// The choice of (alpha,gamma) determines the size of the table and the form of
+0$//
+0$//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
+0$//
+0$// or
+0$//
+0$//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
+0$//
+0$// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
+0$//
+0$//                          <= f_c * f_w * 2^gamma
+0$//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
+0$//
+0$// or
+0$//
+0$//      alpha <= e = e_c + e_w + q <= gamma
+0$//
+0$// within a certain range [alpha, gamma] (Definition 3.2 from [1])
+0$// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
+0$// Given normalized diyfp w, Grisu needs to find a (normalized) cached
+0$
+0$}
+0$    return {diyfp::normalize(v), w_minus, w_plus};
+0$
+0$    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);
+0$    // Determine w- = m- such that e_(w-) = e_(w+).
+0$
+0$    const diyfp w_plus = diyfp::normalize(m_plus);
+0$    // Determine the normalized w+ = m+.
+0$
+0$                          : diyfp(2 * v.f - 1, v.e - 1); // (A)
+0$                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
+0$    const diyfp m_minus = lower_boundary_is_closer
+0$    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
+0$    const bool lower_boundary_is_closer = F == 0 && E > 1;
+0$
+0$    //                       v-     m-     v             m+            v+
+0$    //      -----------------+------+------+-------------+-------------+---  (B)
+0$    //
+0$    //         v-            m-            v             m+            v+
+0$    //      ---+-------------+-------------+-------------+-------------+---  (A)
+0$    //
+0$    // algorithm breaks ties.
+0$    // between m- and m+ round to v, regardless of how the input rounding
+0$    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
+0$    //
+0$    //      v+ = v + 2^e
+0$    //
+0$    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
+0$    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
+0$    //
+0$    // respectively.
+0$    // Determine v- and v+, the floating-point predecessor and successor if v,
+0$    //
+0$    // v = f * 2^e.
+0$    // Compute the boundaries m- and m+ of the floating-point value
+0$
+0$                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);
+0$                    ? diyfp(F, kMinExp)
+0$    const diyfp v = is_denormal
+0$    const bool is_denormal = E == 0;
+0$
+0$    const std::uint64_t F = bits & (kHiddenBit - 1);
+0$    const std::uint64_t E = bits >> (kPrecision - 1);
+0$    const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
+0$
+0$    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;
+0$
+0$    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)
+0$    constexpr int      kMinExp    = 1 - kBias;
+0$    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
+0$    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
+0$
+0$                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");
+0$    static_assert(std::numeric_limits<FloatType>::is_iec559,
+0$
+0$    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))
+0$    // If v is normalized:
+0$    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
+0$    // If v is denormal:
+0$    //
+0$    // Convert the IEEE representation into a diyfp.
+0$
+0$    JSON_ASSERT(value > 0);
+0$    JSON_ASSERT(std::isfinite(value));
+0${
+0$boundaries compute_boundaries(FloatType value)
+0$template<typename FloatType>
+0$*/
+0$@pre value must be finite and positive
+0$
+0$boundaries.
+0$Compute the (normalized) diyfp representing the input number 'value' and its
+0$/*!
+0$
+0$};
+0$    diyfp plus;
+0$    diyfp minus;
+0$    diyfp w;
+0${
+0$struct boundaries
+0$
+0$};
+0$    }
+0$        return {x.f << delta, target_exponent};
+0$
+0$        JSON_ASSERT(((x.f << delta) >> delta) == x.f);
+0$        JSON_ASSERT(delta >= 0);
+0$
+0$        const int delta = x.e - target_exponent;
+0$    {
+0$    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
+0$    */
+0$    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
+0$    @brief normalize x such that the result has the exponent E
+0$    /*!
+0$
+0$    }
+0$        return x;
+0$
+0$        }
+0$            x.e--;
+0$            x.f <<= 1u;
+0$        {
+0$        while ((x.f >> 63u) == 0)
+0$
+0$        JSON_ASSERT(x.f != 0);
+0$    {
+0$    static diyfp normalize(diyfp x) noexcept
+0$    */
+0$    @pre x.f != 0
+0$    @brief normalize x such that the significand is >= 2^(q-1)
+0$    /*!
+0$
+0$    }
+0$        return {h, x.e + y.e + 64};
+0$
+0$        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);
+0$
+0$        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up
+0$
+0$        // Q_hi + 1 does not overflow).
+0$        // Effectively we only need to add the highest bit in p_lo to p_hi (and
+0$        // But in this particular case here, the full p_lo is not required.
+0$        //
+0$        // p_lo = p0_lo + (Q << 32)
+0$        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
+0$        //
+0$        // The full product might now be computed as
+0$
+0$        std::uint64_t Q = p0_hi + p1_lo + p2_lo;
+0$
+0$        const std::uint64_t p2_hi = p2 >> 32u;
+0$        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
+0$        const std::uint64_t p1_hi = p1 >> 32u;
+0$        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
+0$        const std::uint64_t p0_hi = p0 >> 32u;
+0$
+0$        const std::uint64_t p3 = u_hi * v_hi;
+0$        const std::uint64_t p2 = u_hi * v_lo;
+0$        const std::uint64_t p1 = u_lo * v_hi;
+0$        const std::uint64_t p0 = u_lo * v_lo;
+0$
+0$        const std::uint64_t v_hi = y.f >> 32u;
+0$        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
+0$        const std::uint64_t u_hi = x.f >> 32u;
+0$        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
+0$
+0$        //   = p_lo + 2^64 p_hi
+0$        //
+0$        // (Q_hi + H does not overflow a 64-bit int)
+0$        //
+0$        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
+0$        //
+0$        // (Since Q might be larger than 2^32 - 1)
+0$        //
+0$        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
+0$        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
+0$        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
+0$        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
+0$        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
+0$        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
+0$        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
+0$        // p = u * v
+0$        //
+0$        // Emulate the 64-bit * 64-bit multiplication:
+0$
+0$        //  e = x.e + y.e + q
+0$        //  f = round((x.f * y.f) / 2^q)
+0$        // Computes:
+0$
+0$        static_assert(kPrecision == 64, "internal error");
+0$    {
+0$    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
+0$    */
+0$    @note The result is rounded. (Only the upper q bits are returned.)
+0$    @brief returns x * y
+0$    /*!
+0$
+0$    }
+0$        return {x.f - y.f, x.e};
+0$
+0$        JSON_ASSERT(x.f >= y.f);
+0$        JSON_ASSERT(x.e == y.e);
+0$    {
+0$    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
+0$    */
+0$    @pre x.e == y.e and x.f >= y.f
+0$    @brief returns x - y
+0$    /*!
+0$
+0$    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}
+0$
+0$    int e = 0;
+0$    std::uint64_t f = 0;
+0$
+0$    static constexpr int kPrecision = 64; // = q
+0${
+0$struct diyfp // f * 2^e
+0$
+0$}
+0$    return target;
+0$    std::memcpy(&target, &source, sizeof(Source));
+0$    Target target;
+0$
+0$    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");
+0${
+0$Target reinterpret_bits(const Source source)
+0$template<typename Target, typename Source>
+0$
+0${
+0$namespace dtoa_impl
+0$*/
+0$    Design and Implementation, PLDI 1996
+0$    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
+0$[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
+0$    Language Design and Implementation, PLDI 2010
+0$    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
+0$[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
+0$
+0$For a detailed description of the algorithm see:
+0$
+0$The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.
+0$
+0$http://florian.loitsch.com/publications (bench.tar.gz).
+0$implementation which may be obtained from
+0$This implementation is a slightly modified version of the reference
+0$
+0$conversion.
+0$@brief implements the Grisu2 algorithm for binary to decimal floating-point
+0$/*!
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#include <type_traits> // conditional
+0$#include <limits> // numeric_limits
+0$#include <cstring> // memcpy, memmove
+0$#include <cstdint> // intN_t, uintN_t
+0$#include <cmath>   // signbit, isfinite
+0$#include <array> // array
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$// SPDX-FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/conversions/to_chars.hpp>
+0$
+0$#include <utility> // move
+0$#include <type_traits> // is_same
+0$#include <iomanip> // setfill, setw
+0$#include <string> // string, char_traits
+0$#include <limits> // numeric_limits
+0$#include <cstdio> // snprintf
+0$#include <cstdint> // uint8_t
+0$#include <cstddef> // size_t, ptrdiff_t
+0$#include <cmath> // labs, isfinite, isnan, signbit
+0$#include <clocale> // localeconv, lconv
+0$#include <array> // array
+0$#include <algorithm> // reverse, remove, fill, find, none_of
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$// SPDX-FileCopyrightText: 2008-2009 Björn Hoehrmann <bjoern@hoehrmann.de>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/output/serializer.hpp>
+0$
+0$// #include <nlohmann/detail/output/output_adapters.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    output_adapter_t<CharType> oa = nullptr;
+0$    /// the output
+0$
+0$    const bool is_little_endian = little_endianness();
+0$    /// whether we can assume little endianness
+0$  private:
+0$
+0$    }
+0$        return x;
+0$    {
+0$    static constexpr CharType to_char_type(InputCharType x) noexcept
+0$                   > * = nullptr >
+0$                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
+0$                   std::is_signed<char>::value &&
+0$                   std::is_signed<C>::value &&
+0$               enable_if_t <
+0$    template < typename InputCharType, typename C = CharType,
+0$
+0$    }
+0$        return x;
+0$    {
+0$    static constexpr CharType to_char_type(std::uint8_t x) noexcept
+0$             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
+0$    template<typename C = CharType,
+0$
+0$    }
+0$        return result;
+0$        std::memcpy(&result, &x, sizeof(x));
+0$        CharType result;
+0$        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
+0$        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
+0$    {
+0$    static CharType to_char_type(std::uint8_t x) noexcept
+0$               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
+0$    template < typename C = CharType,
+0$
+0$    }
+0$        return *reinterpret_cast<char*>(&x);
+0$    {
+0$    static constexpr CharType to_char_type(std::uint8_t x) noexcept
+0$               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
+0$    template < typename C = CharType,
+0$    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
+0$    // such a conversion is required to allow values greater than 128.
+0$    // between uint8_t and CharType. In case CharType is not unsigned,
+0$    // The following to_char_type functions are implement the conversion
+0$  public:
+0$
+0$    }
+0$#endif
+0$#pragma GCC diagnostic pop
+0$#ifdef __GNUC__
+0$        }
+0$            write_number(n);
+0$                                : get_msgpack_float_prefix(n));
+0$                                ? get_cbor_float_prefix(n)
+0$            oa->write_character(format == detail::input_format_t::cbor
+0$        {
+0$        else
+0$        }
+0$            write_number(static_cast<float>(n));
+0$                                : get_msgpack_float_prefix(static_cast<float>(n)));
+0$                                ? get_cbor_float_prefix(static_cast<float>(n))
+0$            oa->write_character(format == detail::input_format_t::cbor
+0$        {
+0$                static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
+0$                static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
+0$        if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
+0$#endif
+0$#pragma GCC diagnostic ignored "-Wfloat-equal"
+0$#pragma GCC diagnostic push
+0$#ifdef __GNUC__
+0$    {
+0$    void write_compact_float(const number_float_t n, detail::input_format_t format)
+0$
+0$    }
+0$        oa->write_characters(vec.data(), sizeof(NumberType));
+0$
+0$        }
+0$            std::reverse(vec.begin(), vec.end());
+0$            // reverse byte order prior to conversion if necessary
+0$        {
+0$        if (is_little_endian != OutputIsLittleEndian)
+0$        // step 2: write array to output (with possible reordering)
+0$
+0$        std::memcpy(vec.data(), &n, sizeof(NumberType));
+0$        std::array<CharType, sizeof(NumberType)> vec{};
+0$        // step 1: write number to array of length NumberType
+0$    {
+0$    void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
+0$    template<typename NumberType>
+0$    */
+0$          on big endian systems.
+0$          On the other hand, BSON and BJData use little endian and should reorder
+0$          endian) and therefore need reordering on little endian systems.
+0$          in CBOR, MessagePack, and UBJSON are stored in network order (big
+0$    @note This function needs to respect the system's endianness, because bytes
+0$
+0$    @tparam NumberType the type of the number
+0$                                 required to be little endian
+0$    @param[in] OutputIsLittleEndian Set to true if output data is
+0$    @param[in] n number of type @a NumberType
+0$    @brief write a number to output input
+0$    /*
+0$
+0$    ///////////////////////
+0$    // Utility functions //
+0$    ///////////////////////
+0$
+0$    }
+0$        return false;
+0$        }
+0$            }
+0$                write_number(static_cast<double>(el.m_data.m_value.number_float), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'D')
+0$        }
+0$            }
+0$                write_number(static_cast<float>(el.m_data.m_value.number_float), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'd')
+0$        }
+0$            }
+0$                write_number(static_cast<std::int64_t>(el.m_data.m_value.number_integer), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'L')
+0$        }
+0$            }
+0$                write_number(static_cast<std::uint64_t>(el.m_data.m_value.number_unsigned), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'M')
+0$        }
+0$            }
+0$                write_number(static_cast<std::int32_t>(el.m_data.m_value.number_integer), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'l')
+0$        }
+0$            }
+0$                write_number(static_cast<std::uint32_t>(el.m_data.m_value.number_unsigned), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'm')
+0$        }
+0$            }
+0$                write_number(static_cast<std::int16_t>(el.m_data.m_value.number_integer), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'I')
+0$        }
+0$            }
+0$                write_number(static_cast<std::uint16_t>(el.m_data.m_value.number_unsigned), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'u')
+0$        }
+0$            }
+0$                write_number(static_cast<std::int8_t>(el.m_data.m_value.number_integer), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        else if (dtype == 'i')
+0$        }
+0$            }
+0$                write_number(static_cast<std::uint8_t>(el.m_data.m_value.number_unsigned), true);
+0$            {
+0$            for (const auto& el : value.at(key))
+0$        {
+0$        if (dtype == 'U' || dtype == 'C')
+0$        key = "_ArrayData_";
+0$
+0$        write_ubjson(value.at(key), use_count, use_type, true,  true);
+0$        key = "_ArraySize_";
+0$
+0$        oa->write_character('#');
+0$        oa->write_character(dtype);
+0$        oa->write_character('$');
+0$        oa->write_character('[');
+0$
+0$        }
+0$            return true;
+0$        {
+0$        if (value.at(key).size() != len)
+0$        key = "_ArrayData_";
+0$
+0$        }
+0$            len *= static_cast<std::size_t>(el.m_data.m_value.number_unsigned);
+0$        {
+0$        for (const auto& el : value.at(key))
+0$        std::size_t len = (value.at(key).empty() ? 0 : 1);
+0$        key = "_ArraySize_";
+0$
+0$        CharType dtype = it->second;
+0$        }
+0$            return true;
+0$        {
+0$        if (it == bjdtype.end())
+0$        auto it = bjdtype.find(static_cast<string_t>(value.at(key)));
+0$        string_t key = "_ArrayType_";
+0$
+0$        };
+0$            {"uint32", 'm'}, {"int32", 'l'}, {"uint64", 'M'}, {"int64", 'L'}, {"single", 'd'}, {"double", 'D'}, {"char", 'C'}
+0$        std::map<string_t, CharType> bjdtype = {{"uint8", 'U'},  {"int8", 'i'},  {"uint16", 'u'}, {"int16", 'I'},
+0$    {
+0$    bool write_bjdata_ndarray(const typename BasicJsonType::object_t& value, const bool use_count, const bool use_type)
+0$    */
+0$    @return false if the object is successfully converted to a bjdata ndarray, true if the type or size is invalid
+0$    /*!
+0$
+0$    }
+0$        return 'D';  // float 64
+0$    {
+0$    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
+0$
+0$    }
+0$        return 'd';  // float 32
+0$    {
+0$    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
+0$
+0$    }
+0$        }
+0$                return 'N';
+0$            default:  // discarded values
+0$            case value_t::discarded:
+0$
+0$                return '{';
+0$            case value_t::object:
+0$
+0$                return '[';
+0$            case value_t::binary:
+0$            case value_t::array: // fallthrough
+0$
+0$                return 'S';
+0$            case value_t::string:
+0$
+0$                return get_ubjson_float_prefix(j.m_data.m_value.number_float);
+0$            case value_t::number_float:
+0$
+0$            }
+0$                return 'H'; // LCOV_EXCL_LINE
+0$                // anything else is treated as high-precision number
+0$                }
+0$                    return 'M';
+0$                {
+0$                if (use_bjdata && j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
+0$                }
+0$                    return 'L';
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
+0$                }
+0$                    return 'm';
+0$                {
+0$                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint32_t>::max)()))
+0$                }
+0$                    return 'l';
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
+0$                }
+0$                    return 'u';
+0$                {
+0$                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint16_t>::max)()))
+0$                }
+0$                    return 'I';
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
+0$                }
+0$                    return 'U';
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
+0$                }
+0$                    return 'i';
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                return 'H'; // LCOV_EXCL_LINE
+0$                // anything else is treated as high-precision number
+0$                }
+0$                    return 'L';
+0$                {
+0$                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
+0$                }
+0$                    return 'm';
+0$                {
+0$                if (use_bjdata && ((std::numeric_limits<std::uint32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)()))
+0$                }
+0$                    return 'l';
+0$                {
+0$                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
+0$                }
+0$                    return 'u';
+0$                {
+0$                if (use_bjdata && ((std::numeric_limits<std::uint16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)()))
+0$                }
+0$                    return 'I';
+0$                {
+0$                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
+0$                }
+0$                    return 'U';
+0$                {
+0$                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    return 'i';
+0$                {
+0$                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
+0$            {
+0$            case value_t::number_integer:
+0$
+0$                return j.m_data.m_value.boolean ? 'T' : 'F';
+0$            case value_t::boolean:
+0$
+0$                return 'Z';
+0$            case value_t::null:
+0$        {
+0$        switch (j.type())
+0$    {
+0$    CharType ubjson_prefix(const BasicJsonType& j, const bool use_bjdata) const noexcept
+0$    */
+0$    @brief determine the type prefix of container values
+0$    /*!
+0$
+0$    }
+0$        // LCOV_EXCL_STOP
+0$        }
+0$            }
+0$                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
+0$            {
+0$            for (std::size_t i = 0; i < number.size(); ++i)
+0$            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
+0$            const auto number = BasicJsonType(n).dump();
+0$
+0$            }
+0$                oa->write_character(to_char_type('H'));  // high-precision number
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else
+0$        // LCOV_EXCL_START
+0$        }
+0$            write_number(static_cast<std::int64_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('L'));  // int64
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
+0$        }
+0$            write_number(static_cast<uint32_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::max)())))
+0$        }
+0$            write_number(static_cast<std::int32_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('l'));  // int32
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
+0$        }
+0$            write_number(static_cast<uint16_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::max)())))
+0$        }
+0$            write_number(static_cast<std::int16_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('I'));  // int16
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
+0$        }
+0$            write_number(static_cast<std::uint8_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('U'));  // uint8
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::int8_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('i'));  // int8
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
+0$    {
+0$                                         const bool use_bjdata)
+0$                                         const bool add_prefix,
+0$    void write_number_with_ubjson_prefix(const NumberType n,
+0$                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
+0$                   std::is_signed<NumberType>::value&&
+0$    template < typename NumberType, typename std::enable_if <
+0$    // UBJSON: write number (signed integer)
+0$
+0$    }
+0$        }
+0$            }
+0$                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
+0$            {
+0$            for (std::size_t i = 0; i < number.size(); ++i)
+0$            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
+0$            const auto number = BasicJsonType(n).dump();
+0$
+0$            }
+0$                oa->write_character(to_char_type('H'));  // high-precision number
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else
+0$        }
+0$            write_number(static_cast<std::uint64_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('M'));  // uint64 - bjdata only
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (use_bjdata && n <= (std::numeric_limits<uint64_t>::max)())
+0$        }
+0$            write_number(static_cast<std::int64_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('L'));  // int64
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::uint32_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint32_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::int32_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('l'));  // int32
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::uint16_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint16_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::int16_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('I'));  // int16
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
+0$        }
+0$            write_number(static_cast<std::uint8_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('U'));  // uint8
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
+0$        }
+0$            write_number(static_cast<std::uint8_t>(n), use_bjdata);
+0$            }
+0$                oa->write_character(to_char_type('i'));  // int8
+0$            {
+0$            if (add_prefix)
+0$        {
+0$        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
+0$    {
+0$                                         const bool use_bjdata)
+0$                                         const bool add_prefix,
+0$    void write_number_with_ubjson_prefix(const NumberType n,
+0$                 std::is_unsigned<NumberType>::value, int>::type = 0>
+0$    template<typename NumberType, typename std::enable_if<
+0$    // UBJSON: write number (unsigned integer)
+0$
+0$    }
+0$        write_number(n, use_bjdata);
+0$        }
+0$            oa->write_character(get_ubjson_float_prefix(n));
+0$        {
+0$        if (add_prefix)
+0$    {
+0$                                         const bool use_bjdata)
+0$                                         const bool add_prefix,
+0$    void write_number_with_ubjson_prefix(const NumberType n,
+0$                 std::is_floating_point<NumberType>::value, int>::type = 0>
+0$    template<typename NumberType, typename std::enable_if<
+0$    // UBJSON: write number (floating point)
+0$
+0$    ////////////
+0$    // UBJSON //
+0$    ////////////
+0$
+0$    }
+0$        return to_char_type(0xCB);  // float 64
+0$    {
+0$    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
+0$
+0$    }
+0$        return to_char_type(0xCA);  // float 32
+0$    {
+0$    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
+0$
+0$    /////////////
+0$    // MsgPack //
+0$    /////////////
+0$
+0$    }
+0$        return to_char_type(0xFB);  // Double-Precision Float
+0$    {
+0$    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
+0$
+0$    }
+0$        return to_char_type(0xFA);  // Single-Precision Float
+0$    {
+0$    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
+0$
+0$    //////////
+0$    // CBOR //
+0$    //////////
+0$
+0$    }
+0$        oa->write_character(to_char_type(0x00));
+0$
+0$        }
+0$            write_bson_element(el.first, el.second);
+0$        {
+0$        for (const auto& el : value)
+0$
+0$        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_object_size(value)), true);
+0$    {
+0$    void write_bson_object(const typename BasicJsonType::object_t& value)
+0$    */
+0$    @pre       value.type() == value_t::object
+0$    @param[in] value  JSON value to serialize
+0$    /*!
+0$
+0$    }
+0$        return sizeof(std::int32_t) + document_size + 1ul;
+0$
+0$        });
+0$            return result += calc_bson_element_size(el.first, el.second);
+0$        {
+0$                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)
+0$        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),
+0$    {
+0$    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
+0$    */
+0$    @pre       value.type() == value_t::object
+0$    @param[in] value  JSON value to serialize
+0$           JSON-object @a j.
+0$    @brief Calculates the size of the BSON serialization of the given
+0$    /*!
+0$
+0$    }
+0$        }
+0$                // LCOV_EXCL_STOP
+0$                return;
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
+0$            default:
+0$            case value_t::discarded:
+0$            // LCOV_EXCL_START
+0$
+0$                return write_bson_null(name);
+0$            case value_t::null:
+0$
+0$                return write_bson_string(name, *j.m_data.m_value.string);
+0$            case value_t::string:
+0$
+0$                return write_bson_unsigned(name, j);
+0$            case value_t::number_unsigned:
+0$
+0$                return write_bson_integer(name, j.m_data.m_value.number_integer);
+0$            case value_t::number_integer:
+0$
+0$                return write_bson_double(name, j.m_data.m_value.number_float);
+0$            case value_t::number_float:
+0$
+0$                return write_bson_boolean(name, j.m_data.m_value.boolean);
+0$            case value_t::boolean:
+0$
+0$                return write_bson_binary(name, *j.m_data.m_value.binary);
+0$            case value_t::binary:
+0$
+0$                return write_bson_array(name, *j.m_data.m_value.array);
+0$            case value_t::array:
+0$
+0$                return write_bson_object_entry(name, *j.m_data.m_value.object);
+0$            case value_t::object:
+0$        {
+0$        switch (j.type())
+0$    {
+0$                            const BasicJsonType& j)
+0$    void write_bson_element(const string_t& name,
+0$    */
+0$                current BSON document
+0$    @param name The name to associate with the JSON entity @a j within the
+0$           key @a name.
+0$    @brief Serializes the JSON value @a j to BSON and associates it with the
+0$    /*!
+0$
+0$    }
+0$        }
+0$                // LCOV_EXCL_STOP
+0$                return 0ul;
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
+0$            default:
+0$            case value_t::discarded:
+0$            // LCOV_EXCL_START
+0$
+0$                return header_size + 0ul;
+0$            case value_t::null:
+0$
+0$                return header_size + calc_bson_string_size(*j.m_data.m_value.string);
+0$            case value_t::string:
+0$
+0$                return header_size + calc_bson_unsigned_size(j.m_data.m_value.number_unsigned);
+0$            case value_t::number_unsigned:
+0$
+0$                return header_size + calc_bson_integer_size(j.m_data.m_value.number_integer);
+0$            case value_t::number_integer:
+0$
+0$                return header_size + 8ul;
+0$            case value_t::number_float:
+0$
+0$                return header_size + 1ul;
+0$            case value_t::boolean:
+0$
+0$                return header_size + calc_bson_binary_size(*j.m_data.m_value.binary);
+0$            case value_t::binary:
+0$
+0$                return header_size + calc_bson_array_size(*j.m_data.m_value.array);
+0$            case value_t::array:
+0$
+0$                return header_size + calc_bson_object_size(*j.m_data.m_value.object);
+0$            case value_t::object:
+0$        {
+0$        switch (j.type())
+0$        const auto header_size = calc_bson_entry_header_size(name, j);
+0$    {
+0$            const BasicJsonType& j)
+0$    static std::size_t calc_bson_element_size(const string_t& name,
+0$    */
+0$    @return The calculated size for the BSON document entry for @a j with the given @a name.
+0$    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
+0$    /*!
+0$
+0$    }
+0$        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
+0$
+0$        write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : static_cast<std::uint8_t>(0x00));
+0$        write_number<std::int32_t>(static_cast<std::int32_t>(value.size()), true);
+0$
+0$        write_bson_entry_header(name, 0x05);
+0$    {
+0$                           const binary_t& value)
+0$    void write_bson_binary(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and binary value @a value
+0$    /*!
+0$
+0$    }
+0$        oa->write_character(to_char_type(0x00));
+0$
+0$        }
+0$            write_bson_element(std::to_string(array_index++), el);
+0$        {
+0$        for (const auto& el : value)
+0$
+0$        std::size_t array_index = 0ul;
+0$
+0$        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_array_size(value)), true);
+0$        write_bson_entry_header(name, 0x04); // array
+0$    {
+0$                          const typename BasicJsonType::array_t& value)
+0$    void write_bson_array(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and array @a value
+0$    /*!
+0$
+0$    }
+0$        return sizeof(std::int32_t) + value.size() + 1ul;
+0$    {
+0$    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
+0$    */
+0$    @return The size of the BSON-encoded binary array @a value
+0$    /*!
+0$
+0$    }
+0$        return sizeof(std::int32_t) + embedded_document_size + 1ul;
+0$
+0$        });
+0$            return result + calc_bson_element_size(std::to_string(array_index++), el);
+0$        {
+0$        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast<std::size_t>(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
+0$
+0$        std::size_t array_index = 0ul;
+0$    {
+0$    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
+0$    */
+0$    @return The size of the BSON-encoded array @a value
+0$    /*!
+0$
+0$    }
+0$        write_bson_object(value);
+0$        write_bson_entry_header(name, 0x03); // object
+0$    {
+0$                                 const typename BasicJsonType::object_t& value)
+0$    void write_bson_object_entry(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and object @a value
+0$    /*!
+0$
+0$    }
+0$        }
+0$            JSON_THROW(out_of_range::create(407, concat("integer number ", std::to_string(j.m_data.m_value.number_unsigned), " cannot be represented by BSON as it does not fit int64"), &j));
+0$        {
+0$        else
+0$        }
+0$            write_number<std::int64_t>(static_cast<std::int64_t>(j.m_data.m_value.number_unsigned), true);
+0$            write_bson_entry_header(name, 0x12 /* int64 */);
+0$        {
+0$        else if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
+0$        }
+0$            write_number<std::int32_t>(static_cast<std::int32_t>(j.m_data.m_value.number_unsigned), true);
+0$            write_bson_entry_header(name, 0x10 /* int32 */);
+0$        {
+0$        if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
+0$    {
+0$                             const BasicJsonType& j)
+0$    void write_bson_unsigned(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and unsigned @a value
+0$    /*!
+0$
+0$    }
+0$               : sizeof(std::int64_t);
+0$               ? sizeof(std::int32_t)
+0$        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
+0$    {
+0$    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
+0$    */
+0$    @return The size of the BSON-encoded unsigned integer in @a j
+0$    /*!
+0$
+0$    }
+0$        }
+0$            write_number<std::int64_t>(static_cast<std::int64_t>(value), true);
+0$            write_bson_entry_header(name, 0x12); // int64
+0$        {
+0$        else
+0$        }
+0$            write_number<std::int32_t>(static_cast<std::int32_t>(value), true);
+0$            write_bson_entry_header(name, 0x10); // int32
+0$        {
+0$        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
+0$    {
+0$                            const std::int64_t value)
+0$    void write_bson_integer(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and integer @a value
+0$    /*!
+0$
+0$    }
+0$               : sizeof(std::int64_t);
+0$               ? sizeof(std::int32_t)
+0$        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
+0$    {
+0$    static std::size_t calc_bson_integer_size(const std::int64_t value)
+0$    */
+0$    @return The size of the BSON-encoded integer @a value
+0$    /*!
+0$
+0$    }
+0$        write_bson_entry_header(name, 0x0A);
+0$    {
+0$    void write_bson_null(const string_t& name)
+0$    */
+0$    @brief Writes a BSON element with key @a name and null value
+0$    /*!
+0$
+0$    }
+0$            value.size() + 1);
+0$            reinterpret_cast<const CharType*>(value.c_str()),
+0$        oa->write_characters(
+0$        write_number<std::int32_t>(static_cast<std::int32_t>(value.size() + 1ul), true);
+0$
+0$        write_bson_entry_header(name, 0x02);
+0$    {
+0$                           const string_t& value)
+0$    void write_bson_string(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and string value @a value
+0$    /*!
+0$
+0$    }
+0$        return sizeof(std::int32_t) + value.size() + 1ul;
+0$    {
+0$    static std::size_t calc_bson_string_size(const string_t& value)
+0$    */
+0$    @return The size of the BSON-encoded string in @a value
+0$    /*!
+0$
+0$    }
+0$        write_number<double>(value, true);
+0$        write_bson_entry_header(name, 0x01);
+0$    {
+0$                           const double value)
+0$    void write_bson_double(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and double value @a value
+0$    /*!
+0$
+0$    }
+0$        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
+0$        write_bson_entry_header(name, 0x08);
+0$    {
+0$                            const bool value)
+0$    void write_bson_boolean(const string_t& name,
+0$    */
+0$    @brief Writes a BSON element with key @a name and boolean value @a value
+0$    /*!
+0$
+0$    }
+0$            name.size() + 1u);
+0$            reinterpret_cast<const CharType*>(name.c_str()),
+0$        oa->write_characters(
+0$        oa->write_character(to_char_type(element_type)); // boolean
+0$    {
+0$                                 const std::uint8_t element_type)
+0$    void write_bson_entry_header(const string_t& name,
+0$    */
+0$    @brief Writes the given @a element_type and @a name to the output adapter
+0$    /*!
+0$
+0$    }
+0$        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
+0$
+0$        }
+0$            static_cast<void>(j);
+0$            JSON_THROW(out_of_range::create(409, concat("BSON key cannot contain code point U+0000 (at byte ", std::to_string(it), ")"), &j));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
+0$        const auto it = name.find(static_cast<typename string_t::value_type>(0));
+0$    {
+0$    static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
+0$    */
+0$            and the entry name size (and its null-terminator).
+0$    @return The size of a BSON document entry header, including the id marker
+0$    /*!
+0$
+0$    //////////
+0$    // BSON //
+0$    //////////
+0$  private:
+0$
+0$    }
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$
+0$            }
+0$                break;
+0$
+0$                }
+0$                    oa->write_character(to_char_type('}'));
+0$                {
+0$                if (!use_count)
+0$
+0$                }
+0$                    write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata);
+0$                        el.first.size());
+0$                        reinterpret_cast<const CharType*>(el.first.c_str()),
+0$                    oa->write_characters(
+0$                    write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.object)
+0$
+0$                }
+0$                    write_number_with_ubjson_prefix(j.m_data.m_value.object->size(), true, use_bjdata);
+0$                    oa->write_character(to_char_type('#'));
+0$                {
+0$                if (use_count)
+0$
+0$                }
+0$                    }
+0$                        oa->write_character(first_prefix);
+0$                        oa->write_character(to_char_type('$'));
+0$                        prefix_required = false;
+0$                    {
+0$                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
+0$
+0$                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type
+0$
+0$                    });
+0$                        return ubjson_prefix(v, use_bjdata) == first_prefix;
+0$                    {
+0$                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
+0$                    const bool same_prefix = std::all_of(j.begin(), j.end(),
+0$                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
+0$                    JSON_ASSERT(use_count);
+0$                {
+0$                if (use_type && !j.m_data.m_value.object->empty())
+0$                bool prefix_required = true;
+0$
+0$                }
+0$                    oa->write_character(to_char_type('{'));
+0$                {
+0$                if (add_prefix)
+0$
+0$                }
+0$                    }
+0$                        break;
+0$                    {
+0$                    if (!write_bjdata_ndarray(*j.m_data.m_value.object, use_count, use_type))  // decode bjdata ndarray in the JData format (https://github.com/NeuroJSON/jdata)
+0$                {
+0$                if (use_bjdata && j.m_data.m_value.object->size() == 3 && j.m_data.m_value.object->find("_ArrayType_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArraySize_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArrayData_") != j.m_data.m_value.object->end())
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$
+0$                }
+0$                    oa->write_character(to_char_type(']'));
+0$                {
+0$                if (!use_count)
+0$
+0$                }
+0$                    }
+0$                        oa->write_character(j.m_data.m_value.binary->data()[i]);
+0$                        oa->write_character(to_char_type('U'));
+0$                    {
+0$                    for (size_t i = 0; i < j.m_data.m_value.binary->size(); ++i)
+0$                {
+0$                else
+0$                }
+0$                        j.m_data.m_value.binary->size());
+0$                        reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
+0$                    oa->write_characters(
+0$                {
+0$                if (use_type)
+0$
+0$                }
+0$                    write_number_with_ubjson_prefix(j.m_data.m_value.binary->size(), true, use_bjdata);
+0$                    oa->write_character(to_char_type('#'));
+0$                {
+0$                if (use_count)
+0$
+0$                }
+0$                    oa->write_character('U');
+0$                    oa->write_character(to_char_type('$'));
+0$                    JSON_ASSERT(use_count);
+0$                {
+0$                if (use_type && !j.m_data.m_value.binary->empty())
+0$
+0$                }
+0$                    oa->write_character(to_char_type('['));
+0$                {
+0$                if (add_prefix)
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$
+0$                }
+0$                    oa->write_character(to_char_type(']'));
+0$                {
+0$                if (!use_count)
+0$
+0$                }
+0$                    write_ubjson(el, use_count, use_type, prefix_required, use_bjdata);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.array)
+0$
+0$                }
+0$                    write_number_with_ubjson_prefix(j.m_data.m_value.array->size(), true, use_bjdata);
+0$                    oa->write_character(to_char_type('#'));
+0$                {
+0$                if (use_count)
+0$
+0$                }
+0$                    }
+0$                        oa->write_character(first_prefix);
+0$                        oa->write_character(to_char_type('$'));
+0$                        prefix_required = false;
+0$                    {
+0$                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
+0$
+0$                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type
+0$
+0$                    });
+0$                        return ubjson_prefix(v, use_bjdata) == first_prefix;
+0$                    {
+0$                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
+0$                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
+0$                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
+0$                    JSON_ASSERT(use_count);
+0$                {
+0$                if (use_type && !j.m_data.m_value.array->empty())
+0$                bool prefix_required = true;
+0$
+0$                }
+0$                    oa->write_character(to_char_type('['));
+0$                {
+0$                if (add_prefix)
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                    j.m_data.m_value.string->size());
+0$                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
+0$                oa->write_characters(
+0$                write_number_with_ubjson_prefix(j.m_data.m_value.string->size(), true, use_bjdata);
+0$                }
+0$                    oa->write_character(to_char_type('S'));
+0$                {
+0$                if (add_prefix)
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                write_number_with_ubjson_prefix(j.m_data.m_value.number_float, add_prefix, use_bjdata);
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                write_number_with_ubjson_prefix(j.m_data.m_value.number_unsigned, add_prefix, use_bjdata);
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                write_number_with_ubjson_prefix(j.m_data.m_value.number_integer, add_prefix, use_bjdata);
+0$            {
+0$            case value_t::number_integer:
+0$
+0$            }
+0$                break;
+0$                }
+0$                                        : to_char_type('F'));
+0$                                        ? to_char_type('T')
+0$                    oa->write_character(j.m_data.m_value.boolean
+0$                {
+0$                if (add_prefix)
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    oa->write_character(to_char_type('Z'));
+0$                {
+0$                if (add_prefix)
+0$            {
+0$            case value_t::null:
+0$        {
+0$        switch (j.type())
+0$    {
+0$                      const bool use_bjdata = false)
+0$                      const bool use_type, const bool add_prefix = true,
+0$    void write_ubjson(const BasicJsonType& j, const bool use_count,
+0$    */
+0$    @param[in] use_bjdata  whether write in BJData format, default is false
+0$    @param[in] add_prefix  whether prefixes need to be used for this value
+0$    @param[in] use_type    whether to use '$' prefixes (optimized format)
+0$    @param[in] use_count   whether to use '#' prefixes (optimized format)
+0$    @param[in] j  JSON value to serialize
+0$    /*!
+0$
+0$    }
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_msgpack(el.second);
+0$                    write_msgpack(el.first);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.object)
+0$                // step 2: write each element
+0$
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0xDF));
+0$                    // map 32
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0xDE));
+0$                    // map 16
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
+0$                    // fixmap
+0$                {
+0$                if (N <= 15)
+0$                const auto N = j.m_data.m_value.object->size();
+0$                // step 1: write control byte and the object size
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$
+0$                    N);
+0$                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
+0$                oa->write_characters(
+0$                // step 2: write the byte string
+0$
+0$                }
+0$                    write_number(static_cast<std::int8_t>(j.m_data.m_value.binary->subtype()));
+0$                {
+0$                if (use_ext)
+0$                // step 1.5: if this is an ext type, write the subtype
+0$
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(output_type));
+0$
+0$                                                     : 0xC6; // bin 32
+0$                                                     ? 0xC9 // ext 32
+0$                    const std::uint8_t output_type = use_ext
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(output_type));
+0$
+0$                                                     : 0xC5; // bin 16
+0$                                                     ? 0xC8 // ext 16
+0$                    const std::uint8_t output_type = use_ext
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(N));
+0$                    {
+0$                    if (!fixed)
+0$                    oa->write_character(to_char_type(output_type));
+0$
+0$                    }
+0$                        fixed = false;
+0$                        output_type = 0xC4; // bin 8
+0$                    {
+0$                    else
+0$                    }
+0$
+0$                        }
+0$                                break;
+0$                                fixed = false;
+0$                                output_type = 0xC7; // ext 8
+0$                            default:
+0$                                break;
+0$                                output_type = 0xD8; // fixext 16
+0$                            case 16:
+0$                                break;
+0$                                output_type = 0xD7; // fixext 8
+0$                            case 8:
+0$                                break;
+0$                                output_type = 0xD6; // fixext 4
+0$                            case 4:
+0$                                break;
+0$                                output_type = 0xD5; // fixext 2
+0$                            case 2:
+0$                                break;
+0$                                output_type = 0xD4; // fixext 1
+0$                            case 1:
+0$                        {
+0$                        switch (N)
+0$                    {
+0$                    if (use_ext)
+0$                    bool fixed = true;
+0$                    std::uint8_t output_type{};
+0$                {
+0$                if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                const auto N = j.m_data.m_value.binary->size();
+0$                // step 1: write control byte and the byte string length
+0$
+0$                const bool use_ext = j.m_data.m_value.binary->has_subtype();
+0$                // determine whether or not to use the ext or fixext types
+0$                // step 0: determine if the binary type has a set subtype to
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_msgpack(el);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.array)
+0$                // step 2: write each element
+0$
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0xDD));
+0$                    // array 32
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0xDC));
+0$                    // array 16
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0x90 | N));
+0$                    // fixarray
+0$                {
+0$                if (N <= 15)
+0$                const auto N = j.m_data.m_value.array->size();
+0$                // step 1: write control byte and the array size
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                    j.m_data.m_value.string->size());
+0$                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
+0$                oa->write_characters(
+0$                // step 2: write the string
+0$
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0xDB));
+0$                    // str 32
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0xDA));
+0$                    // str 16
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(N));
+0$                    oa->write_character(to_char_type(0xD9));
+0$                    // str 8
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0xA0 | N));
+0$                    // fixstr
+0$                {
+0$                if (N <= 31)
+0$                const auto N = j.m_data.m_value.string->size();
+0$                // step 1: write control byte and the string length
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::msgpack);
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
+0$                    oa->write_character(to_char_type(0xCF));
+0$                    // uint 64
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
+0$                    oa->write_character(to_char_type(0xCE));
+0$                    // uint 32
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
+0$                    oa->write_character(to_char_type(0xCD));
+0$                    // uint 16
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                    oa->write_character(to_char_type(0xCC));
+0$                    // uint 8
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                    // positive fixnum
+0$                {
+0$                if (j.m_data.m_value.number_unsigned < 128)
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::int64_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xD3));
+0$                        // int 64
+0$                    {
+0$                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
+0$                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
+0$                    }
+0$                        write_number(static_cast<std::int32_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xD2));
+0$                        // int 32
+0$                    {
+0$                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
+0$                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
+0$                    }
+0$                        write_number(static_cast<std::int16_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xD1));
+0$                        // int 16
+0$                    {
+0$                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
+0$                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
+0$                    }
+0$                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xD0));
+0$                        // int 8
+0$                    {
+0$                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
+0$                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
+0$                    }
+0$                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
+0$                        // negative fixnum
+0$                    {
+0$                    if (j.m_data.m_value.number_integer >= -32)
+0$                {
+0$                else
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xCF));
+0$                        // uint 64
+0$                    {
+0$                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xCE));
+0$                        // uint 32
+0$                    {
+0$                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xCD));
+0$                        // uint 16
+0$                    {
+0$                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0xCC));
+0$                        // uint 8
+0$                    {
+0$                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                        // positive fixnum
+0$                    {
+0$                    if (j.m_data.m_value.number_unsigned < 128)
+0$                    // the code from the value_t::number_unsigned case here.
+0$                    // signed integers and unsigned integers. Therefore, we used
+0$                    // MessagePack does not differentiate between positive
+0$                {
+0$                if (j.m_data.m_value.number_integer >= 0)
+0$            {
+0$            case value_t::number_integer:
+0$
+0$            }
+0$                break;
+0$                                    : to_char_type(0xC2));
+0$                                    ? to_char_type(0xC3)
+0$                oa->write_character(j.m_data.m_value.boolean
+0$            {
+0$            case value_t::boolean: // true and false
+0$
+0$            }
+0$                break;
+0$                oa->write_character(to_char_type(0xC0));
+0$            {
+0$            case value_t::null: // nil
+0$        {
+0$        switch (j.type())
+0$    {
+0$    void write_msgpack(const BasicJsonType& j)
+0$    */
+0$    @param[in] j  JSON value to serialize
+0$    /*!
+0$
+0$    }
+0$        }
+0$                break;
+0$            default:
+0$            case value_t::discarded:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_cbor(el.second);
+0$                    write_cbor(el.first);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.object)
+0$                // step 2: write each element
+0$
+0$                // LCOV_EXCL_STOP
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(N));
+0$                    oa->write_character(to_char_type(0xBB));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
+0$                // LCOV_EXCL_START
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0xBA));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0xB9));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(N));
+0$                    oa->write_character(to_char_type(0xB8));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0xA0 + N));
+0$                {
+0$                if (N <= 0x17)
+0$                const auto N = j.m_data.m_value.object->size();
+0$                // step 1: write control byte and the object size
+0$            {
+0$            case value_t::object:
+0$
+0$            }
+0$                break;
+0$
+0$                    N);
+0$                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
+0$                oa->write_characters(
+0$                // step 2: write each element
+0$
+0$                // LCOV_EXCL_STOP
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(N));
+0$                    oa->write_character(to_char_type(0x5B));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
+0$                // LCOV_EXCL_START
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0x5A));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0x59));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(N));
+0$                    oa->write_character(to_char_type(0x58));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0x40 + N));
+0$                {
+0$                if (N <= 0x17)
+0$                const auto N = j.m_data.m_value.binary->size();
+0$                // step 1: write control byte and the binary array size
+0$
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.binary->subtype()));
+0$                        write_number(static_cast<std::uint8_t>(0xdb));
+0$                    {
+0$                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.binary->subtype()));
+0$                        write_number(static_cast<std::uint8_t>(0xda));
+0$                    {
+0$                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.binary->subtype()));
+0$                        write_number(static_cast<std::uint8_t>(0xd9));
+0$                    {
+0$                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.binary->subtype()));
+0$                        write_number(static_cast<std::uint8_t>(0xd8));
+0$                    {
+0$                    if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
+0$                {
+0$                if (j.m_data.m_value.binary->has_subtype())
+0$            {
+0$            case value_t::binary:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_cbor(el);
+0$                {
+0$                for (const auto& el : *j.m_data.m_value.array)
+0$                // step 2: write each element
+0$
+0$                // LCOV_EXCL_STOP
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(N));
+0$                    oa->write_character(to_char_type(0x9B));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
+0$                // LCOV_EXCL_START
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0x9A));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0x99));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(N));
+0$                    oa->write_character(to_char_type(0x98));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0x80 + N));
+0$                {
+0$                if (N <= 0x17)
+0$                const auto N = j.m_data.m_value.array->size();
+0$                // step 1: write control byte and the array size
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                    j.m_data.m_value.string->size());
+0$                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
+0$                oa->write_characters(
+0$                // step 2: write the string
+0$
+0$                // LCOV_EXCL_STOP
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(N));
+0$                    oa->write_character(to_char_type(0x7B));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
+0$                // LCOV_EXCL_START
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(N));
+0$                    oa->write_character(to_char_type(0x7A));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(N));
+0$                    oa->write_character(to_char_type(0x79));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(N));
+0$                    oa->write_character(to_char_type(0x78));
+0$                {
+0$                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(0x60 + N));
+0$                {
+0$                if (N <= 0x17)
+0$                const auto N = j.m_data.m_value.string->size();
+0$                // step 1: write control byte and the string length
+0$            {
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::cbor);
+0$                {
+0$                else
+0$                }
+0$                    oa->write_character(to_char_type(0x00));
+0$                    oa->write_character(j.m_data.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
+0$                    oa->write_character(to_char_type(0xf9));
+0$                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
+0$                {
+0$                else if (std::isinf(j.m_data.m_value.number_float))
+0$                }
+0$                    oa->write_character(to_char_type(0x00));
+0$                    oa->write_character(to_char_type(0x7E));
+0$                    oa->write_character(to_char_type(0xF9));
+0$                    // NaN is 0xf97e00 in CBOR
+0$                {
+0$                if (std::isnan(j.m_data.m_value.number_float))
+0$            {
+0$            case value_t::number_float:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned));
+0$                    oa->write_character(to_char_type(0x1B));
+0$                {
+0$                else
+0$                }
+0$                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_unsigned));
+0$                    oa->write_character(to_char_type(0x1A));
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_unsigned));
+0$                    oa->write_character(to_char_type(0x19));
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
+0$                    oa->write_character(to_char_type(0x18));
+0$                {
+0$                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
+0$                }
+0$                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
+0$                {
+0$                if (j.m_data.m_value.number_unsigned <= 0x17)
+0$            {
+0$            case value_t::number_unsigned:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::uint64_t>(positive_number));
+0$                        oa->write_character(to_char_type(0x3B));
+0$                    {
+0$                    else
+0$                    }
+0$                        write_number(static_cast<std::uint32_t>(positive_number));
+0$                        oa->write_character(to_char_type(0x3A));
+0$                    {
+0$                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint16_t>(positive_number));
+0$                        oa->write_character(to_char_type(0x39));
+0$                    {
+0$                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(positive_number));
+0$                        oa->write_character(to_char_type(0x38));
+0$                    {
+0$                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
+0$                    {
+0$                    if (j.m_data.m_value.number_integer >= -24)
+0$                    const auto positive_number = -1 - j.m_data.m_value.number_integer;
+0$                    // byte, and the value is converted to a positive number.
+0$                    // The conversions below encode the sign in the first
+0$                {
+0$                else
+0$                }
+0$                    }
+0$                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0x1B));
+0$                    {
+0$                    else
+0$                    }
+0$                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0x1A));
+0$                    {
+0$                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0x19));
+0$                    {
+0$                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                        oa->write_character(to_char_type(0x18));
+0$                    {
+0$                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
+0$                    }
+0$                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
+0$                    {
+0$                    if (j.m_data.m_value.number_integer <= 0x17)
+0$                    // code from the value_t::number_unsigned case here.
+0$                    // integers and unsigned integers. Therefore, we used the
+0$                    // CBOR does not differentiate between positive signed
+0$                {
+0$                if (j.m_data.m_value.number_integer >= 0)
+0$            {
+0$            case value_t::number_integer:
+0$
+0$            }
+0$                break;
+0$                                    : to_char_type(0xF4));
+0$                                    ? to_char_type(0xF5)
+0$                oa->write_character(j.m_data.m_value.boolean
+0$            {
+0$            case value_t::boolean:
+0$
+0$            }
+0$                break;
+0$                oa->write_character(to_char_type(0xF6));
+0$            {
+0$            case value_t::null:
+0$        {
+0$        switch (j.type())
+0$    {
+0$    void write_cbor(const BasicJsonType& j)
+0$    */
+0$    @param[in] j  JSON value to serialize
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                JSON_THROW(type_error::create(317, concat("to serialize to BSON, top-level type must be object, but is ", j.type_name()), &j));
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::array:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                write_bson_object(*j.m_data.m_value.object);
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (j.type())
+0$    {
+0$    void write_bson(const BasicJsonType& j)
+0$    */
+0$    @pre       j.type() == value_t::object
+0$    @param[in] j  JSON value to serialize
+0$    /*!
+0$
+0$    }
+0$        JSON_ASSERT(oa);
+0$    {
+0$    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
+0$    */
+0$    @param[in] adapter  output adapter to write to
+0$
+0$    @brief create a binary writer
+0$    /*!
+0$  public:
+0$
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0${
+0$class binary_writer
+0$template<typename BasicJsonType, typename CharType>
+0$*/
+0$@brief serialization to CBOR and MessagePack values
+0$/*!
+0$
+0$///////////////////
+0$// binary writer //
+0$///////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    output_adapter_t<CharType> oa = nullptr;
+0$  private:
+0$
+0$    }
+0$        return oa;
+0$    {
+0$    operator output_adapter_t<CharType>()
+0$
+0$        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}
+0$    output_adapter(StringType& s)
+0$
+0$#endif  // JSON_NO_IO
+0$        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
+0$    output_adapter(std::basic_ostream<CharType>& s)
+0$#ifndef JSON_NO_IO
+0$
+0$        : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}
+0$    output_adapter(std::vector<CharType, AllocatorType>& vec)
+0$    template<typename AllocatorType = std::allocator<CharType>>
+0$  public:
+0${
+0$class output_adapter
+0$template<typename CharType, typename StringType = std::basic_string<CharType>>
+0$
+0$};
+0$    StringType& str;
+0$  private:
+0$
+0$    }
+0$        str.append(s, length);
+0$    {
+0$    void write_characters(const CharType* s, std::size_t length) override
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        str.push_back(c);
+0$    {
+0$    void write_character(CharType c) override
+0$
+0$    {}
+0$        : str(s)
+0$    explicit output_string_adapter(StringType& s) noexcept
+0$  public:
+0${
+0$class output_string_adapter : public output_adapter_protocol<CharType>
+0$template<typename CharType, typename StringType = std::basic_string<CharType>>
+0$/// output adapter for basic_string
+0$
+0$#endif  // JSON_NO_IO
+0$};
+0$    std::basic_ostream<CharType>& stream;
+0$  private:
+0$
+0$    }
+0$        stream.write(s, static_cast<std::streamsize>(length));
+0$    {
+0$    void write_characters(const CharType* s, std::size_t length) override
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        stream.put(c);
+0$    {
+0$    void write_character(CharType c) override
+0$
+0$    {}
+0$        : stream(s)
+0$    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
+0$  public:
+0${
+0$class output_stream_adapter : public output_adapter_protocol<CharType>
+0$template<typename CharType>
+0$/// output adapter for output streams
+0$#ifndef JSON_NO_IO
+0$
+0$};
+0$    std::vector<CharType, AllocatorType>& v;
+0$  private:
+0$
+0$    }
+0$        v.insert(v.end(), s, s + length);
+0$    {
+0$    void write_characters(const CharType* s, std::size_t length) override
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        v.push_back(c);
+0$    {
+0$    void write_character(CharType c) override
+0$
+0$    {}
+0$        : v(vec)
+0$    explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept
+0$  public:
+0${
+0$class output_vector_adapter : public output_adapter_protocol<CharType>
+0$template<typename CharType, typename AllocatorType = std::allocator<CharType>>
+0$/// output adapter for byte vectors
+0$
+0$using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;
+0$template<typename CharType>
+0$/// a type to simplify interfaces
+0$
+0$};
+0$    output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
+0$    output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
+0$    output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
+0$    output_adapter_protocol(const output_adapter_protocol&) = default;
+0$    output_adapter_protocol() = default;
+0$
+0$    virtual ~output_adapter_protocol() = default;
+0$    virtual void write_characters(const CharType* s, std::size_t length) = 0;
+0$    virtual void write_character(CharType c) = 0;
+0${
+0$template<typename CharType> struct output_adapter_protocol
+0$/// abstract output adapter interface
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#endif  // JSON_NO_IO
+0$    #include <ostream>  // basic_ostream
+0$    #include <ios>      // streamsize
+0$#ifndef JSON_NO_IO
+0$
+0$#include <vector> // vector
+0$#include <string> // basic_string
+0$#include <memory> // shared_ptr, make_shared
+0$#include <iterator> // back_inserter
+0$#include <cstddef> // size_t
+0$#include <algorithm> // copy
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/output/output_adapters.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/input/binary_reader.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // move
+0$#include <string> // string
+0$#include <limits> // numeric_limits
+0$#include <cstring> // memcpy
+0$#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
+0$#include <cmath> // isnan, isinf
+0$#include <map> // map
+0$#include <array> // array
+0$#include <algorithm> // reverse
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/output/binary_writer.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/string_escape.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    value_type const* value_ref = nullptr;
+0$    mutable value_type owned_value = nullptr;
+0$  private:
+0$
+0$    }
+0$        return &** this;
+0$    {
+0$    value_type const* operator->() const
+0$
+0$    }
+0$        return value_ref ? *value_ref : owned_value;
+0$    {
+0$    value_type const& operator*() const
+0$
+0$    }
+0$        return *value_ref;
+0$        }
+0$            return std::move(owned_value);
+0$        {
+0$        if (value_ref == nullptr)
+0$    {
+0$    value_type moved_or_copied() const
+0$
+0$    ~json_ref() = default;
+0$    json_ref& operator=(json_ref&&) = delete;
+0$    json_ref& operator=(const json_ref&) = delete;
+0$    json_ref(const json_ref&) = delete;
+0$    json_ref(json_ref&&) noexcept = default;
+0$    // class should be movable only
+0$
+0$    {}
+0$        : owned_value(std::forward<Args>(args)...)
+0$    json_ref(Args && ... args)
+0$        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
+0$        class... Args,
+0$    template <
+0$
+0$    {}
+0$        : owned_value(init)
+0$    json_ref(std::initializer_list<json_ref> init)
+0$
+0$    {}
+0$        : value_ref(&value)
+0$    json_ref(const value_type& value)
+0$
+0$    {}
+0$        : owned_value(std::move(value))
+0$    json_ref(value_type&& value)
+0$
+0$    using value_type = BasicJsonType;
+0$  public:
+0${
+0$class json_ref
+0$template<typename BasicJsonType>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <utility>
+0$#include <initializer_list>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/json_ref.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$#endif
+0$}
+0$    return lhs.reference_tokens < rhs.reference_tokens;
+0${
+0$                      const json_pointer<RefStringTypeRhs>& rhs) noexcept
+0$inline bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
+0$template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$
+0$}
+0$    return !(lhs == rhs);
+0${
+0$                       const json_pointer<RefStringTypeRhs>& rhs)
+0$inline bool operator!=(const StringType& lhs,
+0$JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
+0$         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
+0$template<typename RefStringTypeRhs,
+0$
+0$}
+0$    return !(lhs == rhs);
+0${
+0$                       const StringType& rhs)
+0$inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
+0$JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
+0$         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
+0$template<typename RefStringTypeLhs,
+0$
+0$}
+0$    return !(lhs == rhs);
+0${
+0$                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
+0$inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
+0$template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$
+0$}
+0$    return json_pointer<RefStringTypeRhs>(lhs) == rhs;
+0${
+0$                       const json_pointer<RefStringTypeRhs>& rhs)
+0$inline bool operator==(const StringType& lhs,
+0$JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
+0$         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
+0$template<typename RefStringTypeRhs,
+0$
+0$}
+0$    return lhs == json_pointer<RefStringTypeLhs>(rhs);
+0${
+0$                       const StringType& rhs)
+0$inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
+0$JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
+0$         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
+0$template<typename RefStringTypeLhs,
+0$
+0$}
+0$    return lhs.reference_tokens == rhs.reference_tokens;
+0${
+0$                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
+0$inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
+0$template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$// functions cannot be defined inside class due to ODR violations
+0$#if !JSON_HAS_THREE_WAY_COMPARISON
+0$
+0$};
+0$    std::vector<string_t> reference_tokens;
+0$    /// the reference tokens
+0$  private:
+0$
+0$#endif
+0$                          const json_pointer<RefStringTypeRhs>& rhs) noexcept;
+0$    friend bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$    /// @brief compares two JSON pointer for less-than
+0$
+0$                           const json_pointer<RefStringTypeRhs>& rhs);
+0$    friend bool operator!=(const StringType& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeRhs, typename StringType>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
+0$    /// @brief compares string and JSON pointer for inequality
+0$
+0$                           const StringType& rhs);
+0$    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeLhs, typename StringType>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
+0$    /// @brief compares JSON pointer and string for inequality
+0$
+0$                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;
+0$    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
+0$    /// @brief compares two JSON pointers for inequality
+0$
+0$                           const json_pointer<RefStringTypeRhs>& rhs);
+0$    friend bool operator==(const StringType& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeRhs, typename StringType>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
+0$    /// @brief compares string and JSON pointer for equality
+0$
+0$                           const StringType& rhs);
+0$    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeLhs, typename StringType>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
+0$    /// @brief compares JSON pointer and string for equality
+0$
+0$                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;
+0$    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
+0$    // NOLINTNEXTLINE(readability-redundant-declaration)
+0$    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
+0$    /// @brief compares two JSON pointers for equality
+0$#else
+0$    }
+0$        return  reference_tokens <=> rhs.reference_tokens; // *NOPAD*
+0$    {
+0$    std::strong_ordering operator<=>(const json_pointer<RefStringTypeRhs>& rhs) const noexcept // *NOPAD*
+0$    template<typename RefStringTypeRhs>
+0$    /// @brief 3-way compares two JSON pointers
+0$
+0$    }
+0$        return *this == json_pointer(rhs);
+0$    {
+0$    bool operator==(const string_t& rhs) const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
+0$    /// @brief compares JSON pointer and string for equality
+0$
+0$    }
+0$        return reference_tokens == rhs.reference_tokens;
+0$    {
+0$    bool operator==(const json_pointer<RefStringTypeRhs>& rhs) const noexcept
+0$    template<typename RefStringTypeRhs>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
+0$    /// @brief compares two JSON pointers for equality
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$  public:
+0$
+0$    }
+0$        return result;
+0$        result.reference_tokens = std::move(reference_tokens);
+0$        json_pointer<string_t> result;
+0$    {
+0$    json_pointer<string_t> convert()&&
+0$
+0$    }
+0$        return result;
+0$        result.reference_tokens = reference_tokens;
+0$        json_pointer<string_t> result;
+0$    {
+0$    json_pointer<string_t> convert() const&
+0$    // can't use conversion operator because of ambiguity
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            json_pointer(element.first).get_and_create(result) = element.second;
+0$            // will then create a primitive value.
+0$            // get_and_create returns a reference to result itself. An assignment
+0$            // the JSON pointer is "" (i.e., points to the whole value), function
+0$            // assign value to reference pointed to by JSON pointer; Note that if
+0$
+0$            }
+0$                JSON_THROW(detail::type_error::create(315, "values in object must be primitive", &element.second));
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
+0$        {
+0$        for (const auto& element : *value.m_data.m_value.object)
+0$        // iterate the JSON object values
+0$
+0$        BasicJsonType result;
+0$
+0$        }
+0$            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", &value));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
+0$    {
+0$    unflatten(const BasicJsonType& value)
+0$    static BasicJsonType
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw type_error.313  if value cannot be unflattened
+0$    @throw type_error.315  if object values are not primitive
+0$    @throw type_error.314  if value is not an object
+0$    @throw parse_error.109 if array index is not a number
+0$
+0$    @return unflattened JSON
+0$
+0$    @param[in] value  flattened JSON
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                break;
+0$                result[reference_string] = value;
+0$                // add primitive value with its reference string
+0$            {
+0$            default:
+0$            case detail::value_t::discarded:
+0$            case detail::value_t::binary:
+0$            case detail::value_t::number_float:
+0$            case detail::value_t::number_unsigned:
+0$            case detail::value_t::number_integer:
+0$            case detail::value_t::boolean:
+0$            case detail::value_t::string:
+0$            case detail::value_t::null:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    }
+0$                        flatten(detail::concat(reference_string, '/', detail::escape(element.first)), element.second, result);
+0$                    {
+0$                    for (const auto& element : *value.m_data.m_value.object)
+0$                    // iterate object and use keys as reference string
+0$                {
+0$                else
+0$                }
+0$                    result[reference_string] = nullptr;
+0$                    // flatten empty object as null
+0$                {
+0$                if (value.m_data.m_value.object->empty())
+0$            {
+0$            case detail::value_t::object:
+0$
+0$            }
+0$                break;
+0$                }
+0$                    }
+0$                                value.m_data.m_value.array->operator[](i), result);
+0$                        flatten(detail::concat(reference_string, '/', std::to_string(i)),
+0$                    {
+0$                    for (std::size_t i = 0; i < value.m_data.m_value.array->size(); ++i)
+0$                    // iterate array and use index as reference string
+0$                {
+0$                else
+0$                }
+0$                    result[reference_string] = nullptr;
+0$                    // flatten empty array as null
+0$                {
+0$                if (value.m_data.m_value.array->empty())
+0$            {
+0$            case detail::value_t::array:
+0$        {
+0$        switch (value.type())
+0$    {
+0$                        BasicJsonType& result)
+0$                        const BasicJsonType& value,
+0$    static void flatten(const string_t& reference_string,
+0$    template<typename BasicJsonType>
+0$    */
+0$    @note Empty objects or arrays are flattened to `null`.
+0$
+0$    @param[in,out] result        the result object to insert values to
+0$    @param[in] value             the value to consider
+0$    @param[in] reference_string  the reference string to the current value
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            result.push_back(reference_token);
+0$            detail::unescape(reference_token);
+0$            // finally, store the reference token
+0$
+0$            }
+0$                }
+0$                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", nullptr));
+0$                {
+0$                                          reference_token[pos + 1] != '1')))
+0$                                         (reference_token[pos + 1] != '0' &&
+0$                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
+0$                // ~ must be followed by 0 or 1
+0$
+0$                JSON_ASSERT(reference_token[pos] == '~');
+0$            {
+0$                    pos = reference_token.find_first_of('~', pos + 1))
+0$                    pos != string_t::npos;
+0$            for (std::size_t pos = reference_token.find_first_of('~');
+0$            // check reference tokens are properly escaped
+0$
+0$            auto reference_token = reference_string.substr(start, slash - start);
+0$            // (start) and the last slash (slash).
+0$            // use the text between the beginning of the reference token
+0$        {
+0$            slash = reference_string.find_first_of('/', start))
+0$            // find next slash
+0$            start = (slash == string_t::npos) ? 0 : slash + 1,
+0$            // (will eventually be 0 if slash == string_t::npos)
+0$            // set the beginning of the next reference token
+0$            start != 0;
+0$            // we can stop if start == 0 (if slash == string_t::npos)
+0$            start = 1;
+0$            // set the beginning of the first reference token
+0$            std::size_t slash = reference_string.find_first_of('/', 1),
+0$            // search for the first slash after the first character
+0$        for (
+0$        // - start: position after the previous slash
+0$        // - slash: position of the last read slash (or end of string)
+0$        // extract the reference tokens:
+0$
+0$        }
+0$            JSON_THROW(detail::parse_error::create(107, 1, detail::concat("JSON pointer must be empty or begin with '/' - was: '", reference_string, "'"), nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
+0$        // check if nonempty reference string begins with slash
+0$
+0$        }
+0$            return result;
+0$        {
+0$        if (reference_string.empty())
+0$        // special case: empty reference string -> no reference tokens
+0$
+0$        std::vector<string_t> result;
+0$    {
+0$    static std::vector<string_t> split(const string_t& reference_string)
+0$    */
+0$    @throw parse_error.108  if character '~' is not followed by '0' or '1'
+0$    @throw parse_error.107  if the pointer is not empty or begins with '/'
+0$
+0$          All exceptions below are documented there.
+0$    @note This function is only called by the json_pointer constructor.
+0$
+0$    @brief split the string input to reference tokens
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$        // no reference token left means we found a primitive value
+0$
+0$        }
+0$            }
+0$                }
+0$                    return false;
+0$                    // reference token to process
+0$                    // we do not expect primitive values if there is still a
+0$                {
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                case detail::value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->operator[](idx);
+0$
+0$                    }
+0$                        return false;
+0$                        // index out of range
+0$                    {
+0$                    if (idx >= ptr->size())
+0$                    const auto idx = array_index<BasicJsonType>(reference_token);
+0$
+0$                    }
+0$                        }
+0$                            }
+0$                                return false;
+0$                                // other char should be between '0' and '9'
+0$                            {
+0$                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
+0$                        {
+0$                        for (std::size_t i = 1; i < reference_token.size(); i++)
+0$                        }
+0$                            return false;
+0$                            // first char should be between '1' and '9'
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
+0$                    }
+0$                        return false;
+0$                        // invalid char
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
+0$                    }
+0$                        return false;
+0$                        // "-" always fails the range check
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->operator[](reference_token);
+0$
+0$                    }
+0$                        return false;
+0$                        // we did not find the key in the object
+0$                    {
+0$                    if (!ptr->contains(reference_token))
+0$                {
+0$                case detail::value_t::object:
+0$            {
+0$            switch (ptr->type())
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$    {
+0$    bool contains(const BasicJsonType* ptr) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw parse_error.109   if an array index was not a number
+0$    @throw parse_error.106   if an array index begins with '0'
+0$    /*!
+0$
+0$    }
+0$        return *ptr;
+0$
+0$        }
+0$            }
+0$                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                case detail::value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
+0$                    // note: at performs range check
+0$
+0$                    }
+0$                                ") is out of range"), ptr));
+0$                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
+0$                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
+0$                        // "-" always fails the range check
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->at(reference_token);
+0$                    // note: at performs range check
+0$                {
+0$                case detail::value_t::object:
+0$            {
+0$            switch (ptr->type())
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$    {
+0$    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw out_of_range.404  if the JSON pointer can not be resolved
+0$    @throw out_of_range.402  if the array index '-' is used
+0$    @throw parse_error.109   if an array index was not a number
+0$    @throw parse_error.106   if an array index begins with '0'
+0$    /*!
+0$
+0$    }
+0$        return *ptr;
+0$
+0$        }
+0$            }
+0$                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                case detail::value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
+0$                    // use unchecked array access
+0$
+0$                    }
+0$                        JSON_THROW(detail::out_of_range::create(402, detail::concat("array index '-' (", std::to_string(ptr->m_data.m_value.array->size()), ") is out of range"), ptr));
+0$                        // "-" cannot be used for const access
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->operator[](reference_token);
+0$                    // use unchecked object access
+0$                {
+0$                case detail::value_t::object:
+0$            {
+0$            switch (ptr->type())
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$    {
+0$    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw out_of_range.404  if the JSON pointer can not be resolved
+0$    @throw out_of_range.402  if the array index '-' is used
+0$    @throw parse_error.109   if an array index was not a number
+0$    @throw parse_error.106   if an array index begins with '0'
+0$
+0$    pointer
+0$    @return const reference to the JSON value pointed to by the JSON
+0$
+0$    @param[in] ptr  a JSON value
+0$
+0$    @brief return a const reference to the pointed to value
+0$    /*!
+0$
+0$    }
+0$        return *ptr;
+0$
+0$        }
+0$            }
+0$                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                case detail::value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
+0$                    // note: at performs range check
+0$
+0$                    }
+0$                                ") is out of range"), ptr));
+0$                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
+0$                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
+0$                        // "-" always fails the range check
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->at(reference_token);
+0$                    // note: at performs range check
+0$                {
+0$                case detail::value_t::object:
+0$            {
+0$            switch (ptr->type())
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$    {
+0$    BasicJsonType& get_checked(BasicJsonType* ptr) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw out_of_range.404  if the JSON pointer can not be resolved
+0$    @throw out_of_range.402  if the array index '-' is used
+0$    @throw parse_error.109   if an array index was not a number
+0$    @throw parse_error.106   if an array index begins with '0'
+0$    /*!
+0$
+0$    }
+0$        return *ptr;
+0$
+0$        }
+0$            }
+0$                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                case detail::value_t::null:
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
+0$                        // convert array index to number; unchecked access
+0$                    {
+0$                    else
+0$                    }
+0$                        ptr = &ptr->operator[](ptr->m_data.m_value.array->size());
+0$                        // explicitly treat "-" as index beyond the end
+0$                    {
+0$                    if (reference_token == "-")
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    ptr = &ptr->operator[](reference_token);
+0$                    // use unchecked object access
+0$                {
+0$                case detail::value_t::object:
+0$            {
+0$            switch (ptr->type())
+0$
+0$            }
+0$                       : detail::value_t::object;
+0$                       ? detail::value_t::array
+0$                *ptr = (nums || reference_token == "-")
+0$                // change value to array for numbers or "-" or to object otherwise
+0$
+0$                });
+0$                    return std::isdigit(x);
+0$                {
+0$                                [](const unsigned char x)
+0$                    std::all_of(reference_token.begin(), reference_token.end(),
+0$                const bool nums =
+0$                // check if reference token is a number
+0$            {
+0$            if (ptr->is_null())
+0$            // convert null values to arrays or objects before continuing
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$    {
+0$    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw out_of_range.404  if the JSON pointer can not be resolved
+0$    @throw parse_error.109   if an array index was not a number
+0$    @throw parse_error.106   if an array index begins with '0'
+0$
+0$    @complexity Linear in the length of the JSON pointer.
+0$
+0$    @return reference to the JSON value pointed to by the JSON pointer
+0$
+0$    @param[in] ptr  a JSON value
+0$
+0$          changing the null value to an object.
+0$          `operator[]("this").operator[]("that")` on that value, effectively
+0$          with pointer `"/this/that"` on a null value is equivalent to calling
+0$          create nested values instead. For instance, calling this function
+0$    @note This version does not throw if a value is not present, but tries to
+0$
+0$    @brief return a reference to the pointed to value
+0$    /*!
+0$
+0$    }
+0$        return *result;
+0$
+0$        }
+0$            }
+0$                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", &j));
+0$                default:
+0$                case detail::value_t::discarded:
+0$                case detail::value_t::binary:
+0$                case detail::value_t::number_float:
+0$                case detail::value_t::number_unsigned:
+0$                case detail::value_t::number_integer:
+0$                case detail::value_t::boolean:
+0$                case detail::value_t::string:
+0$                */
+0$                single value; that is, with an empty list of reference tokens.
+0$                an error situation, because primitive values may only occur as
+0$                token _and_ the current value is primitive. In this case, we have
+0$                The following code is only reached if there exists a reference
+0$                /*
+0$
+0$                }
+0$                    break;
+0$                    result = &result->operator[](array_index<BasicJsonType>(reference_token));
+0$                    // create an entry in the array
+0$                {
+0$                case detail::value_t::array:
+0$
+0$                }
+0$                    break;
+0$                    result = &result->operator[](reference_token);
+0$                    // create an entry in the object
+0$                {
+0$                case detail::value_t::object:
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        result = &result->operator[](reference_token);
+0$                        // start a new object otherwise
+0$                    {
+0$                    else
+0$                    }
+0$                        result = &result->operator[](0);
+0$                        // start a new array if reference token is 0
+0$                    {
+0$                    if (reference_token == "0")
+0$                {
+0$                case detail::value_t::null:
+0$            {
+0$            switch (result->type())
+0$        {
+0$        for (const auto& reference_token : reference_tokens)
+0$        // j which will be overwritten by a primitive value
+0$        // in case no reference tokens exist, return a reference to the JSON value
+0$
+0$        auto* result = &j;
+0$    {
+0$    BasicJsonType& get_and_create(BasicJsonType& j) const
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw type_error.313 if value cannot be unflattened
+0$    @throw parse_error.109 if array index is not a number
+0$
+0$    @complexity Linear in the number of reference tokens.
+0$
+0$    @brief create and return a reference to the pointed to value
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return result;
+0$        result.reference_tokens = {reference_tokens[0]};
+0$        json_pointer result = *this;
+0$
+0$        }
+0$            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(empty()))
+0$    {
+0$    json_pointer top() const
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    }
+0$        return static_cast<size_type>(res);
+0$
+0$        }
+0$            JSON_THROW(detail::out_of_range::create(410, detail::concat("array index ", s, " exceeds size_type"), nullptr));   // LCOV_EXCL_LINE
+0$        {
+0$        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  // NOLINT(runtime/int)
+0$        // https://github.com/nlohmann/json/pull/2203
+0$        // only triggered on special platforms (like 32bit), see also
+0$
+0$        }
+0$            JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", s, "'"), nullptr));
+0$        {
+0$                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) // incomplete read
+0$                || errno == ERANGE // out of range
+0$        if (p == p_end // invalid input or empty string
+0$        const unsigned long long res = std::strtoull(p, &p_end, 10); // NOLINT(runtime/int)
+0$        errno = 0; // strtoull doesn't reset errno
+0$        char* p_end = nullptr;
+0$        const char* p = s.c_str();
+0$
+0$        }
+0$            JSON_THROW(detail::parse_error::create(109, 0, detail::concat("array index '", s, "' is not a number"), nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
+0$        // error condition (cf. RFC 6901, Sect. 4)
+0$
+0$        }
+0$            JSON_THROW(detail::parse_error::create(106, 0, detail::concat("array index '", s, "' must not begin with '0'"), nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
+0$        // error condition (cf. RFC 6901, Sect. 4)
+0$
+0$        using size_type = typename BasicJsonType::size_type;
+0$    {
+0$    static typename BasicJsonType::size_type array_index(const string_t& s)
+0$    template<typename BasicJsonType>
+0$    */
+0$    @throw out_of_range.410 if an array index exceeds size_type
+0$    @throw out_of_range.404 if string @a s could not be converted to an integer
+0$    @throw parse_error.109  if an array index begins not with a digit
+0$    @throw parse_error.106  if an array index begins with '0'
+0$
+0$    @return integer representation of @a s
+0$
+0$    @param[in] s  reference token to be converted into an array index
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return reference_tokens.empty();
+0$    {
+0$    bool empty() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/empty/
+0$    /// @brief return whether pointer points to the root document
+0$
+0$    }
+0$        reference_tokens.push_back(std::move(token));
+0$    {
+0$    void push_back(string_t&& token)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
+0$    /// @brief append an unescaped token at the end of the reference pointer
+0$
+0$    }
+0$        reference_tokens.push_back(token);
+0$    {
+0$    void push_back(const string_t& token)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
+0$    /// @brief append an unescaped token at the end of the reference pointer
+0$
+0$    }
+0$        return reference_tokens.back();
+0$
+0$        }
+0$            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(empty()))
+0$    {
+0$    const string_t& back() const
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/back/
+0$    /// @brief return last reference token
+0$
+0$    }
+0$        reference_tokens.pop_back();
+0$
+0$        }
+0$            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(empty()))
+0$    {
+0$    void pop_back()
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/pop_back/
+0$    /// @brief remove last reference token
+0$
+0$    }
+0$        return res;
+0$        res.pop_back();
+0$        json_pointer res = *this;
+0$
+0$        }
+0$            return *this;
+0$        {
+0$        if (empty())
+0$    {
+0$    json_pointer parent_pointer() const
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/parent_pointer/
+0$    /// @brief returns the parent of this JSON pointer
+0$
+0$    }
+0$        return json_pointer(lhs) /= array_idx;
+0$    {
+0$    friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
+0$    /// @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer
+0$
+0$    }
+0$        return json_pointer(lhs) /= std::move(token);
+0$    {
+0$    friend json_pointer operator/(const json_pointer& lhs, string_t token) // NOLINT(performance-unnecessary-value-param)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
+0$    /// @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer
+0$
+0$    }
+0$        return json_pointer(lhs) /= rhs;
+0$    {
+0$                                  const json_pointer& rhs)
+0$    friend json_pointer operator/(const json_pointer& lhs,
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
+0$    /// @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer
+0$
+0$    }
+0$        return *this /= std::to_string(array_idx);
+0$    {
+0$    json_pointer& operator/=(std::size_t array_idx)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
+0$    /// @brief append an array index at the end of this JSON pointer
+0$
+0$    }
+0$        return *this;
+0$        push_back(std::move(token));
+0$    {
+0$    json_pointer& operator/=(string_t token)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
+0$    /// @brief append an unescaped reference token at the end of this JSON pointer
+0$
+0$    }
+0$        return *this;
+0$                                ptr.reference_tokens.end());
+0$                                ptr.reference_tokens.begin(),
+0$        reference_tokens.insert(reference_tokens.end(),
+0$    {
+0$    json_pointer& operator/=(const json_pointer& ptr)
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
+0$    /// @brief append another JSON pointer at the end of this JSON pointer
+0$
+0$#endif
+0$    }
+0$        return o;
+0$        o << ptr.to_string();
+0$    {
+0$    friend std::ostream& operator<<(std::ostream& o, const json_pointer& ptr)
+0$    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
+0$    /// @brief write string representation of the JSON pointer to stream
+0$#ifndef JSON_NO_IO
+0$
+0$    }
+0$        return to_string();
+0$    {
+0$    operator string_t() const
+0$    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/operator_string/
+0$    /// @brief return a string representation of the JSON pointer
+0$
+0$    }
+0$        });
+0$            return detail::concat(a, '/', detail::escape(b));
+0$        {
+0$                               [](const string_t& a, const string_t& b)
+0$                               string_t{},
+0$        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
+0$    {
+0$    string_t to_string() const
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/to_string/
+0$    /// @brief return a string representation of the JSON pointer
+0$
+0$    {}
+0$        : reference_tokens(split(s))
+0$    explicit json_pointer(const string_t& s = "")
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/json_pointer/
+0$    /// @brief create JSON pointer
+0$
+0$    using string_t = typename string_t_helper<RefStringType>::type;
+0$    // for backwards compatibility accept BasicJsonType
+0$  public:
+0$
+0$    };
+0$        using type = StringType;
+0$    {
+0$    struct string_t_helper<NLOHMANN_BASIC_JSON_TPL>
+0$    NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$
+0$    };
+0$        using type = T;
+0$    {
+0$    struct string_t_helper
+0$    template<typename T>
+0$
+0$    friend class json_pointer;
+0$    template<typename>
+0$
+0$    friend class basic_json;
+0$    NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$    // allow basic_json to access private members
+0${
+0$class json_pointer
+0$template<typename RefStringType>
+0$/// @sa https://json.nlohmann.me/api/json_pointer/
+0$/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/string_escape.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // move
+0$#include <string> // string
+0$#include <numeric> // accumulate
+0$#include <limits> // max
+0$#endif  // JSON_NO_IO
+0$    #include <iosfwd> // ostream
+0$#ifndef JSON_NO_IO
+0$#include <cstdlib> // strtoull
+0$#include <cerrno> // errno, ERANGE
+0$#include <cctype> // isdigit
+0$#include <algorithm> // all_of
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/json_pointer.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$                        >::type;
+0$                        T
+0$                        json_default_base,
+0$                        std::is_same<T, void>::value,
+0$using json_base_class = typename std::conditional <
+0$template<class T>
+0$
+0$struct json_default_base {};
+0$*/
+0$on the behavior of @ref basic_json.
+0$By default, this class is used because it is empty and thus has no effect
+0$@ref basic_json always has a base class.
+0$(no base class / custom base class used as customization point),
+0$of @ref basic_json do not require complex case distinctions
+0$So that the correct implementations of the copy / move ctors / assign operators
+0$
+0$@brief Default base class of the @ref basic_json class.
+0$/*!
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <type_traits> // conditional, is_same
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/json_custom_base_class.hpp>
+0$
+0$// #include <nlohmann/detail/iterators/primitive_iterator.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    }
+0$        return it.operator * ();
+0$        auto it = --this->base();
+0$    {
+0$    reference value() const
+0$    /// return the value of an iterator
+0$
+0$    }
+0$        return it.key();
+0$        auto it = --this->base();
+0$    {
+0$    auto key() const -> decltype(std::declval<Base>().key())
+0$    /// return the key of an object iterator
+0$
+0$    }
+0$        return *(this->operator+(n));
+0$    {
+0$    reference operator[](difference_type n) const
+0$    /// access to successor
+0$
+0$    }
+0$        return base_iterator(*this) - base_iterator(other);
+0$    {
+0$    difference_type operator-(const json_reverse_iterator& other) const
+0$    /// return difference
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
+0$    {
+0$    json_reverse_iterator operator-(difference_type i) const
+0$    /// subtract from iterator
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
+0$    {
+0$    json_reverse_iterator operator+(difference_type i) const
+0$    /// add to iterator
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
+0$    {
+0$    json_reverse_iterator& operator+=(difference_type i)
+0$    /// add to iterator
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
+0$    {
+0$    json_reverse_iterator& operator--()
+0$    /// pre-decrement (--it)
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
+0$    {
+0$    json_reverse_iterator operator--(int)& // NOLINT(cert-dcl21-cpp)
+0$    /// post-decrement (it--)
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
+0$    {
+0$    json_reverse_iterator& operator++()
+0$    /// pre-increment (++it)
+0$
+0$    }
+0$        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
+0$    {
+0$    json_reverse_iterator operator++(int)& // NOLINT(cert-dcl21-cpp)
+0$    /// post-increment (it++)
+0$
+0$    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}
+0$    /// create reverse iterator from base class
+0$
+0$        : base_iterator(it) {}
+0$    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
+0$    /// create reverse iterator from iterator
+0$
+0$    using reference = typename Base::reference;
+0$    /// the reference type for the pointed-to element
+0$    using base_iterator = std::reverse_iterator<Base>;
+0$    /// shortcut to the reverse iterator adapter
+0$    using difference_type = std::ptrdiff_t;
+0$  public:
+0${
+0$class json_reverse_iterator : public std::reverse_iterator<Base>
+0$template<typename Base>
+0$*/
+0$@since version 1.0.0
+0$
+0$  @ref iterator).
+0$  It is possible to write to the pointed-to element (only if @a Base is
+0$- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
+0$  incremented and decremented).
+0$  The iterator that can be moved can be moved in both directions (i.e.
+0$[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
+0$-
+0$@requirement The class satisfies the following concept requirements:
+0$
+0$create @ref const_reverse_iterator).
+0$iterator (to create @ref reverse_iterator) and @ref const_iterator (to
+0$@tparam Base the base iterator type to reverse. Valid types are @ref
+0$
+0$@brief a template for a reverse iterator class
+0$/*!
+0$
+0$//////////////////////
+0$// reverse_iterator //
+0$//////////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <utility> // declval
+0$#include <iterator> // reverse_iterator
+0$#include <cstddef> // ptrdiff_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>
+0$
+0$// #include <nlohmann/detail/iterators/iteration_proxy.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
+0$    /// the actual iterator of the associated instance
+0$    pointer m_object = nullptr;
+0$    /// associated JSON instance
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    }
+0$        return operator*();
+0$    {
+0$    reference value() const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief return the value of an iterator
+0$    /*!
+0$
+0$    }
+0$        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", m_object));
+0$
+0$        }
+0$            return m_it.object_iterator->first;
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    const typename object_t::key_type& key() const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief return the key of an object iterator
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
+0$
+0$                }
+0$                    return *m_object;
+0$                {
+0$                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$
+0$                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
+0$            case value_t::null:
+0$
+0$                return *std::next(m_it.array_iterator, n);
+0$            case value_t::array:
+0$
+0$                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", m_object));
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    reference operator[](difference_type n) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief access to successor
+0$    /*!
+0$
+0$    }
+0$        }
+0$                return m_it.primitive_iterator - other.m_it.primitive_iterator;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$                return m_it.array_iterator - other.m_it.array_iterator;
+0$            case value_t::array:
+0$
+0$                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    difference_type operator-(const iter_impl& other) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief return difference
+0$    /*!
+0$
+0$    }
+0$        return result;
+0$        result -= i;
+0$        auto result = *this;
+0$    {
+0$    iter_impl operator-(difference_type i) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief subtract from iterator
+0$    /*!
+0$
+0$    }
+0$        return result;
+0$        result += i;
+0$        auto result = it;
+0$    {
+0$    friend iter_impl operator+(difference_type i, const iter_impl& it)
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief addition of distance and iterator
+0$    /*!
+0$
+0$    }
+0$        return result;
+0$        result += i;
+0$        auto result = *this;
+0$    {
+0$    iter_impl operator+(difference_type i) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief add to iterator
+0$    /*!
+0$
+0$    }
+0$        return operator+=(-i);
+0$    {
+0$    iter_impl& operator-=(difference_type i)
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief subtract from iterator
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$
+0$        }
+0$            }
+0$                break;
+0$                m_it.primitive_iterator += i;
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                std::advance(m_it.array_iterator, i);
+0$            {
+0$            case value_t::array:
+0$
+0$                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    iter_impl& operator+=(difference_type i)
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief add to iterator
+0$    /*!
+0$
+0$    }
+0$        return !operator<(other);
+0$    {
+0$    bool operator>=(const iter_impl& other) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: greater than or equal
+0$    /*!
+0$
+0$    }
+0$        return !operator<=(other);
+0$    {
+0$    bool operator>(const iter_impl& other) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: greater than
+0$    /*!
+0$
+0$    }
+0$        return !other.operator < (*this);
+0$    {
+0$    bool operator<=(const iter_impl& other) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: less than or equal
+0$    /*!
+0$
+0$    }
+0$        }
+0$                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$                return (m_it.array_iterator < other.m_it.array_iterator);
+0$            case value_t::array:
+0$
+0$                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", m_object));
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
+0$        // if objects are not the same, the comparison is undefined
+0$    {
+0$    bool operator<(const iter_impl& other) const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: smaller
+0$    /*!
+0$
+0$    }
+0$        return !operator==(other);
+0$    {
+0$    bool operator!=(const IterImpl& other) const
+0$    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: not equal
+0$    /*!
+0$
+0$    }
+0$        }
+0$                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$                return (m_it.array_iterator == other.m_it.array_iterator);
+0$            case value_t::array:
+0$
+0$                return (m_it.object_iterator == other.m_it.object_iterator);
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$
+0$        }
+0$            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
+0$        // if objects are not the same, the comparison is undefined
+0$    {
+0$    bool operator==(const IterImpl& other) const
+0$    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief comparison: equal
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$
+0$        }
+0$            }
+0$                break;
+0$                --m_it.primitive_iterator;
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                std::advance(m_it.array_iterator, -1);
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                std::advance(m_it.object_iterator, -1);
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    iter_impl& operator--()
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief pre-decrement (--it)
+0$    /*!
+0$
+0$    }
+0$        return result;
+0$        --(*this);
+0$        auto result = *this;
+0$    {
+0$    iter_impl operator--(int)& // NOLINT(cert-dcl21-cpp)
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief post-decrement (it--)
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$
+0$        }
+0$            }
+0$                break;
+0$                ++m_it.primitive_iterator;
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                std::advance(m_it.array_iterator, 1);
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                std::advance(m_it.object_iterator, 1);
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    iter_impl& operator++()
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief pre-increment (++it)
+0$    /*!
+0$
+0$    }
+0$        return result;
+0$        ++(*this);
+0$        auto result = *this;
+0$    {
+0$    iter_impl operator++(int)& // NOLINT(cert-dcl21-cpp)
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief post-increment (it++)
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
+0$
+0$                }
+0$                    return m_object;
+0$                {
+0$                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                return &*m_it.array_iterator;
+0$                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                return &(m_it.object_iterator->second);
+0$                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    pointer operator->() const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief dereference the iterator
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
+0$
+0$                }
+0$                    return *m_object;
+0$                {
+0$                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$
+0$                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
+0$            case value_t::null:
+0$
+0$            }
+0$                return *m_it.array_iterator;
+0$                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                return m_it.object_iterator->second;
+0$                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    reference operator*() const
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief return a reference to the value pointed to by the iterator
+0$    /*!
+0$  public:
+0$
+0$    }
+0$        }
+0$            }
+0$                break;
+0$                m_it.primitive_iterator.set_end();
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_it.array_iterator = m_object->m_data.m_value.array->end();
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                m_it.object_iterator = m_object->m_data.m_value.object->end();
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    void set_end() noexcept
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief set the iterator past the last value
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                break;
+0$                m_it.primitive_iterator.set_begin();
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$
+0$            }
+0$                break;
+0$                m_it.primitive_iterator.set_end();
+0$                // set to end so begin()==end() is true: null is empty
+0$            {
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_it.array_iterator = m_object->m_data.m_value.array->begin();
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                m_it.object_iterator = m_object->m_data.m_value.object->begin();
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    void set_begin() noexcept
+0$    */
+0$    @pre The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @brief set the iterator to the first value
+0$    /*!
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    }
+0$        return *this;
+0$        m_it = other.m_it;
+0$        m_object = other.m_object;
+0$    {
+0$    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept // NOLINT(cert-oop54-cpp)
+0$    */
+0$    @note It is not checked whether @a other is initialized.
+0$    @return const/non-const iterator
+0$    @param[in] other  non-const iterator to copy from
+0$    @brief converting assignment
+0$    /*!
+0$
+0$    {}
+0$        : m_object(other.m_object), m_it(other.m_it)
+0$    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
+0$    */
+0$    @note It is not checked whether @a other is initialized.
+0$    @param[in] other  non-const iterator to copy from
+0$    @brief converting constructor
+0$    /*!
+0$
+0$    }
+0$        return *this;
+0$        }
+0$            m_it = other.m_it;
+0$            m_object = other.m_object;
+0$        {
+0$        if (&other != this)
+0$    {
+0$    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
+0$    */
+0$    @note It is not checked whether @a other is initialized.
+0$    @return const/non-const iterator
+0$    @param[in] other const iterator to copy from
+0$    @brief converting assignment
+0$    /*!
+0$
+0$    {}
+0$        : m_object(other.m_object), m_it(other.m_it)
+0$    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
+0$    */
+0$          information refer to: https://github.com/nlohmann/json/issues/1608
+0$          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
+0$    @note This copy constructor had to be defined explicitly to circumvent a bug
+0$    @param[in] other const iterator to copy from
+0$    @brief const copy constructor
+0$    /*!
+0$
+0$    */
+0$          to iterator is not defined.
+0$          iterator to const iterator. However conversion from const iterator
+0$          copy from const iterator to const iterator, and (3) conversion from
+0$          assignment, they support: (1) copy from iterator to iterator, (2)
+0$          defined. Combined with the following converting constructor and
+0$    @note The conventional copy constructor and copy assignment are implicitly
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                break;
+0$                m_it.primitive_iterator = primitive_iterator_t();
+0$            {
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$
+0$            }
+0$                break;
+0$                m_it.array_iterator = typename array_t::iterator();
+0$            {
+0$            case value_t::array:
+0$
+0$            }
+0$                break;
+0$                m_it.object_iterator = typename object_t::iterator();
+0$            {
+0$            case value_t::object:
+0$        {
+0$        switch (m_object->m_data.m_type)
+0$
+0$        JSON_ASSERT(m_object != nullptr);
+0$    {
+0$    explicit iter_impl(pointer object) noexcept : m_object(object)
+0$    */
+0$    @post The iterator is initialized; i.e. `m_object != nullptr`.
+0$    @pre object != nullptr
+0$    @param[in] object  pointer to a JSON object for this iterator
+0$    @brief constructor for a given JSON instance
+0$    /*!
+0$
+0$    iter_impl& operator=(iter_impl&&) noexcept = default;
+0$    iter_impl(iter_impl&&) noexcept = default;
+0$    ~iter_impl() = default;
+0$    iter_impl() = default;
+0$
+0$        typename BasicJsonType::reference>::type;
+0$        typename BasicJsonType::const_reference,
+0$        typename std::conditional<std::is_const<BasicJsonType>::value,
+0$    using reference =
+0$    /// defines a reference to the type iterated over (value_type)
+0$          typename BasicJsonType::pointer>::type;
+0$          typename BasicJsonType::const_pointer,
+0$    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
+0$    /// defines a pointer to the type iterated over (value_type)
+0$    using difference_type = typename BasicJsonType::difference_type;
+0$    /// a type to represent differences between iterators
+0$    using value_type = typename BasicJsonType::value_type;
+0$    /// the type of the values when the iterator is dereferenced
+0$
+0$    using iterator_category = std::bidirectional_iterator_tag;
+0$    /// Note that value_type is required to be non-const, even for constant iterators.
+0$    /// iterator_category, value_type, difference_type, pointer, and reference.
+0$    /// A user-defined iterator should provide publicly accessible typedefs named
+0$    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
+0$    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
+0$  public:
+0$
+0$                  "basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.");
+0$                  &&  std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<typename array_t::iterator>::iterator_category>::value,
+0$    static_assert(std::is_base_of<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>::value
+0$    // superficial check for the LegacyBidirectionalIterator named requirement
+0$                  "iter_impl only accepts (const) basic_json");
+0$    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
+0$    // make sure BasicJsonType is basic_json or const basic_json
+0$    using array_t = typename BasicJsonType::array_t;
+0$    using object_t = typename BasicJsonType::object_t;
+0$
+0$    friend iteration_proxy_value<iter_impl>;
+0$    friend iteration_proxy<iter_impl>;
+0$    friend BasicJsonType;
+0$    friend other_iter_impl;
+0$    /// allow basic_json to access private members
+0$    using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
+0$    /// the iterator with BasicJsonType of different const-ness
+0${
+0$class iter_impl // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
+0$template<typename BasicJsonType>
+0$*/
+0$       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
+0$@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
+0$  incremented and decremented).
+0$  The iterator that can be moved can be moved in both directions (i.e.
+0$[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
+0$-
+0$@requirement The class satisfies the following concept requirements:
+0$      **The library uses assertions to detect calls on uninitialized iterators.**
+0$      default-constructed, it is *uninitialized* and most methods are undefined.
+0$      been set (e.g., by a constructor or a copy assignment). If the iterator is
+0$@note An iterator is called *initialized* when a pointer to a JSON value has
+0$@ref basic_json class.
+0$This class implements a both iterators (iterator and const_iterator) for the
+0$@brief a template for a bidirectional iterator for the @ref basic_json class
+0$/*!
+0$
+0$template<typename IteratorType> class iteration_proxy_value;
+0$template<typename IteratorType> class iteration_proxy;
+0$// forward declare, to be able to friend it later on
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/iterators/primitive_iterator.hpp>
+0$
+0$// #include <nlohmann/detail/iterators/internal_iterator.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <type_traits> // conditional, is_const, remove_const
+0$#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/iter_impl.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    primitive_iterator_t primitive_iterator {};
+0$    /// generic iterator for all other types
+0$    typename BasicJsonType::array_t::iterator array_iterator {};
+0$    /// iterator for JSON arrays
+0$    typename BasicJsonType::object_t::iterator object_iterator {};
+0$    /// iterator for JSON objects
+0${
+0$template<typename BasicJsonType> struct internal_iterator
+0$*/
+0$unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
+0$@note This structure could easily be a union, but MSVC currently does not allow
+0$
+0$@brief an iterator value
+0$/*!
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    }
+0$        return *this;
+0$        m_it -= n;
+0$    {
+0$    primitive_iterator_t& operator-=(difference_type n) noexcept
+0$
+0$    }
+0$        return *this;
+0$        m_it += n;
+0$    {
+0$    primitive_iterator_t& operator+=(difference_type n) noexcept
+0$
+0$    }
+0$        return result;
+0$        --m_it;
+0$        auto result = *this;
+0$    {
+0$    primitive_iterator_t operator--(int)& noexcept // NOLINT(cert-dcl21-cpp)
+0$
+0$    }
+0$        return *this;
+0$        --m_it;
+0$    {
+0$    primitive_iterator_t& operator--() noexcept
+0$
+0$    }
+0$        return result;
+0$        ++m_it;
+0$        auto result = *this;
+0$    {
+0$    primitive_iterator_t operator++(int)& noexcept // NOLINT(cert-dcl21-cpp)
+0$
+0$    }
+0$        return *this;
+0$        ++m_it;
+0$    {
+0$    primitive_iterator_t& operator++() noexcept
+0$
+0$    }
+0$        return lhs.m_it - rhs.m_it;
+0$    {
+0$    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
+0$
+0$    }
+0$        return result;
+0$        result += n;
+0$        auto result = *this;
+0$    {
+0$    primitive_iterator_t operator+(difference_type n) noexcept
+0$
+0$    }
+0$        return lhs.m_it < rhs.m_it;
+0$    {
+0$    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
+0$
+0$    }
+0$        return lhs.m_it == rhs.m_it;
+0$    {
+0$    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
+0$
+0$    }
+0$        return m_it == end_value;
+0$    {
+0$    constexpr bool is_end() const noexcept
+0$    /// return whether the iterator is at end
+0$
+0$    }
+0$        return m_it == begin_value;
+0$    {
+0$    constexpr bool is_begin() const noexcept
+0$    /// return whether the iterator can be dereferenced
+0$
+0$    }
+0$        m_it = end_value;
+0$    {
+0$    void set_end() noexcept
+0$    /// set iterator to a defined past the end
+0$
+0$    }
+0$        m_it = begin_value;
+0$    {
+0$    void set_begin() noexcept
+0$    /// set iterator to a defined beginning
+0$
+0$    }
+0$        return m_it;
+0$    {
+0$    constexpr difference_type get_value() const noexcept
+0$  public:
+0$
+0$    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();
+0$    /// iterator as signed integer type
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    static constexpr difference_type end_value = begin_value + 1;
+0$    static constexpr difference_type begin_value = 0;
+0$    using difference_type = std::ptrdiff_t;
+0$  private:
+0${
+0$class primitive_iterator_t
+0$*/
+0$end_value (`1`) models past the end.
+0$a `difference_type` variable. Value begin_value (`0`) models the begin,
+0$to "iterate" over primitive values. Internally, the iterator is modeled by
+0$string). It's only purpose is to allow the iterator/const_iterator classes
+0$This class models an iterator for primitive JSON types (boolean, number,
+0$
+0$@brief an iterator for primitive JSON types
+0$/*
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#include <limits>  // numeric_limits
+0$#include <cstddef> // ptrdiff_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/primitive_iterator.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/internal_iterator.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    const bool allow_exceptions = true;
+0$    /// whether to throw exceptions in case of errors
+0$    lexer_t m_lexer;
+0$    /// the lexer
+0$    token_type last_token = token_type::uninitialized;
+0$    /// the type of the last read token
+0$    const parser_callback_t<BasicJsonType> callback = nullptr;
+0$    /// callback function
+0$  private:
+0$
+0$    }
+0$        return error_msg;
+0$
+0$        }
+0$            error_msg += concat("; expected ", lexer_t::token_type_name(expected));
+0$        {
+0$        if (expected != token_type::uninitialized)
+0$
+0$        }
+0$            error_msg += concat("unexpected ", lexer_t::token_type_name(last_token));
+0$        {
+0$        else
+0$        }
+0$                                m_lexer.get_token_string(), '\'');
+0$            error_msg += concat(m_lexer.get_error_message(), "; last read: '",
+0$        {
+0$        if (last_token == token_type::parse_error)
+0$
+0$        error_msg += "- ";
+0$
+0$        }
+0$            error_msg += concat("while parsing ", context, ' ');
+0$        {
+0$        if (!context.empty())
+0$
+0$        std::string error_msg = "syntax error ";
+0$    {
+0$    std::string exception_message(const token_type expected, const std::string& context)
+0$
+0$    }
+0$        return last_token = m_lexer.scan();
+0$    {
+0$    token_type get_token()
+0$    /// get next token from lexer
+0$
+0$    }
+0$        }
+0$                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
+0$                                    m_lexer.get_token_string(),
+0$            return sax->parse_error(m_lexer.get_position(),
+0$
+0$            }
+0$                continue;
+0$                skip_to_state_evaluation = true;
+0$                states.pop_back();
+0$                JSON_ASSERT(!states.empty());
+0$                // are effectively jumping to the beginning of this if.
+0$                // By setting skip_to_state_evaluation to false, we
+0$                // new value, we need to evaluate the new state first.
+0$                // We are done with this object. Before we can parse a
+0$
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
+0$            {
+0$            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
+0$            // closing }
+0$
+0$            }
+0$                continue;
+0$                get_token();
+0$                // parse values
+0$
+0$                }
+0$                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
+0$                                            m_lexer.get_token_string(),
+0$                    return sax->parse_error(m_lexer.get_position(),
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
+0$                // parse separator (:)
+0$
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
+0$
+0$                }
+0$                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
+0$                                            m_lexer.get_token_string(),
+0$                    return sax->parse_error(m_lexer.get_position(),
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
+0$                // parse key
+0$            {
+0$            if (get_token() == token_type::value_separator)
+0$            // comma -> next value
+0$
+0$            // states.back() is false -> object
+0$
+0$            }
+0$                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
+0$                                        m_lexer.get_token_string(),
+0$                return sax->parse_error(m_lexer.get_position(),
+0$
+0$                }
+0$                    continue;
+0$                    skip_to_state_evaluation = true;
+0$                    states.pop_back();
+0$                    JSON_ASSERT(!states.empty());
+0$                    // are effectively jumping to the beginning of this if.
+0$                    // By setting skip_to_state_evaluation to false, we
+0$                    // new value, we need to evaluate the new state first.
+0$                    // We are done with this array. Before we can parse a
+0$
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
+0$                {
+0$                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
+0$                // closing ]
+0$
+0$                }
+0$                    continue;
+0$                    get_token();
+0$                    // parse a new value
+0$                {
+0$                if (get_token() == token_type::value_separator)
+0$                // comma -> next value
+0$            {
+0$            if (states.back())  // array
+0$
+0$            }
+0$                return true;
+0$                // empty stack: we reached the end of the hierarchy: done
+0$            {
+0$            if (states.empty())
+0$            // we reached this line after we successfully parsed a value
+0$
+0$            }
+0$                skip_to_state_evaluation = false;
+0$            {
+0$            else
+0$            }
+0$                }
+0$                    }
+0$                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
+0$                                                m_lexer.get_token_string(),
+0$                        return sax->parse_error(m_lexer.get_position(),
+0$                    {
+0$                    default: // the last token was unexpected
+0$                    case token_type::literal_or_value:
+0$                    case token_type::value_separator:
+0$                    case token_type::name_separator:
+0$                    case token_type::end_object:
+0$                    case token_type::end_array:
+0$                    case token_type::uninitialized:
+0$                    }
+0$                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
+0$                                                m_lexer.get_token_string(),
+0$                        return sax->parse_error(m_lexer.get_position(),
+0$
+0$                        }
+0$                                                            "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
+0$                                                    parse_error::create(101, m_lexer.get_position(),
+0$                                                    m_lexer.get_token_string(),
+0$                            return sax->parse_error(m_lexer.get_position(),
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(m_lexer.get_position().chars_read_total == 1))
+0$                    {
+0$                    case token_type::end_of_input:
+0$                    }
+0$                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
+0$                                                m_lexer.get_token_string(),
+0$                        return sax->parse_error(m_lexer.get_position(),
+0$                        // using "uninitialized" to avoid "expected" message
+0$                    {
+0$                    case token_type::parse_error:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
+0$                    {
+0$                    case token_type::value_unsigned:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
+0$                    {
+0$                    case token_type::value_string:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
+0$                    {
+0$                    case token_type::value_integer:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
+0$                    {
+0$                    case token_type::literal_true:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
+0$                    {
+0$                    case token_type::literal_null:
+0$
+0$                    }
+0$                        break;
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
+0$                    {
+0$                    case token_type::literal_false:
+0$
+0$                    }
+0$                        break;
+0$
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
+0$
+0$                        }
+0$                                                    out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
+0$                                                    m_lexer.get_token_string(),
+0$                            return sax->parse_error(m_lexer.get_position(),
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
+0$
+0$                        const auto res = m_lexer.get_number_float();
+0$                    {
+0$                    case token_type::value_float:
+0$
+0$                    }
+0$                        continue;
+0$                        // parse values (no need to call get_token)
+0$
+0$                        states.push_back(true);
+0$                        // remember we are now inside an array
+0$
+0$                        }
+0$                            break;
+0$                            }
+0$                                return false;
+0$                            {
+0$                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
+0$                        {
+0$                        if (get_token() == token_type::end_array)
+0$                        // closing ] -> we are done
+0$
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
+0$                    {
+0$                    case token_type::begin_array:
+0$
+0$                    }
+0$                        continue;
+0$                        get_token();
+0$                        // parse values
+0$
+0$                        states.push_back(false);
+0$                        // remember we are now inside an object
+0$
+0$                        }
+0$                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
+0$                                                    m_lexer.get_token_string(),
+0$                            return sax->parse_error(m_lexer.get_position(),
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
+0$                        // parse separator (:)
+0$
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
+0$                        }
+0$                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
+0$                                                    m_lexer.get_token_string(),
+0$                            return sax->parse_error(m_lexer.get_position(),
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
+0$                        // parse key
+0$
+0$                        }
+0$                            break;
+0$                            }
+0$                                return false;
+0$                            {
+0$                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
+0$                        {
+0$                        if (get_token() == token_type::end_object)
+0$                        // closing } -> we are done
+0$
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
+0$                    {
+0$                    case token_type::begin_object:
+0$                {
+0$                switch (last_token)
+0$                // invariant: get_token() was called before each iteration
+0$            {
+0$            if (!skip_to_state_evaluation)
+0$        {
+0$        while (true)
+0$
+0$        bool skip_to_state_evaluation = false;
+0$        // value to avoid a goto (see comment where set to true)
+0$        std::vector<bool> states;
+0$        // true = array; false = object
+0$        // stack to remember the hierarchy of structured values we are parsing
+0$    {
+0$    bool sax_parse_internal(SAX* sax)
+0$    JSON_HEDLEY_NON_NULL(2)
+0$    template<typename SAX>
+0$  private:
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
+0$                                    m_lexer.get_token_string(),
+0$            return sax->parse_error(m_lexer.get_position(),
+0$        {
+0$        if (result && strict && (get_token() != token_type::end_of_input))
+0$        // strict mode: next byte must be EOF
+0$
+0$        const bool result = sax_parse_internal(sax);
+0$        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
+0$    {
+0$    bool sax_parse(SAX* sax, const bool strict = true)
+0$    JSON_HEDLEY_NON_NULL(2)
+0$    template<typename SAX>
+0$
+0$    }
+0$        return sax_parse(&sax_acceptor, strict);
+0$        json_sax_acceptor<BasicJsonType> sax_acceptor;
+0$    {
+0$    bool accept(const bool strict = true)
+0$    */
+0$    @return whether the input is a proper JSON text
+0$    @param[in] strict  whether to expect the last token to be EOF
+0$
+0$    @brief public accept interface
+0$    /*!
+0$
+0$    }
+0$        result.assert_invariant();
+0$
+0$        }
+0$            }
+0$                return;
+0$                result = value_t::discarded;
+0$            {
+0$            if (sdp.is_errored())
+0$            // in case of an error, return discarded value
+0$
+0$            }
+0$                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
+0$                                m_lexer.get_token_string(),
+0$                sdp.parse_error(m_lexer.get_position(),
+0$            {
+0$            if (strict && (get_token() != token_type::end_of_input))
+0$            // in strict mode, input must be completely read
+0$
+0$            sax_parse_internal(&sdp);
+0$            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
+0$        {
+0$        else
+0$        }
+0$            }
+0$                result = nullptr;
+0$            {
+0$            if (result.is_discarded())
+0$            // function
+0$            // set top-level value to null if it was discarded by the callback
+0$
+0$            }
+0$                return;
+0$                result = value_t::discarded;
+0$            {
+0$            if (sdp.is_errored())
+0$            // in case of an error, return discarded value
+0$
+0$            }
+0$                                                    exception_message(token_type::end_of_input, "value"), nullptr));
+0$                                parse_error::create(101, m_lexer.get_position(),
+0$                                m_lexer.get_token_string(),
+0$                sdp.parse_error(m_lexer.get_position(),
+0$            {
+0$            if (strict && (get_token() != token_type::end_of_input))
+0$            // in strict mode, input must be completely read
+0$
+0$            sax_parse_internal(&sdp);
+0$            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
+0$        {
+0$        if (callback)
+0$    {
+0$    void parse(const bool strict, BasicJsonType& result)
+0$    */
+0$    @throw parse_error.103 if to_unicode fails
+0$    @throw parse_error.102 if to_unicode fails or surrogate error
+0$    @throw parse_error.101 in case of an unexpected token
+0$
+0$    @param[in,out] result  parsed JSON value
+0$    @param[in] strict      whether to expect the last token to be EOF
+0$
+0$    @brief public parser interface
+0$    /*!
+0$
+0$    }
+0$        get_token();
+0$        // read first token
+0$    {
+0$        , allow_exceptions(allow_exceptions_)
+0$        , m_lexer(std::move(adapter), skip_comments)
+0$        : callback(cb)
+0$                    const bool skip_comments = false)
+0$                    const bool allow_exceptions_ = true,
+0$                    const parser_callback_t<BasicJsonType> cb = nullptr,
+0$    explicit parser(InputAdapterType&& adapter,
+0$    /// a parser reading from an input adapter
+0$  public:
+0$
+0$    using token_type = typename lexer_t::token_type;
+0$    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0${
+0$class parser
+0$template<typename BasicJsonType, typename InputAdapterType>
+0$*/
+0$This class implements a recursive descent parser.
+0$
+0$@brief syntax analysis
+0$/*!
+0$
+0$    std::function<bool(int /*depth*/, parse_event_t /*event*/, BasicJsonType& /*parsed*/)>;
+0$using parser_callback_t =
+0$template<typename BasicJsonType>
+0$
+0$};
+0$    value
+0$    /// the parser finished reading a JSON value
+0$    key,
+0$    /// the parser read a key of a value in an object
+0$    array_end,
+0$    /// the parser read `]` and finished processing a JSON array
+0$    array_start,
+0$    /// the parser read `[` and started to process a JSON array
+0$    object_end,
+0$    /// the parser read `}` and finished processing a JSON object
+0$    object_start,
+0$    /// the parser read `{` and started to process a JSON object
+0${
+0$enum class parse_event_t : std::uint8_t
+0$
+0$////////////
+0$// parser //
+0$////////////
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/meta/is_sax.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/input/lexer.hpp>
+0$
+0$// #include <nlohmann/detail/input/json_sax.hpp>
+0$
+0$// #include <nlohmann/detail/input/input_adapters.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // move
+0$#include <string> // string
+0$#include <functional> // function
+0$#include <cstdint> // uint8_t
+0$#include <cmath> // isfinite
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/parser.hpp>
+0$
+0$// #include <nlohmann/detail/input/lexer.hpp>
+0$
+0$// #include <nlohmann/detail/input/input_adapters.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$#endif
+0$    constexpr std::size_t binary_reader<BasicJsonType, InputAdapterType, SAX>::npos;
+0$    template<typename BasicJsonType, typename InputAdapterType, typename SAX>
+0$#ifndef JSON_HAS_CPP_17
+0$
+0$};
+0$#undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
+0$#undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
+0$
+0$        JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;
+0$    const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
+0$    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
+0$    using bjd_type = std::pair<char_int_type, string_t>;
+0$
+0$        JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;
+0$    const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
+0$    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
+0$    // lookup tables
+0$  JSON_PRIVATE_UNLESS_TESTED:
+0$
+0$    bjd_type{'u', "uint16"})
+0$    bjd_type{'m', "uint32"},                   \
+0$    bjd_type{'l', "int32"},                    \
+0$    bjd_type{'i', "int8"},                     \
+0$    bjd_type{'d', "single"},                   \
+0$    bjd_type{'U', "uint8"},                    \
+0$    bjd_type{'M', "uint64"},                   \
+0$    bjd_type{'L', "int64"},                    \
+0$    bjd_type{'I', "int16"},                    \
+0$    bjd_type{'D', "double"},                   \
+0$    bjd_type{'C', "char"},                     \
+0$    make_array<bjd_type>(                      \
+0$#define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
+0$
+0$    make_array<char_int_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '{')
+0$#define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
+0$    // excluded markers in bjdata optimized type
+0$
+0$    json_sax_t* sax = nullptr;
+0$    /// the SAX parser
+0$
+0$    const input_format_t input_format = input_format_t::json;
+0$    /// input format
+0$
+0$    const bool is_little_endian = little_endianness();
+0$    /// whether we can assume little endianness
+0$
+0$    std::size_t chars_read = 0;
+0$    /// the number of characters read
+0$
+0$    char_int_type current = char_traits<char_type>::eof();
+0$    /// the current character
+0$
+0$    InputAdapterType ia;
+0$    /// input adapter
+0$
+0$    static JSON_INLINE_VARIABLE constexpr std::size_t npos = static_cast<std::size_t>(-1);
+0$  private:
+0$
+0$    }
+0$        return concat(error_msg, ' ', context, ": ", detail);
+0$
+0$        }
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$            default:            // LCOV_EXCL_LINE
+0$            case input_format_t::json: // LCOV_EXCL_LINE
+0$
+0$                break;
+0$                error_msg += "BJData";
+0$            case input_format_t::bjdata:
+0$
+0$                break;
+0$                error_msg += "BSON";
+0$            case input_format_t::bson:
+0$
+0$                break;
+0$                error_msg += "UBJSON";
+0$            case input_format_t::ubjson:
+0$
+0$                break;
+0$                error_msg += "MessagePack";
+0$            case input_format_t::msgpack:
+0$
+0$                break;
+0$                error_msg += "CBOR";
+0$            case input_format_t::cbor:
+0$        {
+0$        switch (format)
+0$
+0$        std::string error_msg = "syntax error while parsing ";
+0$    {
+0$                                  const std::string& context) const
+0$                                  const std::string& detail,
+0$    std::string exception_message(const input_format_t format,
+0$    */
+0$    @return a message string to use in the parse_error exceptions
+0$    @param[in] context  further context information
+0$    @param[in] detail   a detailed error message
+0$    @param[in] format   the current format
+0$    /*!
+0$
+0$    }
+0$        return std::string{cr.data()};
+0$        static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$        std::array<char, 3> cr{{}};
+0$    {
+0$    std::string get_token_string() const
+0$    */
+0$    @return a string representation of the last read byte
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$        }
+0$                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
+0$            return sax->parse_error(chars_read, "<end of file>",
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(current == char_traits<char_type>::eof()))
+0$    {
+0$    bool unexpect_eof(const input_format_t format, const char* context) const
+0$    JSON_HEDLEY_NON_NULL(3)
+0$    */
+0$    @return whether the last read character is not EOF
+0$    @param[in] context  further context information (for diagnostics)
+0$    @param[in] format   the current format (for diagnostics)
+0$    /*!
+0$
+0$    }
+0$        return success;
+0$        }
+0$            result.push_back(static_cast<std::uint8_t>(current));
+0$            }
+0$                break;
+0$                success = false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
+0$            get();
+0$        {
+0$        for (NumberType i = 0; i < len; i++)
+0$        bool success = true;
+0$    {
+0$                    binary_t& result)
+0$                    const NumberType len,
+0$    bool get_binary(const input_format_t format,
+0$    template<typename NumberType>
+0$    */
+0$          the input before we run out of memory.
+0$          may be too large. Usually, @ref unexpect_eof() detects the end of
+0$    @note We can not reserve @a len bytes for the result, because @a len
+0$
+0$    @return whether byte array creation completed
+0$
+0$    @param[out] result byte array created by reading @a len bytes
+0$    @param[in] len number of bytes to read
+0$    @param[in] format the current format (for diagnostics)
+0$    @tparam NumberType the type of the number
+0$
+0$    @brief create a byte array by reading bytes from the input
+0$    /*!
+0$
+0$    }
+0$        return success;
+0$        }
+0$            result.push_back(static_cast<typename string_t::value_type>(current));
+0$            }
+0$                break;
+0$                success = false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
+0$            get();
+0$        {
+0$        for (NumberType i = 0; i < len; i++)
+0$        bool success = true;
+0$    {
+0$                    string_t& result)
+0$                    const NumberType len,
+0$    bool get_string(const input_format_t format,
+0$    template<typename NumberType>
+0$    */
+0$          the input before we run out of string memory.
+0$          may be too large. Usually, @ref unexpect_eof() detects the end of
+0$    @note We can not reserve @a len bytes for the result, because @a len
+0$
+0$    @return whether string creation completed
+0$
+0$    @param[out] result string created by reading @a len bytes
+0$    @param[in] len number of characters to read
+0$    @param[in] format the current format (for diagnostics)
+0$    @tparam NumberType the type of the number
+0$
+0$    @brief create a string by reading characters from the input
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$        std::memcpy(&result, vec.data(), sizeof(NumberType));
+0$        // step 2: convert array into number of type T and return
+0$
+0$        }
+0$            }
+0$                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
+0$            {
+0$            else
+0$            }
+0$                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
+0$            {
+0$            if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
+0$            // reverse byte order prior to conversion if necessary
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
+0$            get();
+0$        {
+0$        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
+0$        std::array<std::uint8_t, sizeof(NumberType)> vec{};
+0$        // step 1: read input into array with system's byte order
+0$    {
+0$    bool get_number(const input_format_t format, NumberType& result)
+0$    template<typename NumberType, bool InputIsLittleEndian = false>
+0$    */
+0$          on big endian systems.
+0$          On the other hand, BSON and BJData use little endian and should reorder
+0$          (big endian) and therefore need reordering on little endian systems.
+0$          bytes in CBOR, MessagePack, and UBJSON are stored in network order
+0$    @note This function needs to respect the system's endianness, because
+0$
+0$    @return whether conversion completed
+0$
+0$    @param[out] result  number of type @a NumberType
+0$    @param[in] format   the current format (for diagnostics)
+0$    @tparam NumberType the type of the number
+0$
+0$    @brief read a number from the input
+0$    /*
+0$
+0$    }
+0$        return current;
+0$
+0$        while (current == 'N');
+0$        }
+0$            get();
+0$        {
+0$        do
+0$    {
+0$    char_int_type get_ignore_noop()
+0$    */
+0$    @return character read from the input after ignoring all 'N' entries
+0$    /*!
+0$
+0$    }
+0$        return current = ia.get_character();
+0$        ++chars_read;
+0$    {
+0$    char_int_type get()
+0$    */
+0$    @return character read from the input
+0$
+0$    `char_traits<char_type>::eof()` in that case.
+0$    not throw in case the input reached EOF, but returns a -'ve valued
+0$    This function provides the interface to the used input adapter. It does
+0$
+0$    @brief get next character from the input
+0$    /*!
+0$
+0$    ///////////////////////
+0$    // Utility functions //
+0$    ///////////////////////
+0$
+0$    }
+0$        }
+0$                                        exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
+0$                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
+0$            default:
+0$            case token_type::literal_or_value:
+0$            case token_type::end_of_input:
+0$            case token_type::parse_error:
+0$            case token_type::value_separator:
+0$            case token_type::name_separator:
+0$            case token_type::end_object:
+0$            case token_type::end_array:
+0$            case token_type::begin_object:
+0$            case token_type::begin_array:
+0$            case token_type::value_string:
+0$            case token_type::literal_null:
+0$            case token_type::literal_false:
+0$            case token_type::literal_true:
+0$            case token_type::uninitialized:
+0$                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
+0$            case token_type::value_float:
+0$                return sax->number_unsigned(number_lexer.get_number_unsigned());
+0$            case token_type::value_unsigned:
+0$                return sax->number_integer(number_lexer.get_number_integer());
+0$            case token_type::value_integer:
+0$        {
+0$        switch (result_number)
+0$
+0$        }
+0$                                    exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
+0$            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
+0$
+0$        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;
+0$
+0$        const auto result_remainder = number_lexer.scan();
+0$        const auto number_string = number_lexer.get_token_string();
+0$        const auto result_number = number_lexer.scan();
+0$        auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
+0$        using ia_type = decltype(detail::input_adapter(number_vector));
+0$        // parse number string
+0$
+0$        }
+0$            number_vector.push_back(static_cast<char>(current));
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
+0$            get();
+0$        {
+0$        for (std::size_t i = 0; i < size; ++i)
+0$        std::vector<char> number_vector;
+0$        // get number string
+0$
+0$        }
+0$            return res;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!res))
+0$        auto res = get_ubjson_size_value(size, no_ndarray);
+0$        bool no_ndarray = true;
+0$        std::size_t size{};
+0$        // get size of following number string
+0$    {
+0$    bool get_ubjson_high_precision_number()
+0$
+0$    // not exist
+0$    // Note, no reader for UBJSON binary types is implemented because they do
+0$
+0$    }
+0$        return sax->end_object();
+0$
+0$        }
+0$            }
+0$                key.clear();
+0$                get_ignore_noop();
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
+0$            {
+0$            while (current != '}')
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
+0$        {
+0$        else
+0$        }
+0$            }
+0$                }
+0$                    key.clear();
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
+0$                {
+0$                for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$            {
+0$            else
+0$            }
+0$                }
+0$                    key.clear();
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
+0$                {
+0$                for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$            {
+0$            if (size_and_type.second != 0)
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
+0$        {
+0$        if (size_and_type.first != npos)
+0$        string_t key;
+0$
+0$        }
+0$                                    exception_message(input_format, "BJData object does not support ND-array size in optimized format", "object"), nullptr));
+0$            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$            auto last_token = get_token_string();
+0$        {
+0$        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
+0$        // do not accept ND-array size in objects in BJData
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
+0$        std::pair<std::size_t, char_int_type> size_and_type;
+0$    {
+0$    bool get_ubjson_object()
+0$    */
+0$    @return whether object creation completed
+0$    /*!
+0$
+0$    }
+0$        return sax->end_array();
+0$
+0$        }
+0$            }
+0$                get_ignore_noop();
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
+0$            {
+0$            while (current != ']')
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
+0$        {
+0$        else
+0$        }
+0$            }
+0$                }
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
+0$                {
+0$                for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$            {
+0$            else
+0$            }
+0$                }
+0$                    }
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
+0$                    {
+0$                    for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$                {
+0$                if (size_and_type.second != 'N')
+0$            {
+0$            if (size_and_type.second != 0)
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
+0$        {
+0$        if (size_and_type.first != npos)
+0$
+0$        }
+0$            return (sax->end_array() && sax->end_object());
+0$
+0$            }
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
+0$            {
+0$            for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->start_array(size_and_type.first) ))
+0$            key = "_ArrayData_";
+0$
+0$            }
+0$                size_and_type.second = 'U';
+0$            {
+0$            if (size_and_type.second == 'C')
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->string(type)))
+0$            string_t type = it->second; // sax->string() takes a reference
+0$
+0$            }
+0$                                        exception_message(input_format, "invalid byte: 0x" + last_token, "type"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it->first != size_and_type.second))
+0$            string_t key = "_ArrayType_";
+0$            });
+0$                return p.first < t;
+0$            {
+0$            auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type & p, char_int_type t)
+0$            size_and_type.second &= ~(static_cast<char_int_type>(1) << 8);  // use bit 8 to indicate ndarray, here we remove the bit to restore the type marker
+0$        {
+0$        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
+0$
+0$        // {"_ArrayType_" : "typeid", "_ArraySize_" : [n1, n2, ...], "_ArrayData_" : [v1, v2, ...]}
+0$        // if bit-8 of size_and_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
+0$        std::pair<std::size_t, char_int_type> size_and_type;
+0$    {
+0$    bool get_ubjson_array()
+0$    */
+0$    @return whether array creation completed
+0$    /*!
+0$
+0$    }
+0$        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, "invalid byte: 0x" + last_token, "value"), nullptr));
+0$        auto last_token = get_token_string();
+0$        }
+0$                break;
+0$            default: // anything else
+0$
+0$                return get_ubjson_object();
+0$            case '{':  // object
+0$
+0$                return get_ubjson_array();
+0$            case '[':  // array
+0$
+0$            }
+0$                return get_ubjson_string(s) && sax->string(s);
+0$                string_t s;
+0$            {
+0$            case 'S':  // string
+0$
+0$            }
+0$                return sax->string(s);
+0$                string_t s(1, static_cast<typename string_t::value_type>(current));
+0$                }
+0$                                            exception_message(input_format, concat("byte after 'C' must be in range 0x00..0x7F; last byte: 0x", last_token), "char"), nullptr));
+0$                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
+0$                    auto last_token = get_token_string();
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(current > 127))
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "char")))
+0$                get();
+0$            {
+0$            case 'C':  // char
+0$
+0$            }
+0$                return get_ubjson_high_precision_number();
+0$            {
+0$            case 'H':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                double number{};
+0$            {
+0$            case 'D':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                float number{};
+0$            {
+0$            case 'd':
+0$
+0$            }
+0$                                         : static_cast<number_float_t>(val), "");
+0$                                         ? static_cast<number_float_t>(-val)
+0$                return sax->number_float((half & 0x8000u) != 0
+0$                }();
+0$                    }
+0$                            return std::ldexp(mant + 1024, exp - 25);
+0$                        default:
+0$                            : std::numeric_limits<double>::quiet_NaN();
+0$                            ? std::numeric_limits<double>::infinity()
+0$                            return (mant == 0)
+0$                        case 31:
+0$                            return std::ldexp(mant, -24);
+0$                        case 0:
+0$                    {
+0$                    switch (exp)
+0$                    JSON_ASSERT(mant <= 1024);
+0$                    JSON_ASSERT(0 <= exp&& exp <= 32);
+0$                    const unsigned int mant = half & 0x3FFu;
+0$                    const int exp = (half >> 10u) & 0x1Fu;
+0$                {
+0$                const double val = [&half]
+0$                const auto half = static_cast<unsigned int>((byte2 << 8u) + byte1);
+0$                // is shown in Fig. 3.
+0$                // half-precision floating-point numbers in the C language
+0$                // without such support. An example of a small decoder for
+0$                // easy to include at least decoding support for them even
+0$                // still only have limited support for them. It is very
+0$                // to IEEE 754 in 2008, today's programming platforms often
+0$                // As half-precision floating-point numbers were only added
+0$                // code from RFC 7049, Appendix D, Figure 3:
+0$
+0$                const auto byte2 = static_cast<unsigned char>(byte2_raw);
+0$                const auto byte1 = static_cast<unsigned char>(byte1_raw);
+0$
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
+0$                const auto byte2_raw = get();
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
+0$                const auto byte1_raw = get();
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'h':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_unsigned(number);
+0$                std::uint64_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'M':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_unsigned(number);
+0$                std::uint32_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'm':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_unsigned(number);
+0$                std::uint16_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'u':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_integer(number);
+0$                std::int64_t number{};
+0$            {
+0$            case 'L':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_integer(number);
+0$                std::int32_t number{};
+0$            {
+0$            case 'l':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_integer(number);
+0$                std::int16_t number{};
+0$            {
+0$            case 'I':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_integer(number);
+0$                std::int8_t number{};
+0$            {
+0$            case 'i':
+0$
+0$            }
+0$                return get_number(input_format, number) && sax->number_unsigned(number);
+0$                std::uint8_t number{};
+0$            {
+0$            case 'U':
+0$
+0$                return sax->null();
+0$            case 'Z':  // null
+0$
+0$                return sax->boolean(false);
+0$            case 'F':  // false
+0$                return sax->boolean(true);
+0$            case 'T':  // true
+0$
+0$                return unexpect_eof(input_format, "value");
+0$            case char_traits<char_type>::eof():  // EOF
+0$        {
+0$        switch (prefix)
+0$    {
+0$    bool get_ubjson_value(const char_int_type prefix)
+0$    */
+0$    @return whether value creation completed
+0$    @param prefix  the previously read or set type prefix
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            return is_error;
+0$            }
+0$                                        exception_message(input_format, "ndarray requires both type and size", "size"), nullptr));
+0$                return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
+0$            {
+0$            if (input_format == input_format_t::bjdata && is_ndarray)
+0$            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
+0$        {
+0$        if (current == '#')
+0$
+0$        }
+0$            return is_error;
+0$            }
+0$                result.second |= (1 << 8); // use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters
+0$                }
+0$                                            exception_message(input_format, "ndarray can not be recursive", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
+0$                {
+0$                if (inside_ndarray)
+0$            {
+0$            if (input_format == input_format_t::bjdata && is_ndarray)
+0$            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
+0$
+0$            }
+0$                                        exception_message(input_format, concat("expected '#' after type information; last byte: 0x", last_token), "size"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                auto last_token = get_token_string();
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(current != '#'))
+0$            get_ignore_noop();
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "type")))
+0$
+0$            }
+0$                                        exception_message(input_format, concat("marker 0x", last_token, " is not a permitted optimized array type"), "type"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$                    && JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
+0$            if (input_format == input_format_t::bjdata
+0$            result.second = get();  // must not ignore 'N', because 'N' maybe the type
+0$        {
+0$        if (current == '$')
+0$
+0$        get_ignore_noop();
+0$
+0$        bool is_ndarray = false;
+0$        result.second = 0; // type
+0$        result.first = npos; // size
+0$    {
+0$    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result, bool inside_ndarray = false)
+0$    */
+0$    @return whether pair creation completed
+0$
+0$    @param[in] inside_ndarray  whether the parser is parsing an ND array dimensional vector
+0$    @param[out] result  pair of the size and the type
+0$
+0$    for a more compact representation.
+0$    In the optimized UBJSON format, a type and a size can be provided to allow
+0$
+0$    @brief determine the type and size for a container
+0$    /*!
+0$
+0$    }
+0$        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "size"), nullptr));
+0$        }
+0$            message = "expected length type specification (U, i, u, I, m, l, M, L) after '#'; last byte: 0x" + last_token;
+0$        {
+0$        else
+0$        }
+0$            message = "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token;
+0$        {
+0$        if (input_format != input_format_t::bjdata)
+0$
+0$        std::string message;
+0$        auto last_token = get_token_string();
+0$        }
+0$                break;
+0$            default:
+0$
+0$            }
+0$                return true;
+0$                result = 0;
+0$                }
+0$                    return sax->end_array();
+0$                    is_ndarray = true;
+0$                    }
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(static_cast<number_unsigned_t>(i))))
+0$                        }
+0$                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
+0$                        {
+0$                        if (result == 0 || result == npos) // because dim elements shall not have zeros, result = 0 means overflow happened; it also can't be npos as it is used to initialize size in get_ubjson_size_type()
+0$                        result *= i;
+0$                    {
+0$                    for (auto i : dim)
+0$                    result = 1;
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!sax->start_object(3) || !sax->key(key) || !sax->start_array(dim.size())))
+0$                    string_t key = "_ArraySize_";
+0$
+0$                    }
+0$                        }
+0$                            return true;
+0$                            result = 0;
+0$                        {
+0$                        if ( i == 0 )
+0$                    {
+0$                    for (auto i : dim) // test if any dimension in an ndarray is 0, if so, return a 1D empty container
+0$                {
+0$                if (!dim.empty())  // if ndarray, convert to an object in JData annotated array format
+0$                }
+0$                    return true;
+0$                    result = dim.at(dim.size() - 1);
+0$                {
+0$                if (dim.size() == 1 || (dim.size() == 2 && dim.at(0) == 1)) // return normal array size if 1D row vector
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
+0$                std::vector<size_t> dim;
+0$                }
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, "ndarray dimensional vector is not allowed", "size"), nullptr));
+0$                {
+0$                if (is_ndarray) // ndarray dimensional vector can only contain integers, and can not embed another array
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case '[':
+0$
+0$            }
+0$                return true;
+0$                result = detail::conditional_static_cast<std::size_t>(number);
+0$                }
+0$                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
+0$                {
+0$                if (!value_in_range_of<std::size_t>(number))
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::uint64_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'M':
+0$
+0$            }
+0$                return true;
+0$                result = conditional_static_cast<std::size_t>(number);
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::uint32_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'm':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number);
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::uint16_t number{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'u':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number);
+0$                }
+0$                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
+0$                {
+0$                if (!value_in_range_of<std::size_t>(number))
+0$                }
+0$                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
+0$                {
+0$                if (number < 0)
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::int64_t number{};
+0$            {
+0$            case 'L':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number);
+0$                }
+0$                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
+0$                {
+0$                if (number < 0)
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::int32_t number{};
+0$            {
+0$            case 'l':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number);
+0$                }
+0$                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
+0$                {
+0$                if (number < 0)
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::int16_t number{};
+0$            {
+0$            case 'I':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number); // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char
+0$                }
+0$                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
+0$                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
+0$                {
+0$                if (number < 0)
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::int8_t number{};
+0$            {
+0$            case 'i':
+0$
+0$            }
+0$                return true;
+0$                result = static_cast<std::size_t>(number);
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
+0$                std::uint8_t number{};
+0$            {
+0$            case 'U':
+0$        {
+0$        switch (prefix)
+0$
+0$        }
+0$            prefix = get_ignore_noop();
+0$        {
+0$        if (prefix == 0)
+0$    {
+0$    bool get_ubjson_size_value(std::size_t& result, bool& is_ndarray, char_int_type prefix = 0)
+0$    */
+0$    @return whether size determination completed
+0$
+0$    @param[in] prefix  type marker if already read, otherwise set to 0
+0$                               is `false`
+0$                               is_ndarray can only return `true` when its initial value
+0$                               is allowed; for output, `true` means an ndarray is found;
+0$                               or ndarray dimension is not allowed; `false` means ndarray
+0$    @param[in,out] is_ndarray  for input, `true` means already inside an ndarray vector
+0$    @param[out] result  determined size
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$        }
+0$            }
+0$                get_ignore_noop();
+0$                dim.push_back(dimlen);
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
+0$            {
+0$            while (current != ']')
+0$        {
+0$        else
+0$        }
+0$            }
+0$                }
+0$                    dim.push_back(dimlen);
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
+0$                {
+0$                for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$            {
+0$            else
+0$            }
+0$                }
+0$                    }
+0$                        dim.push_back(dimlen);
+0$                        }
+0$                            return false;
+0$                        {
+0$                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
+0$                    {
+0$                    for (std::size_t i = 0; i < size_and_type.first; ++i)
+0$                {
+0$                if (size_and_type.second != 'N')
+0$            {
+0$            if (size_and_type.second != 0)
+0$        {
+0$        if (size_and_type.first != npos)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
+0$
+0$        bool no_ndarray = true;
+0$        size_t dimlen = 0;
+0$        std::pair<std::size_t, char_int_type> size_and_type;
+0$    {
+0$    bool get_ubjson_ndarray_size(std::vector<size_t>& dim)
+0$    */
+0$    @return whether reading ND array size vector is successful
+0$    @param[out] dim  an integer vector storing the ND array dimensions
+0$    /*!
+0$
+0$    }
+0$        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "string"), nullptr));
+0$        }
+0$            message = "expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x" + last_token;
+0$        {
+0$        else
+0$        }
+0$            message = "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token;
+0$        {
+0$        if (input_format != input_format_t::bjdata)
+0$
+0$        std::string message;
+0$        auto last_token = get_token_string();
+0$        }
+0$                break;
+0$            default:
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::uint64_t len{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'M':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::uint32_t len{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'm':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::uint16_t len{};
+0$                }
+0$                    break;
+0$                {
+0$                if (input_format != input_format_t::bjdata)
+0$            {
+0$            case 'u':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::int64_t len{};
+0$            {
+0$            case 'L':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::int32_t len{};
+0$            {
+0$            case 'l':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::int16_t len{};
+0$            {
+0$            case 'I':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::int8_t len{};
+0$            {
+0$            case 'i':
+0$
+0$            }
+0$                return get_number(input_format, len) && get_string(input_format, len, result);
+0$                std::uint8_t len{};
+0$            {
+0$            case 'U':
+0$        {
+0$        switch (current)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
+0$
+0$        }
+0$            get();  // TODO(niels): may we ignore N here?
+0$        {
+0$        if (get_char)
+0$    {
+0$    bool get_ubjson_string(string_t& result, const bool get_char = true)
+0$    */
+0$    @return whether string creation completed
+0$
+0$                         character should be considered instead
+0$                         input (true, default) or whether the last read
+0$    @param[in] get_char  whether a new character should be retrieved from the
+0$    @param[out] result   created string
+0$
+0$    left out.
+0$    indicating a string, or in case of an object key where the 'S' byte can be
+0$    This function is either called after reading the 'S' byte explicitly
+0$
+0$    @brief reads a UBJSON string
+0$    /*!
+0$
+0$    }
+0$        return get_ubjson_value(get_char ? get_ignore_noop() : current);
+0$    {
+0$    bool parse_ubjson_internal(const bool get_char = true)
+0$    */
+0$    @return whether a valid UBJSON value was passed to the SAX parser
+0$
+0$                         character should be considered instead
+0$                         input (true, default) or whether the last read
+0$    @param[in] get_char  whether a new character should be retrieved from the
+0$    /*!
+0$
+0$    ////////////
+0$    // UBJSON //
+0$    ////////////
+0$
+0$    }
+0$        return sax->end_object();
+0$
+0$        }
+0$            key.clear();
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
+0$            get();
+0$        {
+0$        for (std::size_t i = 0; i < len; ++i)
+0$        string_t key;
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
+0$    {
+0$    bool get_msgpack_object(const std::size_t len)
+0$    */
+0$    @return whether object creation completed
+0$    @param[in] len  the length of the object
+0$    /*!
+0$
+0$    }
+0$        return sax->end_array();
+0$
+0$        }
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
+0$        {
+0$        for (std::size_t i = 0; i < len; ++i)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
+0$    {
+0$    bool get_msgpack_array(const std::size_t len)
+0$    */
+0$    @return whether array creation completed
+0$    @param[in] len  the length of the array
+0$    /*!
+0$
+0$    }
+0$        }
+0$                return false;  // LCOV_EXCL_LINE
+0$            default:           // LCOV_EXCL_LINE
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, 16, result) &&
+0$                return get_number(input_format_t::msgpack, subtype) &&
+0$                std::int8_t subtype{};
+0$            {
+0$            case 0xD8: // fixext 16
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, 8, result) &&
+0$                return get_number(input_format_t::msgpack, subtype) &&
+0$                std::int8_t subtype{};
+0$            {
+0$            case 0xD7: // fixext 8
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, 4, result) &&
+0$                return get_number(input_format_t::msgpack, subtype) &&
+0$                std::int8_t subtype{};
+0$            {
+0$            case 0xD6: // fixext 4
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, 2, result) &&
+0$                return get_number(input_format_t::msgpack, subtype) &&
+0$                std::int8_t subtype{};
+0$            {
+0$            case 0xD5: // fixext 2
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, 1, result) &&
+0$                return get_number(input_format_t::msgpack, subtype) &&
+0$                std::int8_t subtype{};
+0$            {
+0$            case 0xD4: // fixext 1
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, len, result) &&
+0$                       get_number(input_format_t::msgpack, subtype) &&
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::int8_t subtype{};
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xC9: // ext 32
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, len, result) &&
+0$                       get_number(input_format_t::msgpack, subtype) &&
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::int8_t subtype{};
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xC8: // ext 16
+0$
+0$            }
+0$                       assign_and_return_true(subtype);
+0$                       get_binary(input_format_t::msgpack, len, result) &&
+0$                       get_number(input_format_t::msgpack, subtype) &&
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::int8_t subtype{};
+0$                std::uint8_t len{};
+0$            {
+0$            case 0xC7: // ext 8
+0$
+0$            }
+0$                       get_binary(input_format_t::msgpack, len, result);
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xC6: // bin 32
+0$
+0$            }
+0$                       get_binary(input_format_t::msgpack, len, result);
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xC5: // bin 16
+0$
+0$            }
+0$                       get_binary(input_format_t::msgpack, len, result);
+0$                return get_number(input_format_t::msgpack, len) &&
+0$                std::uint8_t len{};
+0$            {
+0$            case 0xC4: // bin 8
+0$        {
+0$        switch (current)
+0$
+0$        };
+0$            return true;
+0$            result.set_subtype(static_cast<std::uint8_t>(subtype));
+0$        {
+0$        auto assign_and_return_true = [&result](std::int8_t subtype)
+0$        // helper function to set the subtype
+0$    {
+0$    bool get_msgpack_binary(binary_t& result)
+0$    */
+0$    @return whether byte array creation completed
+0$
+0$    @param[out] result  created byte array
+0$
+0$    byte array length and then copies this number of bytes into a byte array.
+0$    This function first reads starting bytes to determine the expected
+0$
+0$    @brief reads a MessagePack byte array
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        exception_message(input_format_t::msgpack, concat("expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x", last_token), "string"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            default:
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xDB: // str 32
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xDA: // str 16
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
+0$                std::uint8_t len{};
+0$            {
+0$            case 0xD9: // str 8
+0$
+0$            }
+0$                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
+0$            {
+0$            case 0xBF:
+0$            case 0xBE:
+0$            case 0xBD:
+0$            case 0xBC:
+0$            case 0xBB:
+0$            case 0xBA:
+0$            case 0xB9:
+0$            case 0xB8:
+0$            case 0xB7:
+0$            case 0xB6:
+0$            case 0xB5:
+0$            case 0xB4:
+0$            case 0xB3:
+0$            case 0xB2:
+0$            case 0xB1:
+0$            case 0xB0:
+0$            case 0xAF:
+0$            case 0xAE:
+0$            case 0xAD:
+0$            case 0xAC:
+0$            case 0xAB:
+0$            case 0xAA:
+0$            case 0xA9:
+0$            case 0xA8:
+0$            case 0xA7:
+0$            case 0xA6:
+0$            case 0xA5:
+0$            case 0xA4:
+0$            case 0xA3:
+0$            case 0xA2:
+0$            case 0xA1:
+0$            case 0xA0:
+0$            // fixstr
+0$        {
+0$        switch (current)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
+0$    {
+0$    bool get_msgpack_string(string_t& result)
+0$    */
+0$    @return whether string creation completed
+0$
+0$    @param[out] result  created string
+0$
+0$    string length and then copies this number of bytes into a string.
+0$    This function first reads starting bytes to determine the expected
+0$
+0$    @brief reads a MessagePack string
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        exception_message(input_format_t::msgpack, concat("invalid byte: 0x", last_token), "value"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            default: // anything else
+0$
+0$                return sax->number_integer(static_cast<std::int8_t>(current));
+0$            case 0xFF:
+0$            case 0xFE:
+0$            case 0xFD:
+0$            case 0xFC:
+0$            case 0xFB:
+0$            case 0xFA:
+0$            case 0xF9:
+0$            case 0xF8:
+0$            case 0xF7:
+0$            case 0xF6:
+0$            case 0xF5:
+0$            case 0xF4:
+0$            case 0xF3:
+0$            case 0xF2:
+0$            case 0xF1:
+0$            case 0xF0:
+0$            case 0xEF:
+0$            case 0xEE:
+0$            case 0xED:
+0$            case 0xEC:
+0$            case 0xEB:
+0$            case 0xEA:
+0$            case 0xE9:
+0$            case 0xE8:
+0$            case 0xE7:
+0$            case 0xE6:
+0$            case 0xE5:
+0$            case 0xE4:
+0$            case 0xE3:
+0$            case 0xE2:
+0$            case 0xE1:
+0$            case 0xE0:
+0$            // negative fixint
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_msgpack_object(conditional_static_cast<std::size_t>(len));
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xDF: // map 32
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xDE: // map 16
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_msgpack_array(conditional_static_cast<std::size_t>(len));
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xDD: // array 32
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xDC: // array 16
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
+0$                std::int64_t number{};
+0$            {
+0$            case 0xD3: // int 64
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
+0$                std::int32_t number{};
+0$            {
+0$            case 0xD2: // int 32
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
+0$                std::int16_t number{};
+0$            {
+0$            case 0xD1: // int 16
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
+0$                std::int8_t number{};
+0$            {
+0$            case 0xD0: // int 8
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
+0$                std::uint64_t number{};
+0$            {
+0$            case 0xCF: // uint 64
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
+0$                std::uint32_t number{};
+0$            {
+0$            case 0xCE: // uint 32
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
+0$                std::uint16_t number{};
+0$            {
+0$            case 0xCD: // uint 16
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
+0$                std::uint8_t number{};
+0$            {
+0$            case 0xCC: // uint 8
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                double number{};
+0$            {
+0$            case 0xCB: // float 64
+0$
+0$            }
+0$                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                float number{};
+0$            {
+0$            case 0xCA: // float 32
+0$
+0$            }
+0$                return get_msgpack_binary(b) && sax->binary(b);
+0$                binary_t b;
+0$            {
+0$            case 0xD8: // fixext 16
+0$            case 0xD7: // fixext 8
+0$            case 0xD6: // fixext 4
+0$            case 0xD5: // fixext 2
+0$            case 0xD4: // fixext 1
+0$            case 0xC9: // ext 32
+0$            case 0xC8: // ext 16
+0$            case 0xC7: // ext 8
+0$            case 0xC6: // bin 32
+0$            case 0xC5: // bin 16
+0$            case 0xC4: // bin 8
+0$
+0$                return sax->boolean(true);
+0$            case 0xC3: // true
+0$
+0$                return sax->boolean(false);
+0$            case 0xC2: // false
+0$
+0$                return sax->null();
+0$            case 0xC0: // nil
+0$
+0$            }
+0$                return get_msgpack_string(s) && sax->string(s);
+0$                string_t s;
+0$            {
+0$            case 0xDB: // str 32
+0$            case 0xDA: // str 16
+0$            case 0xD9: // str 8
+0$            case 0xBF:
+0$            case 0xBE:
+0$            case 0xBD:
+0$            case 0xBC:
+0$            case 0xBB:
+0$            case 0xBA:
+0$            case 0xB9:
+0$            case 0xB8:
+0$            case 0xB7:
+0$            case 0xB6:
+0$            case 0xB5:
+0$            case 0xB4:
+0$            case 0xB3:
+0$            case 0xB2:
+0$            case 0xB1:
+0$            case 0xB0:
+0$            case 0xAF:
+0$            case 0xAE:
+0$            case 0xAD:
+0$            case 0xAC:
+0$            case 0xAB:
+0$            case 0xAA:
+0$            case 0xA9:
+0$            case 0xA8:
+0$            case 0xA7:
+0$            case 0xA6:
+0$            case 0xA5:
+0$            case 0xA4:
+0$            case 0xA3:
+0$            case 0xA2:
+0$            case 0xA1:
+0$            case 0xA0:
+0$            // fixstr
+0$
+0$                return get_msgpack_array(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
+0$            case 0x9F:
+0$            case 0x9E:
+0$            case 0x9D:
+0$            case 0x9C:
+0$            case 0x9B:
+0$            case 0x9A:
+0$            case 0x99:
+0$            case 0x98:
+0$            case 0x97:
+0$            case 0x96:
+0$            case 0x95:
+0$            case 0x94:
+0$            case 0x93:
+0$            case 0x92:
+0$            case 0x91:
+0$            case 0x90:
+0$            // fixarray
+0$
+0$                return get_msgpack_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
+0$            case 0x8F:
+0$            case 0x8E:
+0$            case 0x8D:
+0$            case 0x8C:
+0$            case 0x8B:
+0$            case 0x8A:
+0$            case 0x89:
+0$            case 0x88:
+0$            case 0x87:
+0$            case 0x86:
+0$            case 0x85:
+0$            case 0x84:
+0$            case 0x83:
+0$            case 0x82:
+0$            case 0x81:
+0$            case 0x80:
+0$            // fixmap
+0$
+0$                return sax->number_unsigned(static_cast<number_unsigned_t>(current));
+0$            case 0x7F:
+0$            case 0x7E:
+0$            case 0x7D:
+0$            case 0x7C:
+0$            case 0x7B:
+0$            case 0x7A:
+0$            case 0x79:
+0$            case 0x78:
+0$            case 0x77:
+0$            case 0x76:
+0$            case 0x75:
+0$            case 0x74:
+0$            case 0x73:
+0$            case 0x72:
+0$            case 0x71:
+0$            case 0x70:
+0$            case 0x6F:
+0$            case 0x6E:
+0$            case 0x6D:
+0$            case 0x6C:
+0$            case 0x6B:
+0$            case 0x6A:
+0$            case 0x69:
+0$            case 0x68:
+0$            case 0x67:
+0$            case 0x66:
+0$            case 0x65:
+0$            case 0x64:
+0$            case 0x63:
+0$            case 0x62:
+0$            case 0x61:
+0$            case 0x60:
+0$            case 0x5F:
+0$            case 0x5E:
+0$            case 0x5D:
+0$            case 0x5C:
+0$            case 0x5B:
+0$            case 0x5A:
+0$            case 0x59:
+0$            case 0x58:
+0$            case 0x57:
+0$            case 0x56:
+0$            case 0x55:
+0$            case 0x54:
+0$            case 0x53:
+0$            case 0x52:
+0$            case 0x51:
+0$            case 0x50:
+0$            case 0x4F:
+0$            case 0x4E:
+0$            case 0x4D:
+0$            case 0x4C:
+0$            case 0x4B:
+0$            case 0x4A:
+0$            case 0x49:
+0$            case 0x48:
+0$            case 0x47:
+0$            case 0x46:
+0$            case 0x45:
+0$            case 0x44:
+0$            case 0x43:
+0$            case 0x42:
+0$            case 0x41:
+0$            case 0x40:
+0$            case 0x3F:
+0$            case 0x3E:
+0$            case 0x3D:
+0$            case 0x3C:
+0$            case 0x3B:
+0$            case 0x3A:
+0$            case 0x39:
+0$            case 0x38:
+0$            case 0x37:
+0$            case 0x36:
+0$            case 0x35:
+0$            case 0x34:
+0$            case 0x33:
+0$            case 0x32:
+0$            case 0x31:
+0$            case 0x30:
+0$            case 0x2F:
+0$            case 0x2E:
+0$            case 0x2D:
+0$            case 0x2C:
+0$            case 0x2B:
+0$            case 0x2A:
+0$            case 0x29:
+0$            case 0x28:
+0$            case 0x27:
+0$            case 0x26:
+0$            case 0x25:
+0$            case 0x24:
+0$            case 0x23:
+0$            case 0x22:
+0$            case 0x21:
+0$            case 0x20:
+0$            case 0x1F:
+0$            case 0x1E:
+0$            case 0x1D:
+0$            case 0x1C:
+0$            case 0x1B:
+0$            case 0x1A:
+0$            case 0x19:
+0$            case 0x18:
+0$            case 0x17:
+0$            case 0x16:
+0$            case 0x15:
+0$            case 0x14:
+0$            case 0x13:
+0$            case 0x12:
+0$            case 0x11:
+0$            case 0x10:
+0$            case 0x0F:
+0$            case 0x0E:
+0$            case 0x0D:
+0$            case 0x0C:
+0$            case 0x0B:
+0$            case 0x0A:
+0$            case 0x09:
+0$            case 0x08:
+0$            case 0x07:
+0$            case 0x06:
+0$            case 0x05:
+0$            case 0x04:
+0$            case 0x03:
+0$            case 0x02:
+0$            case 0x01:
+0$            case 0x00:
+0$            // positive fixint
+0$
+0$                return unexpect_eof(input_format_t::msgpack, "value");
+0$            case char_traits<char_type>::eof():
+0$            // EOF
+0$        {
+0$        switch (get())
+0$    {
+0$    bool parse_msgpack_internal()
+0$    */
+0$    @return whether a valid MessagePack value was passed to the SAX parser
+0$    /*!
+0$
+0$    /////////////
+0$    // MsgPack //
+0$    /////////////
+0$
+0$    }
+0$        return sax->end_object();
+0$
+0$        }
+0$            }
+0$                }
+0$                    key.clear();
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
+0$
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
+0$                {
+0$                while (get() != 0xFF)
+0$            {
+0$            else
+0$            }
+0$                }
+0$                    key.clear();
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
+0$
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
+0$                    get();
+0$                {
+0$                for (std::size_t i = 0; i < len; ++i)
+0$            {
+0$            if (len != static_cast<std::size_t>(-1))
+0$            string_t key;
+0$        {
+0$        if (len != 0)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
+0$    {
+0$                         const cbor_tag_handler_t tag_handler)
+0$    bool get_cbor_object(const std::size_t len,
+0$    */
+0$    @return whether object creation completed
+0$    @param[in] tag_handler how CBOR tags should be treated
+0$                    object of indefinite size
+0$    @param[in] len  the length of the object or static_cast<std::size_t>(-1) for an
+0$    /*!
+0$
+0$    }
+0$        return sax->end_array();
+0$
+0$        }
+0$            }
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
+0$            {
+0$            while (get() != 0xFF)
+0$        {
+0$        else
+0$        }
+0$            }
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
+0$            {
+0$            for (std::size_t i = 0; i < len; ++i)
+0$        {
+0$        if (len != static_cast<std::size_t>(-1))
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
+0$    {
+0$                        const cbor_tag_handler_t tag_handler)
+0$    bool get_cbor_array(const std::size_t len,
+0$    */
+0$    @return whether array creation completed
+0$    @param[in] tag_handler how CBOR tags should be treated
+0$                    array of indefinite size
+0$    @param[in] len  the length of the array or static_cast<std::size_t>(-1) for an
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        exception_message(input_format_t::cbor, concat("expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x", last_token), "binary"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            default:
+0$
+0$            }
+0$                return true;
+0$                }
+0$                    result.insert(result.end(), chunk.begin(), chunk.end());
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (!get_cbor_binary(chunk))
+0$                    binary_t chunk;
+0$                {
+0$                while (get() != 0xFF)
+0$            {
+0$            case 0x5F: // Binary data (indefinite length)
+0$
+0$            }
+0$                       get_binary(input_format_t::cbor, len, result);
+0$                return get_number(input_format_t::cbor, len) &&
+0$                std::uint64_t len{};
+0$            {
+0$            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
+0$
+0$            }
+0$                       get_binary(input_format_t::cbor, len, result);
+0$                return get_number(input_format_t::cbor, len) &&
+0$                std::uint32_t len{};
+0$            {
+0$            case 0x5A: // Binary data (four-byte uint32_t for n follow)
+0$
+0$            }
+0$                       get_binary(input_format_t::cbor, len, result);
+0$                return get_number(input_format_t::cbor, len) &&
+0$                std::uint16_t len{};
+0$            {
+0$            case 0x59: // Binary data (two-byte uint16_t for n follow)
+0$
+0$            }
+0$                       get_binary(input_format_t::cbor, len, result);
+0$                return get_number(input_format_t::cbor, len) &&
+0$                std::uint8_t len{};
+0$            {
+0$            case 0x58: // Binary data (one-byte uint8_t for n follows)
+0$
+0$            }
+0$                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
+0$            {
+0$            case 0x57:
+0$            case 0x56:
+0$            case 0x55:
+0$            case 0x54:
+0$            case 0x53:
+0$            case 0x52:
+0$            case 0x51:
+0$            case 0x50:
+0$            case 0x4F:
+0$            case 0x4E:
+0$            case 0x4D:
+0$            case 0x4C:
+0$            case 0x4B:
+0$            case 0x4A:
+0$            case 0x49:
+0$            case 0x48:
+0$            case 0x47:
+0$            case 0x46:
+0$            case 0x45:
+0$            case 0x44:
+0$            case 0x43:
+0$            case 0x42:
+0$            case 0x41:
+0$            case 0x40:
+0$            // Binary data (0x00..0x17 bytes follow)
+0$        {
+0$        switch (current)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
+0$    {
+0$    bool get_cbor_binary(binary_t& result)
+0$    */
+0$    @return whether byte array creation completed
+0$
+0$    @param[out] result  created byte array
+0$
+0$    Additionally, CBOR's byte arrays with indefinite lengths are supported.
+0$    byte array length and then copies this number of bytes into the byte array.
+0$    This function first reads starting bytes to determine the expected
+0$
+0$    @brief reads a CBOR byte array
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        exception_message(input_format_t::cbor, concat("expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x", last_token), "string"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            default:
+0$
+0$            }
+0$                return true;
+0$                }
+0$                    result.append(chunk);
+0$                    }
+0$                        return false;
+0$                    {
+0$                    if (!get_cbor_string(chunk))
+0$                    string_t chunk;
+0$                {
+0$                while (get() != 0xFF)
+0$            {
+0$            case 0x7F: // UTF-8 string (indefinite length)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
+0$                std::uint64_t len{};
+0$            {
+0$            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
+0$                std::uint32_t len{};
+0$            {
+0$            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
+0$                std::uint16_t len{};
+0$            {
+0$            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
+0$                std::uint8_t len{};
+0$            {
+0$            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
+0$
+0$            }
+0$                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
+0$            {
+0$            case 0x77:
+0$            case 0x76:
+0$            case 0x75:
+0$            case 0x74:
+0$            case 0x73:
+0$            case 0x72:
+0$            case 0x71:
+0$            case 0x70:
+0$            case 0x6F:
+0$            case 0x6E:
+0$            case 0x6D:
+0$            case 0x6C:
+0$            case 0x6B:
+0$            case 0x6A:
+0$            case 0x69:
+0$            case 0x68:
+0$            case 0x67:
+0$            case 0x66:
+0$            case 0x65:
+0$            case 0x64:
+0$            case 0x63:
+0$            case 0x62:
+0$            case 0x61:
+0$            case 0x60:
+0$            // UTF-8 string (0x00..0x17 bytes follow)
+0$        {
+0$        switch (current)
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
+0$    {
+0$    bool get_cbor_string(string_t& result)
+0$    */
+0$    @return whether string creation completed
+0$
+0$    @param[out] result  created string
+0$
+0$    Additionally, CBOR's strings with indefinite lengths are supported.
+0$    string length and then copies this number of bytes into a string.
+0$    This function first reads starting bytes to determine the expected
+0$
+0$    @brief reads a CBOR string
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
+0$                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                auto last_token = get_token_string();
+0$            {
+0$            default: // anything else (0xFF is handled inside the other types)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                double number{};
+0$            {
+0$            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                float number{};
+0$            {
+0$            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
+0$
+0$            }
+0$                                         : static_cast<number_float_t>(val), "");
+0$                                         ? static_cast<number_float_t>(-val)
+0$                return sax->number_float((half & 0x8000u) != 0
+0$                }();
+0$                    }
+0$                            return std::ldexp(mant + 1024, exp - 25);
+0$                        default:
+0$                            : std::numeric_limits<double>::quiet_NaN();
+0$                            ? std::numeric_limits<double>::infinity()
+0$                            return (mant == 0)
+0$                        case 31:
+0$                            return std::ldexp(mant, -24);
+0$                        case 0:
+0$                    {
+0$                    switch (exp)
+0$                    JSON_ASSERT(mant <= 1024);
+0$                    JSON_ASSERT(0 <= exp&& exp <= 32);
+0$                    const unsigned int mant = half & 0x3FFu;
+0$                    const int exp = (half >> 10u) & 0x1Fu;
+0$                {
+0$                const double val = [&half]
+0$                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
+0$                // is shown in Fig. 3.
+0$                // half-precision floating-point numbers in the C language
+0$                // without such support. An example of a small decoder for
+0$                // easy to include at least decoding support for them even
+0$                // still only have limited support for them. It is very
+0$                // to IEEE 754 in 2008, today's programming platforms often
+0$                // As half-precision floating-point numbers were only added
+0$                // code from RFC 7049, Appendix D, Figure 3:
+0$
+0$                const auto byte2 = static_cast<unsigned char>(byte2_raw);
+0$                const auto byte1 = static_cast<unsigned char>(byte1_raw);
+0$
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
+0$                const auto byte2_raw = get();
+0$                }
+0$                    return false;
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
+0$                const auto byte1_raw = get();
+0$            {
+0$            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
+0$
+0$                return sax->null();
+0$            case 0xF6: // null
+0$
+0$                return sax->boolean(true);
+0$            case 0xF5: // true
+0$
+0$                return sax->boolean(false);
+0$            case 0xF4: // false
+0$
+0$            }
+0$                }
+0$                        return false;        // LCOV_EXCL_LINE
+0$                        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$                    default:                 // LCOV_EXCL_LINE
+0$
+0$                    }
+0$                        return get_cbor_binary(b) && sax->binary(b);
+0$                        get();
+0$                        }
+0$                                return parse_cbor_internal(true, tag_handler);
+0$                            default:
+0$                            }
+0$                                break;
+0$                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
+0$                                get_number(input_format_t::cbor, subtype);
+0$                                std::uint64_t subtype{};
+0$                            {
+0$                            case 0xDB:
+0$                            }
+0$                                break;
+0$                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
+0$                                get_number(input_format_t::cbor, subtype);
+0$                                std::uint32_t subtype{};
+0$                            {
+0$                            case 0xDA:
+0$                            }
+0$                                break;
+0$                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
+0$                                get_number(input_format_t::cbor, subtype);
+0$                                std::uint16_t subtype{};
+0$                            {
+0$                            case 0xD9:
+0$                            }
+0$                                break;
+0$                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
+0$                                get_number(input_format_t::cbor, subtype);
+0$                                std::uint8_t subtype{};
+0$                            {
+0$                            case 0xD8:
+0$                        {
+0$                        switch (current)
+0$                        // use binary subtype and store in binary container
+0$                        binary_t b;
+0$                    {
+0$                    case cbor_tag_handler_t::store:
+0$
+0$                    }
+0$                        return parse_cbor_internal(true, tag_handler);
+0$                        }
+0$                                break;
+0$                            default:
+0$                            }
+0$                                break;
+0$                                get_number(input_format_t::cbor, subtype_to_ignore);
+0$                                std::uint64_t subtype_to_ignore{};
+0$                            {
+0$                            case 0xDB:
+0$                            }
+0$                                break;
+0$                                get_number(input_format_t::cbor, subtype_to_ignore);
+0$                                std::uint32_t subtype_to_ignore{};
+0$                            {
+0$                            case 0xDA:
+0$                            }
+0$                                break;
+0$                                get_number(input_format_t::cbor, subtype_to_ignore);
+0$                                std::uint16_t subtype_to_ignore{};
+0$                            {
+0$                            case 0xD9:
+0$                            }
+0$                                break;
+0$                                get_number(input_format_t::cbor, subtype_to_ignore);
+0$                                std::uint8_t subtype_to_ignore{};
+0$                            {
+0$                            case 0xD8:
+0$                        {
+0$                        switch (current)
+0$                        // ignore binary subtype
+0$                    {
+0$                    case cbor_tag_handler_t::ignore:
+0$
+0$                    }
+0$                                                exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
+0$                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$                        auto last_token = get_token_string();
+0$                    {
+0$                    case cbor_tag_handler_t::error:
+0$                {
+0$                switch (tag_handler)
+0$            {
+0$            case 0xDB: // tagged item (8 bytes follow)
+0$            case 0xDA: // tagged item (4 bytes follow)
+0$            case 0xD9: // tagged item (2 bytes follow)
+0$            case 0xD8: // tagged item (1 bytes follow)
+0$            case 0xD4:
+0$            case 0xD3:
+0$            case 0xD2:
+0$            case 0xD1:
+0$            case 0xD0:
+0$            case 0xCF:
+0$            case 0xCE:
+0$            case 0xCD:
+0$            case 0xCC:
+0$            case 0xCB:
+0$            case 0xCA:
+0$            case 0xC9:
+0$            case 0xC8:
+0$            case 0xC7:
+0$            case 0xC6: // tagged item
+0$
+0$                return get_cbor_object(static_cast<std::size_t>(-1), tag_handler);
+0$            case 0xBF: // map (indefinite length)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
+0$                std::uint64_t len{};
+0$            {
+0$            case 0xBB: // map (eight-byte uint64_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
+0$                std::uint32_t len{};
+0$            {
+0$            case 0xBA: // map (four-byte uint32_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
+0$                std::uint16_t len{};
+0$            {
+0$            case 0xB9: // map (two-byte uint16_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
+0$                std::uint8_t len{};
+0$            {
+0$            case 0xB8: // map (one-byte uint8_t for n follows)
+0$
+0$                return get_cbor_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
+0$            case 0xB7:
+0$            case 0xB6:
+0$            case 0xB5:
+0$            case 0xB4:
+0$            case 0xB3:
+0$            case 0xB2:
+0$            case 0xB1:
+0$            case 0xB0:
+0$            case 0xAF:
+0$            case 0xAE:
+0$            case 0xAD:
+0$            case 0xAC:
+0$            case 0xAB:
+0$            case 0xAA:
+0$            case 0xA9:
+0$            case 0xA8:
+0$            case 0xA7:
+0$            case 0xA6:
+0$            case 0xA5:
+0$            case 0xA4:
+0$            case 0xA3:
+0$            case 0xA2:
+0$            case 0xA1:
+0$            case 0xA0:
+0$            // map (0x00..0x17 pairs of data items follow)
+0$
+0$                return get_cbor_array(static_cast<std::size_t>(-1), tag_handler);
+0$            case 0x9F: // array (indefinite length)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
+0$                std::uint64_t len{};
+0$            {
+0$            case 0x9B: // array (eight-byte uint64_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
+0$                std::uint32_t len{};
+0$            {
+0$            case 0x9A: // array (four-byte uint32_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
+0$                std::uint16_t len{};
+0$            {
+0$            case 0x99: // array (two-byte uint16_t for n follow)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
+0$                std::uint8_t len{};
+0$            {
+0$            case 0x98: // array (one-byte uint8_t for n follows)
+0$
+0$                           conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
+0$                return get_cbor_array(
+0$            case 0x97:
+0$            case 0x96:
+0$            case 0x95:
+0$            case 0x94:
+0$            case 0x93:
+0$            case 0x92:
+0$            case 0x91:
+0$            case 0x90:
+0$            case 0x8F:
+0$            case 0x8E:
+0$            case 0x8D:
+0$            case 0x8C:
+0$            case 0x8B:
+0$            case 0x8A:
+0$            case 0x89:
+0$            case 0x88:
+0$            case 0x87:
+0$            case 0x86:
+0$            case 0x85:
+0$            case 0x84:
+0$            case 0x83:
+0$            case 0x82:
+0$            case 0x81:
+0$            case 0x80:
+0$            // array (0x00..0x17 data items follow)
+0$
+0$            }
+0$                return get_cbor_string(s) && sax->string(s);
+0$                string_t s;
+0$            {
+0$            case 0x7F: // UTF-8 string (indefinite length)
+0$            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
+0$            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
+0$            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
+0$            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
+0$            case 0x77:
+0$            case 0x76:
+0$            case 0x75:
+0$            case 0x74:
+0$            case 0x73:
+0$            case 0x72:
+0$            case 0x71:
+0$            case 0x70:
+0$            case 0x6F:
+0$            case 0x6E:
+0$            case 0x6D:
+0$            case 0x6C:
+0$            case 0x6B:
+0$            case 0x6A:
+0$            case 0x69:
+0$            case 0x68:
+0$            case 0x67:
+0$            case 0x66:
+0$            case 0x65:
+0$            case 0x64:
+0$            case 0x63:
+0$            case 0x62:
+0$            case 0x61:
+0$            case 0x60:
+0$            // UTF-8 string (0x00..0x17 bytes follow)
+0$
+0$            }
+0$                return get_cbor_binary(b) && sax->binary(b);
+0$                binary_t b;
+0$            {
+0$            case 0x5F: // Binary data (indefinite length)
+0$            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
+0$            case 0x5A: // Binary data (four-byte uint32_t for n follow)
+0$            case 0x59: // Binary data (two-byte uint16_t for n follow)
+0$            case 0x58: // Binary data (one-byte uint8_t for n follows)
+0$            case 0x57:
+0$            case 0x56:
+0$            case 0x55:
+0$            case 0x54:
+0$            case 0x53:
+0$            case 0x52:
+0$            case 0x51:
+0$            case 0x50:
+0$            case 0x4F:
+0$            case 0x4E:
+0$            case 0x4D:
+0$            case 0x4C:
+0$            case 0x4B:
+0$            case 0x4A:
+0$            case 0x49:
+0$            case 0x48:
+0$            case 0x47:
+0$            case 0x46:
+0$            case 0x45:
+0$            case 0x44:
+0$            case 0x43:
+0$            case 0x42:
+0$            case 0x41:
+0$            case 0x40:
+0$            // Binary data (0x00..0x17 bytes follow)
+0$
+0$            }
+0$                        - static_cast<number_integer_t>(number));
+0$                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
+0$                std::uint64_t number{};
+0$            {
+0$            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
+0$                std::uint32_t number{};
+0$            {
+0$            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
+0$                std::uint16_t number{};
+0$            {
+0$            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
+0$                std::uint8_t number{};
+0$            {
+0$            case 0x38: // Negative integer (one-byte uint8_t follows)
+0$
+0$                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));
+0$            case 0x37:
+0$            case 0x36:
+0$            case 0x35:
+0$            case 0x34:
+0$            case 0x33:
+0$            case 0x32:
+0$            case 0x31:
+0$            case 0x30:
+0$            case 0x2F:
+0$            case 0x2E:
+0$            case 0x2D:
+0$            case 0x2C:
+0$            case 0x2B:
+0$            case 0x2A:
+0$            case 0x29:
+0$            case 0x28:
+0$            case 0x27:
+0$            case 0x26:
+0$            case 0x25:
+0$            case 0x24:
+0$            case 0x23:
+0$            case 0x22:
+0$            case 0x21:
+0$            case 0x20:
+0$            // Negative integer -1-0x00..-1-0x17 (-1..-24)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
+0$                std::uint64_t number{};
+0$            {
+0$            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
+0$                std::uint32_t number{};
+0$            {
+0$            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
+0$                std::uint16_t number{};
+0$            {
+0$            case 0x19: // Unsigned integer (two-byte uint16_t follows)
+0$
+0$            }
+0$                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
+0$                std::uint8_t number{};
+0$            {
+0$            case 0x18: // Unsigned integer (one-byte uint8_t follows)
+0$
+0$                return sax->number_unsigned(static_cast<number_unsigned_t>(current));
+0$            case 0x17:
+0$            case 0x16:
+0$            case 0x15:
+0$            case 0x14:
+0$            case 0x13:
+0$            case 0x12:
+0$            case 0x11:
+0$            case 0x10:
+0$            case 0x0F:
+0$            case 0x0E:
+0$            case 0x0D:
+0$            case 0x0C:
+0$            case 0x0B:
+0$            case 0x0A:
+0$            case 0x09:
+0$            case 0x08:
+0$            case 0x07:
+0$            case 0x06:
+0$            case 0x05:
+0$            case 0x04:
+0$            case 0x03:
+0$            case 0x02:
+0$            case 0x01:
+0$            case 0x00:
+0$            // Integer 0x00..0x17 (0..23)
+0$
+0$                return unexpect_eof(input_format_t::cbor, "value");
+0$            case char_traits<char_type>::eof():
+0$            // EOF
+0$        {
+0$        switch (get_char ? get() : current)
+0$    {
+0$                             const cbor_tag_handler_t tag_handler)
+0$    bool parse_cbor_internal(const bool get_char,
+0$    */
+0$    @return whether a valid CBOR value was passed to the SAX parser
+0$
+0$    @param[in] tag_handler how CBOR tags should be treated
+0$                         be considered instead (false)
+0$                         input (true) or whether the last read character should
+0$    @param[in] get_char  whether a new character should be retrieved from the
+0$    /*!
+0$
+0$    //////////
+0$    // CBOR //
+0$    //////////
+0$
+0$    }
+0$        return sax->end_array();
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
+0$
+0$        get_number<std::int32_t, true>(input_format_t::bson, document_size);
+0$        std::int32_t document_size{};
+0$    {
+0$    bool parse_bson_array()
+0$    */
+0$    @return whether a valid BSON-array was passed to the SAX parser
+0$    @brief Reads an array from the BSON input and passes it to the SAX-parser.
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            key.clear();
+0$            // get_bson_cstr only appends
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (!is_array && !sax->key(key))
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
+0$            const std::size_t element_type_parse_position = chars_read;
+0$
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
+0$        {
+0$        while (auto element_type = get())
+0$
+0$        string_t key;
+0$    {
+0$    bool parse_bson_element_list(const bool is_array)
+0$    */
+0$    @return whether a valid BSON-object/array was passed to the SAX parser
+0$                        array (@a is_array == true).
+0$                        treated as an object (@a is_array == false), or as an
+0$    @param[in] is_array Determines if the element list being read is to be
+0$
+0$    (true --> array, false --> object).
+0$    indicated with the argument @a is_array which one is expected
+0$    The same binary layout is used for objects and arrays, hence it must be
+0$
+0$    @brief Read a BSON element list (as specified in the BSON-spec)
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                                        parse_error::create(114, element_type_parse_position, concat("Unsupported BSON record type 0x", cr_str), nullptr));
+0$                return sax->parse_error(element_type_parse_position, cr_str,
+0$                const std::string cr_str{cr.data()};
+0$                static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$                std::array<char, 3> cr{{}};
+0$            {
+0$            default: // anything else not supported (yet)
+0$
+0$            }
+0$                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
+0$                std::int64_t value{};
+0$            {
+0$            case 0x12: // int64
+0$
+0$            }
+0$                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
+0$                std::int32_t value{};
+0$            {
+0$            case 0x10: // int32
+0$
+0$            }
+0$                return sax->null();
+0$            {
+0$            case 0x0A: // null
+0$
+0$            }
+0$                return sax->boolean(get() != 0);
+0$            {
+0$            case 0x08: // boolean
+0$
+0$            }
+0$                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
+0$                binary_t value;
+0$                std::int32_t len{};
+0$            {
+0$            case 0x05: // binary
+0$
+0$            }
+0$                return parse_bson_array();
+0$            {
+0$            case 0x04: // array
+0$
+0$            }
+0$                return parse_bson_internal();
+0$            {
+0$            case 0x03: // object
+0$
+0$            }
+0$                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
+0$                string_t value;
+0$                std::int32_t len{};
+0$            {
+0$            case 0x02: // string
+0$
+0$            }
+0$                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
+0$                double number{};
+0$            {
+0$            case 0x01: // double
+0$        {
+0$        switch (element_type)
+0$    {
+0$                                     const std::size_t element_type_parse_position)
+0$    bool parse_bson_element_internal(const char_int_type element_type,
+0$    */
+0$    @return whether a valid BSON-object/array was passed to the SAX parser
+0$             Unsupported BSON record type 0x...
+0$             @a element_type will give rise to a parse_error.114:
+0$    @warning Not all BSON element types are supported yet. An unsupported
+0$               where the `element_type` was read.
+0$    @param[in] element_type_parse_position The position in the input stream,
+0$    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
+0$    @brief Read a BSON document element of the given @a element_type.
+0$    /*!
+0$
+0$    }
+0$        return get_binary(input_format_t::bson, len, result);
+0$
+0$        result.set_subtype(subtype);
+0$        get_number<std::uint8_t>(input_format_t::bson, subtype);
+0$        std::uint8_t subtype{};
+0$        // All BSON binary values have a subtype
+0$
+0$        }
+0$                                    exception_message(input_format_t::bson, concat("byte array length cannot be negative, is ", std::to_string(len)), "binary"), nullptr));
+0$            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$            auto last_token = get_token_string();
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(len < 0))
+0$    {
+0$    bool get_bson_binary(const NumberType len, binary_t& result)
+0$    template<typename NumberType>
+0$    */
+0$    @return `true` if the byte array was successfully parsed
+0$    @pre len >= 0
+0$    @tparam NumberType The type of the length @a len
+0$                            array is to be stored.
+0$    @param[in,out] result  A reference to the binary variable where the read
+0$    @param[in] len  The length of the byte array to be read.
+0$    @brief Parses a byte array input of length @a len from the BSON input.
+0$    /*!
+0$
+0$    }
+0$        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != char_traits<char_type>::eof();
+0$
+0$        }
+0$                                    exception_message(input_format_t::bson, concat("string length must be at least 1, is ", std::to_string(len)), "string"), nullptr));
+0$            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
+0$            auto last_token = get_token_string();
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(len < 1))
+0$    {
+0$    bool get_bson_string(const NumberType len, string_t& result)
+0$    template<typename NumberType>
+0$    */
+0$    @return `true` if the string was successfully parsed
+0$    @pre len >= 1
+0$    @tparam NumberType The type of the length @a len
+0$                            string is to be stored.
+0$    @param[in,out] result  A reference to the string variable where the read
+0$                    string to be read.
+0$    @param[in] len  The length (including the zero-byte at the end) of the
+0$           input.
+0$    @brief Parses a zero-terminated string of length @a len from the BSON
+0$    /*!
+0$
+0$    }
+0$        }
+0$            *out++ = static_cast<typename string_t::value_type>(current);
+0$            }
+0$                return true;
+0$            {
+0$            if (current == 0x00)
+0$            }
+0$                return false;
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
+0$            get();
+0$        {
+0$        while (true)
+0$        auto out = std::back_inserter(result);
+0$    {
+0$    bool get_bson_cstr(string_t& result)
+0$    */
+0$             encountered before the EOF; false` indicates an unexpected EOF.
+0$    @return `true` if the \x00-byte indicating the end of the string was
+0$                            string is to be stored.
+0$    @param[in,out] result  A reference to the string variable where the read
+0$    @brief Parses a C-style string from the BSON input.
+0$    /*!
+0$
+0$    }
+0$        return sax->end_object();
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
+0$
+0$        }
+0$            return false;
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
+0$
+0$        get_number<std::int32_t, true>(input_format_t::bson, document_size);
+0$        std::int32_t document_size{};
+0$    {
+0$    bool parse_bson_internal()
+0$    */
+0$    @return whether a valid BSON-value was passed to the SAX parser
+0$    @brief Reads in a BSON-object and passes it to the SAX-parser.
+0$    /*!
+0$
+0$    //////////
+0$    // BSON //
+0$    //////////
+0$  private:
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            }
+0$                                        exception_message(input_format, concat("expected end of input; last byte: 0x", get_token_string()), "value"), nullptr));
+0$                return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(current != char_traits<char_type>::eof()))
+0$
+0$            }
+0$                get();
+0$            {
+0$            else
+0$            }
+0$                get_ignore_noop();
+0$            {
+0$            if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
+0$        {
+0$        if (result && strict)
+0$        // strict mode: next byte must be EOF
+0$
+0$        }
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$            default:            // LCOV_EXCL_LINE
+0$            case input_format_t::json: // LCOV_EXCL_LINE
+0$
+0$                break;
+0$                result = parse_ubjson_internal();
+0$            case input_format_t::bjdata:
+0$            case input_format_t::ubjson:
+0$
+0$                break;
+0$                result = parse_msgpack_internal();
+0$            case input_format_t::msgpack:
+0$
+0$                break;
+0$                result = parse_cbor_internal(true, tag_handler);
+0$            case input_format_t::cbor:
+0$
+0$                break;
+0$                result = parse_bson_internal();
+0$            case input_format_t::bson:
+0$        {
+0$        switch (format)
+0$
+0$        bool result = false;
+0$        sax = sax_;
+0$    {
+0$                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
+0$                   const bool strict = true,
+0$                   json_sax_t* sax_,
+0$    bool sax_parse(const input_format_t format,
+0$    JSON_HEDLEY_NON_NULL(3)
+0$    */
+0$    @return whether parsing was successful
+0$
+0$    @param[in] tag_handler  how to treat CBOR tags
+0$    @param[in] strict  whether to expect the input to be consumed completed
+0$    @param[in] sax_    a SAX event processor
+0$    @param[in] format  the binary format to parse
+0$    /*!
+0$
+0$    ~binary_reader() = default;
+0$    binary_reader& operator=(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    binary_reader& operator=(const binary_reader&) = delete;
+0$    binary_reader(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    binary_reader(const binary_reader&) = delete;
+0$    // make class move-only
+0$
+0$    }
+0$        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
+0$    {
+0$    explicit binary_reader(InputAdapterType&& adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
+0$    */
+0$    @param[in] adapter  input adapter to read from
+0$
+0$    @brief create a binary reader
+0$    /*!
+0$  public:
+0$
+0$    using char_int_type = typename char_traits<char_type>::int_type;
+0$    using char_type = typename InputAdapterType::char_type;
+0$    using json_sax_t = SAX;
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0${
+0$class binary_reader
+0$template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
+0$*/
+0$@brief deserialization of CBOR, MessagePack, and UBJSON values
+0$/*!
+0$
+0$///////////////////
+0$// binary reader //
+0$///////////////////
+0$
+0$}
+0$    return *reinterpret_cast<char*>(&num) == 1;
+0${
+0$static inline bool little_endianness(int num = 1) noexcept
+0$*/
+0$@note from https://stackoverflow.com/a/1001328/266378
+0$
+0$@return true if and only if system's byte order is little endian
+0$
+0$@brief determine system byte order
+0$/*!
+0$
+0$};
+0$    store    ///< store tags as binary type
+0$    ignore,  ///< ignore tags
+0$    error,   ///< throw a parse_error exception in case of a tag
+0${
+0$enum class cbor_tag_handler_t
+0$/// how to treat CBOR tags
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$        "std::string&, const exception&)");
+0$        "Missing/invalid function: bool parse_error(std::size_t, const "
+0$        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
+0$    static_assert(
+0$                  "Missing/invalid function: bool end_array()");
+0$    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
+0$                  "Missing/invalid function: bool start_array(std::size_t)");
+0$    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
+0$                  "Missing/invalid function: bool end_object()");
+0$    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
+0$                  "Missing/invalid function: bool key(string_t&)");
+0$    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
+0$                  "Missing/invalid function: bool start_object(std::size_t)");
+0$    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
+0$        "Missing/invalid function: bool binary(binary_t&)");
+0$        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
+0$    static_assert(
+0$        "Missing/invalid function: bool string(string_t&)");
+0$        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
+0$    static_assert(
+0$                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
+0$                  number_float_t, string_t>::value,
+0$    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
+0$        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
+0$        number_unsigned_t>::value,
+0$        is_detected_exact<bool, number_unsigned_function_t, SAX,
+0$    static_assert(
+0$        "Missing/invalid function: bool number_integer(number_integer_t)");
+0$        number_integer_t>::value,
+0$        is_detected_exact<bool, number_integer_function_t, SAX,
+0$    static_assert(
+0$                  "Missing/invalid function: bool boolean(bool)");
+0$    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
+0$                  "Missing/invalid function: bool boolean(bool)");
+0$    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
+0$                  "Missing/invalid function: bool null()");
+0$    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
+0$  public:
+0$
+0$    using exception_t = typename BasicJsonType::exception;
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$
+0$                  "BasicJsonType must be of type basic_json<...>");
+0$    static_assert(is_basic_json<BasicJsonType>::value,
+0$  private:
+0${
+0$struct is_sax_static_asserts
+0$template<typename SAX, typename BasicJsonType>
+0$
+0$};
+0$        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
+0$        is_detected_exact<bool, end_array_function_t, SAX>::value &&
+0$        is_detected_exact<bool, start_array_function_t, SAX>::value &&
+0$        is_detected_exact<bool, end_object_function_t, SAX>::value &&
+0$        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
+0$        is_detected_exact<bool, start_object_function_t, SAX>::value &&
+0$        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
+0$        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
+0$        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
+0$        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
+0$        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
+0$        is_detected_exact<bool, boolean_function_t, SAX>::value &&
+0$        is_detected_exact<bool, null_function_t, SAX>::value &&
+0$    static constexpr bool value =
+0$  public:
+0$
+0$    using exception_t = typename BasicJsonType::exception;
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$
+0$                  "BasicJsonType must be of type basic_json<...>");
+0$    static_assert(is_basic_json<BasicJsonType>::value,
+0$  private:
+0${
+0$struct is_sax
+0$template<typename SAX, typename BasicJsonType>
+0$
+0$        std::declval<const Exception&>()));
+0$        std::declval<std::size_t>(), std::declval<const std::string&>(),
+0$using parse_error_function_t = decltype(std::declval<T&>().parse_error(
+0$template<typename T, typename Exception>
+0$
+0$using end_array_function_t = decltype(std::declval<T&>().end_array());
+0$template<typename T>
+0$
+0$    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));
+0$using start_array_function_t =
+0$template<typename T>
+0$
+0$using end_object_function_t = decltype(std::declval<T&>().end_object());
+0$template<typename T>
+0$
+0$    decltype(std::declval<T&>().key(std::declval<String&>()));
+0$using key_function_t =
+0$template<typename T, typename String>
+0$
+0$    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));
+0$using start_object_function_t =
+0$template<typename T>
+0$
+0$    decltype(std::declval<T&>().binary(std::declval<Binary&>()));
+0$using binary_function_t =
+0$template<typename T, typename Binary>
+0$
+0$    decltype(std::declval<T&>().string(std::declval<String&>()));
+0$using string_function_t =
+0$template<typename T, typename String>
+0$
+0$                                    std::declval<Float>(), std::declval<const String&>()));
+0$using number_float_function_t = decltype(std::declval<T&>().number_float(
+0$template<typename T, typename Float, typename String>
+0$
+0$    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));
+0$using number_unsigned_function_t =
+0$template<typename T, typename Unsigned>
+0$
+0$    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));
+0$using number_integer_function_t =
+0$template<typename T, typename Integer>
+0$
+0$    decltype(std::declval<T&>().boolean(std::declval<bool>()));
+0$using boolean_function_t =
+0$template<typename T>
+0$
+0$using null_function_t = decltype(std::declval<T&>().null());
+0$template<typename T>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/meta/detected.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <string> // string
+0$#include <utility> // declval
+0$#include <cstdint> // size_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/is_sax.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    const char_int_type decimal_point_char = '.';
+0$    /// the decimal point
+0$
+0$    number_float_t value_float = 0;
+0$    number_unsigned_t value_unsigned = 0;
+0$    number_integer_t value_integer = 0;
+0$    // number values
+0$
+0$    const char* error_message = "";
+0$    /// a description of occurred lexer errors
+0$
+0$    string_t token_buffer {};
+0$    /// buffer for variable-length tokens (numbers, strings)
+0$
+0$    std::vector<char_type> token_string {};
+0$    /// raw input token string (for error messages)
+0$
+0$    position_t position {};
+0$    /// the start position of the current token
+0$
+0$    bool next_unget = false;
+0$    /// whether the next get() call should just return current
+0$
+0$    char_int_type current = char_traits<char_type>::eof();
+0$    /// the current character
+0$
+0$    const bool ignore_comments = false;
+0$    /// whether comments should be ignored (true) or signaled as errors (false)
+0$
+0$    InputAdapterType ia;
+0$    /// input adapter
+0$  private:
+0$
+0$    }
+0$        }
+0$                return token_type::parse_error;
+0$                error_message = "invalid literal";
+0$            default:
+0$            // error
+0$
+0$                return token_type::end_of_input;
+0$            case char_traits<char_type>::eof():
+0$            case '\0':
+0$            // string literals)
+0$            // end of input (the null byte is needed when parsing from
+0$
+0$                return scan_number();
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$            case '-':
+0$            // number
+0$
+0$                return scan_string();
+0$            case '\"':
+0$            // string
+0$
+0$            }
+0$                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
+0$                std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};
+0$            {
+0$            case 'n':
+0$            }
+0$                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
+0$                std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};
+0$            {
+0$            case 'f':
+0$            }
+0$                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
+0$                std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};
+0$            {
+0$            case 't':
+0$            // literals
+0$
+0$                return token_type::value_separator;
+0$            case ',':
+0$                return token_type::name_separator;
+0$            case ':':
+0$                return token_type::end_object;
+0$            case '}':
+0$                return token_type::begin_object;
+0$            case '{':
+0$                return token_type::end_array;
+0$            case ']':
+0$                return token_type::begin_array;
+0$            case '[':
+0$            // structural characters
+0$        {
+0$        switch (current)
+0$
+0$        }
+0$            skip_whitespace();
+0$            // skip following whitespace
+0$
+0$            }
+0$                return token_type::parse_error;
+0$            {
+0$            if (!scan_comment())
+0$        {
+0$        while (ignore_comments && current == '/')
+0$        // ignore comments
+0$
+0$        skip_whitespace();
+0$        // read next character and ignore whitespace
+0$
+0$        }
+0$            return token_type::parse_error;
+0$            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
+0$        {
+0$        if (position.chars_read_total == 0 && !skip_bom())
+0$        // initially, skip the BOM
+0$    {
+0$    token_type scan()
+0$
+0$    }
+0$        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
+0$        }
+0$            get();
+0$        {
+0$        do
+0$    {
+0$    void skip_whitespace()
+0$
+0$    }
+0$        return true;
+0$        unget();
+0$        // process is later
+0$        // the first character is not the beginning of the BOM; unget it to
+0$
+0$        }
+0$            return get() == 0xBB && get() == 0xBF;
+0$            // check if we completely parse the BOM
+0$        {
+0$        if (get() == 0xEF)
+0$    {
+0$    bool skip_bom()
+0$    */
+0$    @return true iff there is no BOM or the correct BOM has been skipped
+0$    @brief skip the UTF-8 byte order mark
+0$    /*!
+0$
+0$    /////////////////////
+0$    // actual scanner
+0$    /////////////////////
+0$
+0$    }
+0$        return error_message;
+0$    {
+0$    constexpr const char* get_error_message() const noexcept
+0$    JSON_HEDLEY_RETURNS_NON_NULL
+0$    /// return syntax error message
+0$
+0$    }
+0$        return result;
+0$
+0$        }
+0$            }
+0$                result.push_back(static_cast<std::string::value_type>(c));
+0$                // add character as is
+0$            {
+0$            else
+0$            }
+0$                result += cs.data();
+0$                static_cast<void>((std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$                std::array<char, 9> cs{{}};
+0$                // escape control characters
+0$            {
+0$            if (static_cast<unsigned char>(c) <= '\x1F')
+0$        {
+0$        for (const auto c : token_string)
+0$        std::string result;
+0$        // escape control characters
+0$    {
+0$    std::string get_token_string() const
+0$    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
+0$    /// (an arbitrary value that is not a valid char value, often -1), because
+0$    /// return the last read token (for errors only).  Will never contain EOF
+0$
+0$    }
+0$        return position;
+0$    {
+0$    constexpr position_t get_position() const noexcept
+0$    /// return position of last read token
+0$
+0$    /////////////////////
+0$    // diagnostics
+0$    /////////////////////
+0$
+0$    }
+0$        return token_buffer;
+0$    {
+0$    string_t& get_string()
+0$    /// return current string value (implicitly resets the token; useful only once)
+0$
+0$    }
+0$        return value_float;
+0$    {
+0$    constexpr number_float_t get_number_float() const noexcept
+0$    /// return floating-point value
+0$
+0$    }
+0$        return value_unsigned;
+0$    {
+0$    constexpr number_unsigned_t get_number_unsigned() const noexcept
+0$    /// return unsigned integer value
+0$
+0$    }
+0$        return value_integer;
+0$    {
+0$    constexpr number_integer_t get_number_integer() const noexcept
+0$    /// return integer value
+0$
+0$    /////////////////////
+0$    // value getters
+0$    /////////////////////
+0$  public:
+0$
+0$    }
+0$        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
+0$    {
+0$    void add(char_int_type c)
+0$    /// add a character to token_buffer
+0$
+0$    }
+0$        }
+0$            token_string.pop_back();
+0$            JSON_ASSERT(!token_string.empty());
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
+0$
+0$        }
+0$            --position.chars_read_current_line;
+0$        {
+0$        else
+0$        }
+0$            }
+0$                --position.lines_read;
+0$            {
+0$            if (position.lines_read > 0)
+0$        {
+0$        if (position.chars_read_current_line == 0)
+0$        // in case we "unget" a newline, we have to also decrement the lines_read
+0$
+0$        --position.chars_read_total;
+0$
+0$        next_unget = true;
+0$    {
+0$    void unget()
+0$    */
+0$    behave as if the unget character is read again.
+0$    chars_read_current_line, and token_string. The next call to get() will
+0$    changed - we just simulate ungetting by modifying chars_read_total,
+0$    We implement unget by setting variable next_unget to true. The input is not
+0$
+0$    @brief unget current character (read it again on next get)
+0$    /*!
+0$
+0$    }
+0$        return current;
+0$
+0$        }
+0$            position.chars_read_current_line = 0;
+0$            ++position.lines_read;
+0$        {
+0$        if (current == '\n')
+0$
+0$        }
+0$            token_string.push_back(char_traits<char_type>::to_char_type(current));
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
+0$
+0$        }
+0$            current = ia.get_character();
+0$        {
+0$        else
+0$        }
+0$            next_unget = false;
+0$            // just reset the next_unget variable and work with current
+0$        {
+0$        if (next_unget)
+0$
+0$        ++position.chars_read_current_line;
+0$        ++position.chars_read_total;
+0$    {
+0$    char_int_type get()
+0$    */
+0$    @return character read from the input
+0$
+0$    for use in error messages.
+0$    `char_traits<char>::eof()` in that case.  Stores the scanned characters
+0$    not throw in case the input reached EOF, but returns a
+0$    This function provides the interface to the used input adapter. It does
+0$
+0$    @brief get next character from the input
+0$    /*
+0$
+0$    }
+0$        token_string.push_back(char_traits<char_type>::to_char_type(current));
+0$        token_string.clear();
+0$        token_buffer.clear();
+0$    {
+0$    void reset() noexcept
+0$    /// reset token_buffer; current character is beginning of token
+0$
+0$    /////////////////////
+0$    // input management
+0$    /////////////////////
+0$
+0$    }
+0$        return return_type;
+0$        }
+0$            }
+0$                return token_type::parse_error;
+0$                error_message = "invalid literal";
+0$            {
+0$            if (JSON_HEDLEY_UNLIKELY(char_traits<char_type>::to_char_type(get()) != literal_text[i]))
+0$        {
+0$        for (std::size_t i = 1; i < length; ++i)
+0$        JSON_ASSERT(char_traits<char_type>::to_char_type(current) == literal_text[0]);
+0$    {
+0$                            token_type return_type)
+0$    token_type scan_literal(const char_type* literal_text, const std::size_t length,
+0$    JSON_HEDLEY_NON_NULL(2)
+0$    */
+0$    @param[in] return_type   the token type to return on success
+0$    @param[in] length        the length of the passed literal text
+0$    @param[in] literal_text  the literal text to expect
+0$    /*!
+0$
+0$    }
+0$        return token_type::value_float;
+0$
+0$        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
+0$        // we checked the number format before
+0$
+0$        strtof(value_float, token_buffer.data(), &endptr);
+0$        // integer conversion above failed
+0$        // this code is reached if we parse a floating-point number or if an
+0$
+0$        }
+0$            }
+0$                }
+0$                    return token_type::value_integer;
+0$                {
+0$                if (value_integer == x)
+0$                value_integer = static_cast<number_integer_t>(x);
+0$            {
+0$            if (errno == 0)
+0$
+0$            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
+0$            // we checked the number format before
+0$
+0$            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);
+0$        {
+0$        else if (number_type == token_type::value_integer)
+0$        }
+0$            }
+0$                }
+0$                    return token_type::value_unsigned;
+0$                {
+0$                if (value_unsigned == x)
+0$                value_unsigned = static_cast<number_unsigned_t>(x);
+0$            {
+0$            if (errno == 0)
+0$
+0$            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
+0$            // we checked the number format before
+0$
+0$            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);
+0$        {
+0$        if (number_type == token_type::value_unsigned)
+0$        // try to parse integers first and fall back to floats
+0$
+0$        errno = 0;
+0$        char* endptr = nullptr; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$
+0$        unget();
+0$        // we are done scanning a number)
+0$        // unget the character after the number (we only read it to know that
+0$scan_number_done:
+0$
+0$        }
+0$                goto scan_number_done;
+0$            default:
+0$
+0$            }
+0$                goto scan_number_any2;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        // we just parsed a number after the exponent or exponent sign
+0$scan_number_any2:
+0$
+0$        }
+0$            }
+0$                return token_type::parse_error;
+0$                error_message = "invalid number; expected digit after exponent sign";
+0$            {
+0$            default:
+0$
+0$            }
+0$                goto scan_number_any2;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        // we just parsed an exponent sign
+0$scan_number_sign:
+0$
+0$        }
+0$            }
+0$                return token_type::parse_error;
+0$                    "invalid number; expected '+', '-', or digit after exponent";
+0$                error_message =
+0$            {
+0$            default:
+0$
+0$            }
+0$                goto scan_number_any2;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$
+0$            }
+0$                goto scan_number_sign;
+0$                add(current);
+0$            {
+0$            case '-':
+0$            case '+':
+0$        {
+0$        switch (get())
+0$        number_type = token_type::value_float;
+0$        // we just parsed an exponent
+0$scan_number_exponent:
+0$
+0$        }
+0$                goto scan_number_done;
+0$            default:
+0$
+0$            }
+0$                goto scan_number_exponent;
+0$                add(current);
+0$            {
+0$            case 'E':
+0$            case 'e':
+0$
+0$            }
+0$                goto scan_number_decimal2;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        // we just parsed at least one number after a decimal point
+0$scan_number_decimal2:
+0$
+0$        }
+0$            }
+0$                return token_type::parse_error;
+0$                error_message = "invalid number; expected digit after '.'";
+0$            {
+0$            default:
+0$
+0$            }
+0$                goto scan_number_decimal2;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        number_type = token_type::value_float;
+0$        // state: we just parsed a decimal point
+0$scan_number_decimal1:
+0$
+0$        }
+0$                goto scan_number_done;
+0$            default:
+0$
+0$            }
+0$                goto scan_number_exponent;
+0$                add(current);
+0$            {
+0$            case 'E':
+0$            case 'e':
+0$
+0$            }
+0$                goto scan_number_decimal1;
+0$                add(decimal_point_char);
+0$            {
+0$            case '.':
+0$
+0$            }
+0$                goto scan_number_any1;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
+0$scan_number_any1:
+0$
+0$        }
+0$                goto scan_number_done;
+0$            default:
+0$
+0$            }
+0$                goto scan_number_exponent;
+0$                add(current);
+0$            {
+0$            case 'E':
+0$            case 'e':
+0$
+0$            }
+0$                goto scan_number_decimal1;
+0$                add(decimal_point_char);
+0$            {
+0$            case '.':
+0$        {
+0$        switch (get())
+0$        // state: we just parse a zero (maybe with a leading minus sign)
+0$scan_number_zero:
+0$
+0$        }
+0$            }
+0$                return token_type::parse_error;
+0$                error_message = "invalid number; expected digit after '-'";
+0$            {
+0$            default:
+0$
+0$            }
+0$                goto scan_number_any1;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$
+0$            }
+0$                goto scan_number_zero;
+0$                add(current);
+0$            {
+0$            case '0':
+0$        {
+0$        switch (get())
+0$        number_type = token_type::value_integer;
+0$        // state: we just parsed a leading minus sign
+0$scan_number_minus:
+0$
+0$        }
+0$                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$            default:            // LCOV_EXCL_LINE
+0$            // all other characters are rejected outside scan_number()
+0$
+0$            }
+0$                goto scan_number_any1;
+0$                add(current);
+0$            {
+0$            case '9':
+0$            case '8':
+0$            case '7':
+0$            case '6':
+0$            case '5':
+0$            case '4':
+0$            case '3':
+0$            case '2':
+0$            case '1':
+0$
+0$            }
+0$                goto scan_number_zero;
+0$                add(current);
+0$            {
+0$            case '0':
+0$
+0$            }
+0$                goto scan_number_minus;
+0$                add(current);
+0$            {
+0$            case '-':
+0$        {
+0$        switch (current)
+0$        // state (init): we just found out we need to scan a number
+0$
+0$        token_type number_type = token_type::value_unsigned;
+0$        // changed if minus sign, decimal point or exponent is read
+0$        // the type of the parsed number; initially set to unsigned; will be
+0$
+0$        reset();
+0$        // reset token_buffer to store the number's bytes
+0$    {
+0$    token_type scan_number()  // lgtm [cpp/use-of-goto]
+0$    */
+0$          locale-dependent converters.
+0$          locale's decimal point is used instead of `.` to work with the
+0$    @note The scanner is independent of the current locale. Internally, the
+0$
+0$            token_type::parse_error otherwise
+0$            token_type::value_float if number could be successfully scanned,
+0$    @return token_type::value_unsigned, token_type::value_integer, or
+0$
+0$    floating-point number.
+0$    then converted to a signed integer, an unsigned integer, or a
+0$    During scanning, the read bytes are stored in token_buffer. This string is
+0$
+0$    the function is guaranteed to terminate.
+0$    contains cycles, but any cycle can be left when EOF is read. Therefore,
+0$    "scan_number_") and `goto` statements between them. The state machine
+0$    The state machine is realized with one label per state (prefixed with
+0$
+0$    any2     | any2     | any2     | done     | done    | done    | done     | done
+0$    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
+0$    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
+0$    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
+0$    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
+0$    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
+0$    zero     | done     | done     | exponent | done    | done    | decimal1 | done
+0$    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
+0$    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
+0$    ---------|----------|----------|----------|---------|---------|----------|-----------
+0$    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
+0$
+0$    table below, "anything" means any character but the ones listed before.
+0$    accepts the number. State "error" is a trap state to model errors. In the
+0$    input is read and used to determined the next state. Only state "done"
+0$    from the grammar described in RFC 8259. Starting in state "init", the
+0$    The function is realized with a deterministic finite state machine derived
+0$
+0$    This function scans a string according to Sect. 6 of RFC 8259.
+0$
+0$    @brief scan a number literal
+0$    /*!
+0$
+0$    }
+0$        f = std::strtold(str, endptr);
+0$    {
+0$    static void strtof(long double& f, const char* str, char** endptr) noexcept
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        f = std::strtod(str, endptr);
+0$    {
+0$    static void strtof(double& f, const char* str, char** endptr) noexcept
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        f = std::strtof(str, endptr);
+0$    {
+0$    static void strtof(float& f, const char* str, char** endptr) noexcept
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    }
+0$        }
+0$            }
+0$                return false;
+0$                error_message = "invalid comment; expecting '/' or '*' after '/'";
+0$            {
+0$            default:
+0$            // unexpected character after reading '/'
+0$
+0$            }
+0$                }
+0$                    }
+0$                            continue;
+0$                        default:
+0$
+0$                        }
+0$                            }
+0$                                }
+0$                                    continue;
+0$                                    unget();
+0$                                {
+0$                                default:
+0$
+0$                                    return true;
+0$                                case '/':
+0$                            {
+0$                            switch (get())
+0$                        {
+0$                        case '*':
+0$
+0$                        }
+0$                            return false;
+0$                            error_message = "invalid comment; missing closing '*/'";
+0$                        {
+0$                        case '\0':
+0$                        case char_traits<char_type>::eof():
+0$                    {
+0$                    switch (get())
+0$                {
+0$                while (true)
+0$            {
+0$            case '*':
+0$            // multi-line comments skip input until */ is read
+0$
+0$            }
+0$                }
+0$                    }
+0$                            break;
+0$                        default:
+0$
+0$                            return true;
+0$                        case '\0':
+0$                        case char_traits<char_type>::eof():
+0$                        case '\r':
+0$                        case '\n':
+0$                    {
+0$                    switch (get())
+0$                {
+0$                while (true)
+0$            {
+0$            case '/':
+0$            // single-line comments skip input until a newline or EOF is read
+0$        {
+0$        switch (get())
+0$    {
+0$    bool scan_comment()
+0$     */
+0$     * @return whether comment could be scanned successfully
+0$     * @brief scan a comment
+0$    /*!
+0$
+0$    }
+0$        }
+0$            }
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: ill-formed UTF-8 byte";
+0$                {
+0$                default:
+0$                // remaining bytes (80..C1 and F5..FF) are ill-formed
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
+0$                {
+0$                case 0xF4:
+0$                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
+0$                {
+0$                case 0xF3:
+0$                case 0xF2:
+0$                case 0xF1:
+0$                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
+0$                {
+0$                case 0xF0:
+0$                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
+0$                {
+0$                case 0xED:
+0$                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
+0$                {
+0$                case 0xEF:
+0$                case 0xEE:
+0$                case 0xEC:
+0$                case 0xEB:
+0$                case 0xEA:
+0$                case 0xE9:
+0$                case 0xE8:
+0$                case 0xE7:
+0$                case 0xE6:
+0$                case 0xE5:
+0$                case 0xE4:
+0$                case 0xE3:
+0$                case 0xE2:
+0$                case 0xE1:
+0$                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
+0$                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
+0$                {
+0$                case 0xE0:
+0$                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        return token_type::parse_error;
+0$                    {
+0$                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
+0$                {
+0$                case 0xDF:
+0$                case 0xDE:
+0$                case 0xDD:
+0$                case 0xDC:
+0$                case 0xDB:
+0$                case 0xDA:
+0$                case 0xD9:
+0$                case 0xD8:
+0$                case 0xD7:
+0$                case 0xD6:
+0$                case 0xD5:
+0$                case 0xD4:
+0$                case 0xD3:
+0$                case 0xD2:
+0$                case 0xD1:
+0$                case 0xD0:
+0$                case 0xCF:
+0$                case 0xCE:
+0$                case 0xCD:
+0$                case 0xCC:
+0$                case 0xCB:
+0$                case 0xCA:
+0$                case 0xC9:
+0$                case 0xC8:
+0$                case 0xC7:
+0$                case 0xC6:
+0$                case 0xC5:
+0$                case 0xC4:
+0$                case 0xC3:
+0$                case 0xC2:
+0$                // U+0080..U+07FF: bytes C2..DF 80..BF
+0$
+0$                }
+0$                    break;
+0$                    add(current);
+0$                {
+0$                case 0x7F:
+0$                case 0x7E:
+0$                case 0x7D:
+0$                case 0x7C:
+0$                case 0x7B:
+0$                case 0x7A:
+0$                case 0x79:
+0$                case 0x78:
+0$                case 0x77:
+0$                case 0x76:
+0$                case 0x75:
+0$                case 0x74:
+0$                case 0x73:
+0$                case 0x72:
+0$                case 0x71:
+0$                case 0x70:
+0$                case 0x6F:
+0$                case 0x6E:
+0$                case 0x6D:
+0$                case 0x6C:
+0$                case 0x6B:
+0$                case 0x6A:
+0$                case 0x69:
+0$                case 0x68:
+0$                case 0x67:
+0$                case 0x66:
+0$                case 0x65:
+0$                case 0x64:
+0$                case 0x63:
+0$                case 0x62:
+0$                case 0x61:
+0$                case 0x60:
+0$                case 0x5F:
+0$                case 0x5E:
+0$                case 0x5D:
+0$                case 0x5B:
+0$                case 0x5A:
+0$                case 0x59:
+0$                case 0x58:
+0$                case 0x57:
+0$                case 0x56:
+0$                case 0x55:
+0$                case 0x54:
+0$                case 0x53:
+0$                case 0x52:
+0$                case 0x51:
+0$                case 0x50:
+0$                case 0x4F:
+0$                case 0x4E:
+0$                case 0x4D:
+0$                case 0x4C:
+0$                case 0x4B:
+0$                case 0x4A:
+0$                case 0x49:
+0$                case 0x48:
+0$                case 0x47:
+0$                case 0x46:
+0$                case 0x45:
+0$                case 0x44:
+0$                case 0x43:
+0$                case 0x42:
+0$                case 0x41:
+0$                case 0x40:
+0$                case 0x3F:
+0$                case 0x3E:
+0$                case 0x3D:
+0$                case 0x3C:
+0$                case 0x3B:
+0$                case 0x3A:
+0$                case 0x39:
+0$                case 0x38:
+0$                case 0x37:
+0$                case 0x36:
+0$                case 0x35:
+0$                case 0x34:
+0$                case 0x33:
+0$                case 0x32:
+0$                case 0x31:
+0$                case 0x30:
+0$                case 0x2F:
+0$                case 0x2E:
+0$                case 0x2D:
+0$                case 0x2C:
+0$                case 0x2B:
+0$                case 0x2A:
+0$                case 0x29:
+0$                case 0x28:
+0$                case 0x27:
+0$                case 0x26:
+0$                case 0x25:
+0$                case 0x24:
+0$                case 0x23:
+0$                case 0x21:
+0$                case 0x20:
+0$                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
+0$                {
+0$                case 0x1F:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
+0$                {
+0$                case 0x1E:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
+0$                {
+0$                case 0x1D:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
+0$                {
+0$                case 0x1C:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
+0$                {
+0$                case 0x1B:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
+0$                {
+0$                case 0x1A:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
+0$                {
+0$                case 0x19:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
+0$                {
+0$                case 0x18:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
+0$                {
+0$                case 0x17:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
+0$                {
+0$                case 0x16:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
+0$                {
+0$                case 0x15:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
+0$                {
+0$                case 0x14:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
+0$                {
+0$                case 0x13:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
+0$                {
+0$                case 0x12:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
+0$                {
+0$                case 0x11:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
+0$                {
+0$                case 0x10:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
+0$                {
+0$                case 0x0F:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
+0$                {
+0$                case 0x0E:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
+0$                {
+0$                case 0x0D:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
+0$                {
+0$                case 0x0C:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
+0$                {
+0$                case 0x0B:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
+0$                {
+0$                case 0x0A:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
+0$                {
+0$                case 0x09:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
+0$                {
+0$                case 0x08:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
+0$                {
+0$                case 0x07:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
+0$                {
+0$                case 0x06:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
+0$                {
+0$                case 0x05:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
+0$                {
+0$                case 0x04:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
+0$                {
+0$                case 0x03:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
+0$                {
+0$                case 0x02:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
+0$                {
+0$                case 0x01:
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
+0$                {
+0$                case 0x00:
+0$                // invalid control characters
+0$
+0$                }
+0$                    break;
+0$
+0$                    }
+0$                            return token_type::parse_error;
+0$                            error_message = "invalid string: forbidden character after backslash";
+0$                        default:
+0$                        // other characters after escape
+0$
+0$                        }
+0$                            break;
+0$
+0$                            }
+0$                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
+0$                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+0$                            {
+0$                            else
+0$                            }
+0$                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
+0$                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
+0$                            {
+0$                            else if (codepoint <= 0xFFFF)
+0$                            }
+0$                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
+0$                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
+0$                                // 2-byte characters: 110xxxxx 10xxxxxx
+0$                            {
+0$                            else if (codepoint <= 0x7FF)
+0$                            }
+0$                                add(static_cast<char_int_type>(codepoint));
+0$                                // 1-byte characters: 0xxxxxxx (ASCII)
+0$                            {
+0$                            if (codepoint < 0x80)
+0$                            // translate codepoint into bytes
+0$
+0$                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);
+0$                            // result of the above calculation yields a proper codepoint
+0$
+0$                            }
+0$                                }
+0$                                    return token_type::parse_error;
+0$                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
+0$                                {
+0$                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
+0$                            {
+0$                            else
+0$                            }
+0$                                }
+0$                                    return token_type::parse_error;
+0$                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
+0$                                {
+0$                                else
+0$                                }
+0$                                    }
+0$                                        return token_type::parse_error;
+0$                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
+0$                                    {
+0$                                    else
+0$                                    }
+0$                                                        - 0x35FDC00u);
+0$                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
+0$                                                        // in the result, so we have to subtract with:
+0$                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
+0$                                                        + static_cast<unsigned int>(codepoint2)
+0$                                                        // low surrogate occupies the least significant 15 bits
+0$                                                        (static_cast<unsigned int>(codepoint1) << 10u)
+0$                                                        // high surrogate occupies the most significant 22 bits
+0$                                        codepoint = static_cast<int>(
+0$                                        // overwrite codepoint
+0$                                    {
+0$                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
+0$                                    // check if codepoint2 is a low surrogate
+0$
+0$                                    }
+0$                                        return token_type::parse_error;
+0$                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
+0$                                    {
+0$                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
+0$
+0$                                    const int codepoint2 = get_codepoint();
+0$                                {
+0$                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
+0$                                // expect next \uxxxx entry
+0$                            {
+0$                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
+0$                            // check if code point is a high surrogate
+0$
+0$                            }
+0$                                return token_type::parse_error;
+0$                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
+0$                            {
+0$                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
+0$
+0$                            int codepoint = codepoint1; // start with codepoint1
+0$                            const int codepoint1 = get_codepoint();
+0$                        {
+0$                        case 'u':
+0$                        // unicode escapes
+0$
+0$                            break;
+0$                            add('\t');
+0$                        case 't':
+0$                        // tab
+0$                            break;
+0$                            add('\r');
+0$                        case 'r':
+0$                        // carriage return
+0$                            break;
+0$                            add('\n');
+0$                        case 'n':
+0$                        // line feed
+0$                            break;
+0$                            add('\f');
+0$                        case 'f':
+0$                        // form feed
+0$                            break;
+0$                            add('\b');
+0$                        case 'b':
+0$                        // backspace
+0$                            break;
+0$                            add('/');
+0$                        case '/':
+0$                        // solidus
+0$                            break;
+0$                            add('\\');
+0$                        case '\\':
+0$                        // reverse solidus
+0$                            break;
+0$                            add('\"');
+0$                        case '\"':
+0$                        // quotation mark
+0$                    {
+0$                    switch (get())
+0$                {
+0$                case '\\':
+0$                // escapes
+0$
+0$                }
+0$                    return token_type::value_string;
+0$                {
+0$                case '\"':
+0$                // closing quote
+0$
+0$                }
+0$                    return token_type::parse_error;
+0$                    error_message = "invalid string: missing closing quote";
+0$                {
+0$                case char_traits<char_type>::eof():
+0$                // end of file while parsing string
+0$            {
+0$            switch (get())
+0$            // get next character
+0$        {
+0$        while (true)
+0$
+0$        JSON_ASSERT(current == '\"');
+0$        // we entered the function by reading an open quote
+0$
+0$        reset();
+0$        // reset token_buffer (ignore opening quote)
+0$    {
+0$    token_type scan_string()
+0$    */
+0$          description.
+0$    @note In case of errors, variable error_message contains a textual
+0$
+0$            token_type::parse_error otherwise
+0$    @return token_type::value_string if string could be successfully scanned,
+0$
+0$    string.
+0$    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
+0$    function returns successfully, token_buffer is *not* null-terminated (as it
+0$    scanning, bytes are escaped and copied into buffer token_buffer. Then the
+0$    This function scans a string according to Sect. 7 of RFC 8259. While
+0$
+0$    @brief scan a string literal
+0$    /*!
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            }
+0$                return false;
+0$                error_message = "invalid string: ill-formed UTF-8 byte";
+0$            {
+0$            else
+0$            }
+0$                add(current);
+0$            {
+0$            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range))) // NOLINT(bugprone-inc-dec-in-conditions)
+0$            get();
+0$        {
+0$        for (auto range = ranges.begin(); range != ranges.end(); ++range)
+0$
+0$        add(current);
+0$        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
+0$    {
+0$    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
+0$    */
+0$    @return true if and only if no range violation was detected
+0$
+0$         1, 2, or 3 pairs. This precondition is enforced by an assertion.
+0$    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
+0$
+0$                       inclusive lower and upper bound, respectively
+0$    @param[in] ranges  list of integers; interpreted as list of pairs of
+0$
+0$    error message and return false. Otherwise, return true.
+0$    checks if it is inside the range. If a violation was detected, set up an
+0$    Adds the current byte and, for each passed range, reads a new byte and
+0$
+0$    @brief check if the next byte(s) are inside a given range
+0$    /*!
+0$
+0$    }
+0$        return codepoint;
+0$        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
+0$
+0$        }
+0$            }
+0$                return -1;
+0$            {
+0$            else
+0$            }
+0$                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
+0$            {
+0$            else if (current >= 'a' && current <= 'f')
+0$            }
+0$                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
+0$            {
+0$            else if (current >= 'A' && current <= 'F')
+0$            }
+0$                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
+0$            {
+0$            if (current >= '0' && current <= '9')
+0$
+0$            get();
+0$        {
+0$        for (const auto factor : factors)
+0$        const auto factors = { 12u, 8u, 4u, 0u };
+0$
+0$        int codepoint = 0;
+0$        JSON_ASSERT(current == 'u');
+0$        // this function only makes sense after reading `\u`
+0$    {
+0$    int get_codepoint()
+0$    */
+0$            non-hex character)
+0$    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
+0$
+0$    between the ASCII value of the character and the desired integer value.
+0$    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
+0$    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
+0$    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
+0$
+0$    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)
+0$      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
+0$    For input "\u c1 c2 c3 c4" the codepoint is:
+0$
+0$    @brief get codepoint from 4 hex characters following `\u`
+0$    /*!
+0$
+0$    /////////////////////
+0$    // scan functions
+0$    /////////////////////
+0$
+0$    }
+0$        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
+0$        JSON_ASSERT(loc != nullptr);
+0$        const auto* loc = localeconv();
+0$    {
+0$    static char get_decimal_point() noexcept
+0$    JSON_HEDLEY_PURE
+0$    /// return the locale-dependent decimal point
+0$
+0$    /////////////////////
+0$    // locales
+0$    /////////////////////
+0$  private:
+0$
+0$    ~lexer() = default;
+0$    lexer& operator=(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    lexer& operator=(lexer&) = delete;
+0$    lexer(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    lexer(const lexer&) = delete;
+0$    // delete because of pointer members
+0$
+0$    {}
+0$        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
+0$        , ignore_comments(ignore_comments_)
+0$        : ia(std::move(adapter))
+0$    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
+0$
+0$    using token_type = typename lexer_base<BasicJsonType>::token_type;
+0$  public:
+0$
+0$    using char_int_type = typename char_traits<char_type>::int_type;
+0$    using char_type = typename InputAdapterType::char_type;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0${
+0$class lexer : public lexer_base<BasicJsonType>
+0$template<typename BasicJsonType, typename InputAdapterType>
+0$*/
+0$This class organizes the lexical analysis during JSON deserialization.
+0$
+0$@brief lexical analysis
+0$/*!
+0$};
+0$    }
+0$        }
+0$                // LCOV_EXCL_STOP
+0$                return "unknown token";
+0$            default: // catch non-enum values
+0$            // LCOV_EXCL_START
+0$                return "'[', '{', or a literal";
+0$            case token_type::literal_or_value:
+0$                return "end of input";
+0$            case token_type::end_of_input:
+0$                return "<parse error>";
+0$            case token_type::parse_error:
+0$                return "','";
+0$            case token_type::value_separator:
+0$                return "':'";
+0$            case token_type::name_separator:
+0$                return "'}'";
+0$            case token_type::end_object:
+0$                return "']'";
+0$            case token_type::end_array:
+0$                return "'{'";
+0$            case token_type::begin_object:
+0$                return "'['";
+0$            case token_type::begin_array:
+0$                return "number literal";
+0$            case token_type::value_float:
+0$            case token_type::value_integer:
+0$            case token_type::value_unsigned:
+0$                return "string literal";
+0$            case token_type::value_string:
+0$                return "null literal";
+0$            case token_type::literal_null:
+0$                return "false literal";
+0$            case token_type::literal_false:
+0$                return "true literal";
+0$            case token_type::literal_true:
+0$                return "<uninitialized>";
+0$            case token_type::uninitialized:
+0$        {
+0$        switch (t)
+0$    {
+0$    static const char* token_type_name(const token_type t) noexcept
+0$    JSON_HEDLEY_CONST
+0$    JSON_HEDLEY_RETURNS_NON_NULL
+0$    /// return name of values of type token_type (only used for errors)
+0$
+0$    };
+0$        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
+0$        end_of_input,     ///< indicating the end of the input buffer
+0$        parse_error,      ///< indicating a parse error
+0$        value_separator,  ///< the value separator `,`
+0$        name_separator,   ///< the name separator `:`
+0$        end_object,       ///< the character for object end `}`
+0$        end_array,        ///< the character for array end `]`
+0$        begin_object,     ///< the character for object begin `{`
+0$        begin_array,      ///< the character for array begin `[`
+0$        value_float,      ///< an floating point number -- use get_number_float() for actual value
+0$        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
+0$        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
+0$        value_string,     ///< a string -- use get_string() for actual value
+0$        literal_null,     ///< the `null` literal
+0$        literal_false,    ///< the `false` literal
+0$        literal_true,     ///< the `true` literal
+0$        uninitialized,    ///< indicating the scanner is uninitialized
+0$    {
+0$    enum class token_type
+0$    /// token types for the parser
+0$  public:
+0${
+0$class lexer_base
+0$template<typename BasicJsonType>
+0$
+0$///////////
+0$// lexer //
+0$///////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/input/position_t.hpp>
+0$
+0$// #include <nlohmann/detail/input/input_adapters.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // move
+0$#include <string> // char_traits, string
+0$#include <initializer_list> // initializer_list
+0$#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
+0$#include <cstdio> // snprintf
+0$#include <cstddef> // size_t
+0$#include <clocale> // localeconv
+0$#include <array> // array
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/lexer.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    }
+0$        return false;
+0$    {
+0$    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool end_array()
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool start_array(std::size_t /*unused*/ = static_cast<std::size_t>(-1))
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool end_object()
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool key(string_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool start_object(std::size_t /*unused*/ = static_cast<std::size_t>(-1))
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool binary(binary_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool string(string_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool number_unsigned(number_unsigned_t /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool number_integer(number_integer_t /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool boolean(bool /*unused*/)
+0$
+0$    }
+0$        return true;
+0$    {
+0$    bool null()
+0$
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$  public:
+0${
+0$class json_sax_acceptor
+0$template<typename BasicJsonType>
+0$
+0$};
+0$    BasicJsonType discarded = BasicJsonType::value_t::discarded;
+0$    /// a discarded value for the callback
+0$    const bool allow_exceptions = true;
+0$    /// whether to throw exceptions in case of errors
+0$    const parser_callback_t callback = nullptr;
+0$    /// callback function
+0$    bool errored = false;
+0$    /// whether a syntax error occurred
+0$    BasicJsonType* object_element = nullptr;
+0$    /// helper to hold the reference for the next object element
+0$    std::vector<bool> key_keep_stack {}; // NOLINT(readability-redundant-member-init)
+0$    /// stack to manage which object keys to keep
+0$    std::vector<bool> keep_stack {}; // NOLINT(readability-redundant-member-init)
+0$    /// stack to manage which values to keep
+0$    std::vector<BasicJsonType*> ref_stack {};
+0$    /// stack to model hierarchy of values
+0$    BasicJsonType& root;
+0$    /// the parsed JSON value
+0$
+0$    }
+0$        return {true, object_element};
+0$        *object_element = std::move(value);
+0$        JSON_ASSERT(object_element);
+0$
+0$        }
+0$            return {false, nullptr};
+0$        {
+0$        if (!store_element)
+0$
+0$        key_keep_stack.pop_back();
+0$        const bool store_element = key_keep_stack.back();
+0$        JSON_ASSERT(!key_keep_stack.empty());
+0$        // check if we should store an element for the current key
+0$        JSON_ASSERT(ref_stack.back()->is_object());
+0$        // object
+0$
+0$        }
+0$            return {true, & (ref_stack.back()->m_data.m_value.array->back())};
+0$            ref_stack.back()->m_data.m_value.array->emplace_back(std::move(value));
+0$        {
+0$        if (ref_stack.back()->is_array())
+0$        // array
+0$
+0$        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
+0$        // we now only expect arrays and objects
+0$
+0$        }
+0$            return {false, nullptr};
+0$        {
+0$        if (!ref_stack.back())
+0$        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
+0$        // skip this value if we already decided to skip the parent
+0$
+0$        }
+0$            return {true, & root};
+0$            root = std::move(value);
+0$        {
+0$        if (ref_stack.empty())
+0$
+0$        }
+0$            return {false, nullptr};
+0$        {
+0$        if (!keep)
+0$        // do not handle this value if we just learnt it shall be discarded
+0$
+0$        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);
+0$        // check callback
+0$
+0$        auto value = BasicJsonType(std::forward<Value>(v));
+0$        // create value
+0$
+0$        }
+0$            return {false, nullptr};
+0$        {
+0$        if (!keep_stack.back())
+0$        // container
+0$        // do not handle this value if we know it would be added to a discarded
+0$
+0$        JSON_ASSERT(!keep_stack.empty());
+0$    {
+0$    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
+0$    template<typename Value>
+0$    */
+0$            passed value in the ref_stack hierarchy; nullptr if not kept)
+0$    @return pair of boolean (whether value should be kept) and pointer (to the
+0$
+0$               object to which we can add elements
+0$    @invariant If the ref stack contains a value, then it is an array or an
+0$               root.
+0$    @invariant If the ref stack is empty, then the passed value will be the new
+0$
+0$               callback function with an empty array or object, respectively.
+0$               start_object() SAX events, because otherwise we would call the
+0$               function; this is required after start_array() and
+0$    @param[in] skip_callback  whether we should skip calling the callback
+0$    @param[in] v  value to add to the JSON value we build during parsing
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return errored;
+0$    {
+0$    constexpr bool is_errored() const
+0$
+0$    }
+0$        return false;
+0$        }
+0$            JSON_THROW(ex);
+0$        {
+0$        if (allow_exceptions)
+0$        static_cast<void>(ex);
+0$        errored = true;
+0$    {
+0$                     const Exception& ex)
+0$    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
+0$    template<class Exception>
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            ref_stack.back()->m_data.m_value.array->pop_back();
+0$        {
+0$        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
+0$        // remove discarded value
+0$
+0$        keep_stack.pop_back();
+0$        ref_stack.pop_back();
+0$        JSON_ASSERT(!keep_stack.empty());
+0$        JSON_ASSERT(!ref_stack.empty());
+0$
+0$        }
+0$            }
+0$                *ref_stack.back() = discarded;
+0$                // discard array
+0$            {
+0$            else
+0$            }
+0$                ref_stack.back()->set_parents();
+0$            {
+0$            if (keep)
+0$            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
+0$        {
+0$        if (ref_stack.back())
+0$
+0$        bool keep = true;
+0$    {
+0$    bool end_array()
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
+0$        {
+0$        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
+0$        // check array limit
+0$
+0$        ref_stack.push_back(val.second);
+0$        auto val = handle_value(BasicJsonType::value_t::array, true);
+0$
+0$        keep_stack.push_back(keep);
+0$        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
+0$    {
+0$    bool start_array(std::size_t len)
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            }
+0$                }
+0$                    break;
+0$                    ref_stack.back()->erase(it);
+0$                {
+0$                if (it->is_discarded())
+0$            {
+0$            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
+0$            // remove discarded value
+0$        {
+0$        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
+0$
+0$        keep_stack.pop_back();
+0$        ref_stack.pop_back();
+0$        JSON_ASSERT(!keep_stack.empty());
+0$        JSON_ASSERT(!ref_stack.empty());
+0$
+0$        }
+0$            }
+0$                ref_stack.back()->set_parents();
+0$            {
+0$            else
+0$            }
+0$                *ref_stack.back() = discarded;
+0$                // discard object
+0$            {
+0$            if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
+0$        {
+0$        if (ref_stack.back())
+0$    {
+0$    bool end_object()
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val) = discarded);
+0$        {
+0$        if (keep && ref_stack.back())
+0$        // add discarded value at given key and store the reference for later
+0$
+0$        key_keep_stack.push_back(keep);
+0$        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
+0$        // check callback for key
+0$
+0$        BasicJsonType k = BasicJsonType(val);
+0$    {
+0$    bool key(string_t& val)
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
+0$        {
+0$        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
+0$        // check object limit
+0$
+0$        ref_stack.push_back(val.second);
+0$        auto val = handle_value(BasicJsonType::value_t::object, true);
+0$
+0$        keep_stack.push_back(keep);
+0$        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
+0$        // check callback for object start
+0$    {
+0$    bool start_object(std::size_t len)
+0$
+0$    }
+0$        return true;
+0$        handle_value(std::move(val));
+0$    {
+0$    bool binary(binary_t& val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool string(string_t& val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_float(number_float_t val, const string_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_unsigned(number_unsigned_t val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_integer(number_integer_t val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool boolean(bool val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(nullptr);
+0$    {
+0$    bool null()
+0$
+0$    ~json_sax_dom_callback_parser() = default;
+0$    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
+0$    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
+0$    // make class move-only
+0$
+0$    }
+0$        keep_stack.push_back(true);
+0$    {
+0$        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
+0$                                 const bool allow_exceptions_ = true)
+0$                                 const parser_callback_t cb,
+0$    json_sax_dom_callback_parser(BasicJsonType& r,
+0$
+0$    using parse_event_t = typename BasicJsonType::parse_event_t;
+0$    using parser_callback_t = typename BasicJsonType::parser_callback_t;
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$  public:
+0${
+0$class json_sax_dom_callback_parser
+0$template<typename BasicJsonType>
+0$
+0$};
+0$    const bool allow_exceptions = true;
+0$    /// whether to throw exceptions in case of errors
+0$    bool errored = false;
+0$    /// whether a syntax error occurred
+0$    BasicJsonType* object_element = nullptr;
+0$    /// helper to hold the reference for the next object element
+0$    std::vector<BasicJsonType*> ref_stack {};
+0$    /// stack to model hierarchy of values
+0$    BasicJsonType& root;
+0$    /// the parsed JSON value
+0$
+0$    }
+0$        return object_element;
+0$        *object_element = BasicJsonType(std::forward<Value>(v));
+0$        JSON_ASSERT(object_element);
+0$        JSON_ASSERT(ref_stack.back()->is_object());
+0$
+0$        }
+0$            return &(ref_stack.back()->m_data.m_value.array->back());
+0$            ref_stack.back()->m_data.m_value.array->emplace_back(std::forward<Value>(v));
+0$        {
+0$        if (ref_stack.back()->is_array())
+0$
+0$        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
+0$
+0$        }
+0$            return &root;
+0$            root = BasicJsonType(std::forward<Value>(v));
+0$        {
+0$        if (ref_stack.empty())
+0$    {
+0$    BasicJsonType* handle_value(Value&& v)
+0$    JSON_HEDLEY_RETURNS_NON_NULL
+0$    template<typename Value>
+0$    */
+0$               object to which we can add elements
+0$    @invariant If the ref stack contains a value, then it is an array or an
+0$               root.
+0$    @invariant If the ref stack is empty, then the passed value will be the new
+0$    /*!
+0$  private:
+0$
+0$    }
+0$        return errored;
+0$    {
+0$    constexpr bool is_errored() const
+0$
+0$    }
+0$        return false;
+0$        }
+0$            JSON_THROW(ex);
+0$        {
+0$        if (allow_exceptions)
+0$        static_cast<void>(ex);
+0$        errored = true;
+0$    {
+0$                     const Exception& ex)
+0$    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
+0$    template<class Exception>
+0$
+0$    }
+0$        return true;
+0$        ref_stack.pop_back();
+0$        ref_stack.back()->set_parents();
+0$
+0$        JSON_ASSERT(ref_stack.back()->is_array());
+0$        JSON_ASSERT(!ref_stack.empty());
+0$    {
+0$    bool end_array()
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
+0$
+0$        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
+0$    {
+0$    bool start_array(std::size_t len)
+0$
+0$    }
+0$        return true;
+0$        ref_stack.pop_back();
+0$        ref_stack.back()->set_parents();
+0$
+0$        JSON_ASSERT(ref_stack.back()->is_object());
+0$        JSON_ASSERT(!ref_stack.empty());
+0$    {
+0$    bool end_object()
+0$
+0$    }
+0$        return true;
+0$        object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val));
+0$        // add null at given key and store the reference for later
+0$
+0$        JSON_ASSERT(ref_stack.back()->is_object());
+0$        JSON_ASSERT(!ref_stack.empty());
+0$    {
+0$    bool key(string_t& val)
+0$
+0$    }
+0$        return true;
+0$
+0$        }
+0$            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
+0$
+0$        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
+0$    {
+0$    bool start_object(std::size_t len)
+0$
+0$    }
+0$        return true;
+0$        handle_value(std::move(val));
+0$    {
+0$    bool binary(binary_t& val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool string(string_t& val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_float(number_float_t val, const string_t& /*unused*/)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_unsigned(number_unsigned_t val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool number_integer(number_integer_t val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(val);
+0$    {
+0$    bool boolean(bool val)
+0$
+0$    }
+0$        return true;
+0$        handle_value(nullptr);
+0$    {
+0$    bool null()
+0$
+0$    ~json_sax_dom_parser() = default;
+0$    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
+0$    json_sax_dom_parser(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
+0$    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
+0$    // make class move-only
+0$
+0$    {}
+0$        : root(r), allow_exceptions(allow_exceptions_)
+0$    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
+0$    */
+0$    @param[in] allow_exceptions_  whether parse errors yield exceptions
+0$                       parsing
+0$    @param[in,out] r  reference to a JSON value that is manipulated while
+0$    /*!
+0$
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$  public:
+0${
+0$class json_sax_dom_parser
+0$template<typename BasicJsonType>
+0$*/
+0$@tparam BasicJsonType  the JSON type
+0$
+0$constructor contains the parsed value.
+0$After successful parsing, the value that is passed by reference to the
+0$
+0$a pointer to the respective array or object for each recursion depth.
+0$hierarchy of the JSON value is managed by the stack `ref_stack` which contains
+0$to create a JSON value which makes it basically a DOM parser. The structure or
+0$This class implements the @ref json_sax interface and processes the SAX events
+0$
+0$@brief SAX implementation to create a JSON value from SAX events
+0$/*!
+0${
+0$namespace detail
+0$
+0$};
+0$    virtual ~json_sax() = default;
+0$    json_sax& operator=(json_sax&&) noexcept = default;
+0$    json_sax& operator=(const json_sax&) = default;
+0$    json_sax(json_sax&&) noexcept = default;
+0$    json_sax(const json_sax&) = default;
+0$    json_sax() = default;
+0$
+0$                             const detail::exception& ex) = 0;
+0$                             const std::string& last_token,
+0$    virtual bool parse_error(std::size_t position,
+0$    */
+0$    @return whether parsing should proceed (must return false)
+0$    @param[in] ex          an exception object describing the error
+0$    @param[in] last_token  the last read token
+0$    @param[in] position    the position in the input where the error occurs
+0$    @brief a parse error occurred
+0$    /*!
+0$
+0$    virtual bool end_array() = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @brief the end of an array was read
+0$    /*!
+0$
+0$    virtual bool start_array(std::size_t elements) = 0;
+0$    */
+0$    @note binary formats may report the number of elements
+0$    @return whether parsing should proceed
+0$    @param[in] elements  number of array elements or -1 if unknown
+0$    @brief the beginning of an array was read
+0$    /*!
+0$
+0$    virtual bool end_object() = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @brief the end of an object was read
+0$    /*!
+0$
+0$    virtual bool key(string_t& val) = 0;
+0$    */
+0$    @note It is safe to move the passed string.
+0$    @return whether parsing should proceed
+0$    @param[in] val  object key
+0$    @brief an object key was read
+0$    /*!
+0$
+0$    virtual bool start_object(std::size_t elements) = 0;
+0$    */
+0$    @note binary formats may report the number of elements
+0$    @return whether parsing should proceed
+0$    @param[in] elements  number of object elements or -1 if unknown
+0$    @brief the beginning of an object was read
+0$    /*!
+0$
+0$    virtual bool binary(binary_t& val) = 0;
+0$    */
+0$    @note It is safe to move the passed binary value.
+0$    @return whether parsing should proceed
+0$    @param[in] val  binary value
+0$    @brief a binary value was read
+0$    /*!
+0$
+0$    virtual bool string(string_t& val) = 0;
+0$    */
+0$    @note It is safe to move the passed string value.
+0$    @return whether parsing should proceed
+0$    @param[in] val  string value
+0$    @brief a string value was read
+0$    /*!
+0$
+0$    virtual bool number_float(number_float_t val, const string_t& s) = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @param[in] s    raw token value
+0$    @param[in] val  floating-point value
+0$    @brief a floating-point number was read
+0$    /*!
+0$
+0$    virtual bool number_unsigned(number_unsigned_t val) = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @param[in] val  unsigned integer value
+0$    @brief an unsigned integer number was read
+0$    /*!
+0$
+0$    virtual bool number_integer(number_integer_t val) = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @param[in] val  integer value
+0$    @brief an integer number was read
+0$    /*!
+0$
+0$    virtual bool boolean(bool val) = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @param[in] val  boolean value
+0$    @brief a boolean value was read
+0$    /*!
+0$
+0$    virtual bool null() = 0;
+0$    */
+0$    @return whether parsing should proceed
+0$    @brief a null value was read
+0$    /*!
+0$
+0$    using binary_t = typename BasicJsonType::binary_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0${
+0$struct json_sax
+0$template<typename BasicJsonType>
+0$*/
+0$input.
+0$boolean return value informs the parser whether to continue processing the
+0$Each function is called in different situations while the input is parsed. The
+0$This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
+0$
+0$@brief SAX interface
+0$/*!
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // move
+0$#include <string> // string
+0$#include <cstddef>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/json_sax.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    contiguous_bytes_input_adapter ia;
+0$  private:
+0$
+0$    }
+0$        return std::move(ia); // NOLINT(hicpp-move-const-arg,performance-move-const-arg)
+0$    {
+0$    contiguous_bytes_input_adapter&& get()
+0$
+0$        : ia(input_adapter(first, last)) {}
+0$    span_input_adapter(IteratorType first, IteratorType last)
+0$                 int>::type = 0>
+0$                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
+0$             typename std::enable_if<
+0$    template<class IteratorType,
+0$
+0$        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}
+0$    span_input_adapter(CharT b, std::size_t l)
+0$                   int >::type = 0 >
+0$                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
+0$                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
+0$                   std::is_pointer<CharT>::value&&
+0$               typename std::enable_if <
+0$    template < typename CharT,
+0$  public:
+0${
+0$class span_input_adapter
+0$// to the correct adapter.
+0$// It's required so that expressions like {ptr, len} can be implicitly cast
+0$// This class only handles inputs of input_buffer_adapter type.
+0$
+0$}
+0$    return input_adapter(array, array + N);
+0${
+0$auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$template<typename T, std::size_t N>
+0$
+0$}
+0$    return input_adapter(ptr, ptr + length);
+0$    const auto* ptr = reinterpret_cast<const char*>(b);
+0$    auto length = std::strlen(reinterpret_cast<const char*>(b));
+0${
+0$contiguous_bytes_input_adapter input_adapter(CharT b)
+0$               int >::type = 0 >
+0$               sizeof(typename std::remove_pointer<CharT>::type) == 1,
+0$               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
+0$               !std::is_array<CharT>::value&&
+0$               std::is_pointer<CharT>::value&&
+0$           typename std::enable_if <
+0$template < typename CharT,
+0$// Null-delimited strings, and the like.
+0$
+0$using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));
+0$
+0$#endif  // JSON_NO_IO
+0$}
+0$    return input_stream_adapter(stream);
+0${
+0$inline input_stream_adapter input_adapter(std::istream&& stream)
+0$
+0$}
+0$    return input_stream_adapter(stream);
+0${
+0$inline input_stream_adapter input_adapter(std::istream& stream)
+0$
+0$}
+0$    return file_input_adapter(file);
+0${
+0$inline file_input_adapter input_adapter(std::FILE* file)
+0$// Special cases with fast paths
+0$#ifndef JSON_NO_IO
+0$
+0$}
+0$    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
+0${
+0$typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
+0$template<typename ContainerType>
+0$
+0$}  // namespace container_input_adapter_factory_impl
+0$
+0$       };
+0$}
+0$    return input_adapter(begin(container), end(container));
+0${
+0$           static adapter_type create(const ContainerType& container)
+0$
+0$           using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));
+0$       {
+0$       void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
+0$struct container_input_adapter_factory< ContainerType,
+0$template<typename ContainerType>
+0$
+0$struct container_input_adapter_factory {};
+0$template<typename ContainerType, typename Enable = void>
+0$
+0$using std::end;
+0$using std::begin;
+0$
+0${
+0$namespace container_input_adapter_factory_impl
+0$
+0$// Encloses the using declarations in namespace for not to leak them to outside scope
+0$// Enables ADL on begin(container) and end(container)
+0$// Convenience shorthand from container to iterator
+0$
+0$}
+0$    return factory_type::create(first, last);
+0$    using factory_type = iterator_input_adapter_factory<IteratorType>;
+0${
+0$typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
+0$template<typename IteratorType>
+0$// General purpose iterator-based input
+0$
+0$};
+0$    }
+0$        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
+0$    {
+0$    static adapter_type create(IteratorType first, IteratorType last)
+0$
+0$    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;
+0$    using base_adapter_type = iterator_input_adapter<iterator_type>;
+0$    using char_type = typename std::iterator_traits<iterator_type>::value_type;
+0$    using iterator_type = IteratorType;
+0${
+0$struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
+0$template<typename IteratorType>
+0$
+0$};
+0$    };
+0$        value = sizeof(value_type) > 1
+0$    {
+0$    enum
+0$    using value_type = typename std::iterator_traits<T>::value_type;
+0${
+0$struct is_iterator_of_multibyte
+0$template<typename T>
+0$
+0$};
+0$    }
+0$        return adapter_type(std::move(first), std::move(last));
+0$    {
+0$    static adapter_type create(IteratorType first, IteratorType last)
+0$
+0$    using adapter_type = iterator_input_adapter<iterator_type>;
+0$    using char_type = typename std::iterator_traits<iterator_type>::value_type;
+0$    using iterator_type = IteratorType;
+0${
+0$struct iterator_input_adapter_factory
+0$template<typename IteratorType, typename Enable = void>
+0$
+0$};
+0$    std::size_t utf8_bytes_filled = 0;
+0$    /// number of valid bytes in the utf8_codes array
+0$    std::size_t utf8_bytes_index = 0;
+0$    /// index to the utf8_codes array for the next valid byte
+0$
+0$    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};
+0$    /// a buffer for UTF-8 bytes
+0$
+0$    }
+0$        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
+0$    {
+0$    void fill_buffer()
+0$    template<size_t T>
+0$
+0$    BaseInputAdapter base_adapter;
+0$  private:
+0$
+0$    }
+0$        return utf8_bytes[utf8_bytes_index++];
+0$        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
+0$        JSON_ASSERT(utf8_bytes_filled > 0);
+0$        // use buffer
+0$
+0$        }
+0$            JSON_ASSERT(utf8_bytes_index == 0);
+0$            JSON_ASSERT(utf8_bytes_filled > 0);
+0$
+0$            fill_buffer<sizeof(WideCharType)>();
+0$        {
+0$        if (utf8_bytes_index == utf8_bytes_filled)
+0$        // check if buffer needs to be filled
+0$    {
+0$    typename std::char_traits<char>::int_type get_character() noexcept
+0$
+0$        : base_adapter(base) {}
+0$    wide_string_input_adapter(BaseInputAdapter base)
+0$
+0$    using char_type = char;
+0$  public:
+0${
+0$class wide_string_input_adapter
+0$template<typename BaseInputAdapter, typename WideCharType>
+0$// Wraps another input adapter to convert wide character types into individual bytes.
+0$
+0$};
+0$    }
+0$        }
+0$            }
+0$                }
+0$                    utf8_bytes_filled = 1;
+0$                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
+0$                {
+0$                else
+0$                }
+0$                    utf8_bytes_filled = 4;
+0$                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
+0$                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
+0$                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
+0$                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
+0$                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
+0$                    const auto wc2 = static_cast<unsigned int>(input.get_character());
+0$                {
+0$                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
+0$            {
+0$            else
+0$            }
+0$                utf8_bytes_filled = 3;
+0$                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
+0$                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
+0$            {
+0$            else if (0xD800 > wc || wc >= 0xE000)
+0$            }
+0$                utf8_bytes_filled = 2;
+0$                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
+0$            {
+0$            else if (wc <= 0x7FF)
+0$            }
+0$                utf8_bytes_filled = 1;
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
+0$            {
+0$            if (wc < 0x80)
+0$            // UTF-16 to UTF-8 encoding
+0$
+0$            const auto wc = input.get_character();
+0$            // get the current character
+0$        {
+0$        else
+0$        }
+0$            utf8_bytes_filled = 1;
+0$            utf8_bytes[0] = std::char_traits<char>::eof();
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(input.empty()))
+0$
+0$        utf8_bytes_index = 0;
+0$    {
+0$                            size_t& utf8_bytes_filled)
+0$                            size_t& utf8_bytes_index,
+0$                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
+0$    static void fill_buffer(BaseInputAdapter& input,
+0$    // UTF-16
+0${
+0$struct wide_string_input_helper<BaseInputAdapter, 2>
+0$template<typename BaseInputAdapter>
+0$
+0$};
+0$    }
+0$        }
+0$            }
+0$                utf8_bytes_filled = 1;
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
+0$                // unknown character
+0$            {
+0$            else
+0$            }
+0$                utf8_bytes_filled = 4;
+0$                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
+0$                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
+0$                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
+0$            {
+0$            else if (wc <= 0x10FFFF)
+0$            }
+0$                utf8_bytes_filled = 3;
+0$                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
+0$                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
+0$            {
+0$            else if (wc <= 0xFFFF)
+0$            }
+0$                utf8_bytes_filled = 2;
+0$                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
+0$            {
+0$            else if (wc <= 0x7FF)
+0$            }
+0$                utf8_bytes_filled = 1;
+0$                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
+0$            {
+0$            if (wc < 0x80)
+0$            // UTF-32 to UTF-8 encoding
+0$
+0$            const auto wc = input.get_character();
+0$            // get the current character
+0$        {
+0$        else
+0$        }
+0$            utf8_bytes_filled = 1;
+0$            utf8_bytes[0] = std::char_traits<char>::eof();
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(input.empty()))
+0$
+0$        utf8_bytes_index = 0;
+0$    {
+0$                            size_t& utf8_bytes_filled)
+0$                            size_t& utf8_bytes_index,
+0$                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
+0$    static void fill_buffer(BaseInputAdapter& input,
+0$    // UTF-32
+0${
+0$struct wide_string_input_helper<BaseInputAdapter, 4>
+0$template<typename BaseInputAdapter>
+0$
+0$struct wide_string_input_helper;
+0$template<typename BaseInputAdapter, size_t T>
+0$
+0$};
+0$    }
+0$        return current == end;
+0$    {
+0$    bool empty() const
+0$
+0$    friend struct wide_string_input_helper;
+0$    template<typename BaseInputAdapter, size_t T>
+0$
+0$    IteratorType end;
+0$    IteratorType current;
+0$  private:
+0$
+0$    }
+0$        return char_traits<char_type>::eof();
+0$
+0$        }
+0$            return result;
+0$            std::advance(current, 1);
+0$            auto result = char_traits<char_type>::to_int_type(*current);
+0$        {
+0$        if (JSON_HEDLEY_LIKELY(current != end))
+0$    {
+0$    typename char_traits<char_type>::int_type get_character()
+0$
+0$    {}
+0$        : current(std::move(first)), end(std::move(last))
+0$    iterator_input_adapter(IteratorType first, IteratorType last)
+0$
+0$    using char_type = typename std::iterator_traits<IteratorType>::value_type;
+0$  public:
+0${
+0$class iterator_input_adapter
+0$template<typename IteratorType>
+0$// theoretically possible for some containers, but it is extremely versatile.
+0$// General-purpose iterator-based adapter. It might not be as fast as
+0$
+0$#endif  // JSON_NO_IO
+0$};
+0$    std::streambuf* sb = nullptr;
+0$    std::istream* is = nullptr;
+0$    /// the associated input stream
+0$  private:
+0$
+0$    }
+0$        return res;
+0$        }
+0$            is->clear(is->rdstate() | std::ios::eofbit);
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
+0$        // set eof manually, as we don't use the istream interface.
+0$        auto res = sb->sbumpc();
+0$    {
+0$    std::char_traits<char>::int_type get_character()
+0$    // end up as the same value, e.g. 0xFFFFFFFF.
+0$    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
+0$    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
+0$
+0$    }
+0$        rhs.sb = nullptr;
+0$        rhs.is = nullptr;
+0$    {
+0$        : is(rhs.is), sb(rhs.sb)
+0$    input_stream_adapter(input_stream_adapter&& rhs) noexcept
+0$
+0$    input_stream_adapter& operator=(input_stream_adapter&&) = delete;
+0$    input_stream_adapter& operator=(input_stream_adapter&) = delete;
+0$    input_stream_adapter(const input_stream_adapter&) = delete;
+0$    // delete because of pointer members
+0$
+0$    {}
+0$        : is(&i), sb(i.rdbuf())
+0$    explicit input_stream_adapter(std::istream& i)
+0$
+0$    }
+0$        }
+0$            is->clear(is->rdstate() & std::ios::eofbit);
+0$        {
+0$        if (is != nullptr)
+0$        // maintain ifstream flags, except eof
+0$        // clear stream flags; we use underlying streambuf I/O, do not
+0$    {
+0$    ~input_stream_adapter()
+0$
+0$    using char_type = char;
+0$  public:
+0${
+0$class input_stream_adapter
+0$*/
+0$subsequent call for input from the std::istream.
+0$std::istream flags; any input errors (e.g., EOF) will be detected by the first
+0$characters following those used in parsing the JSON input.  Clears the
+0$subsequent use of standard std::istream operations to process any input
+0$in mid-input. Maintains underlying std::istream and std::streambuf to support
+0$beginning of input. Does not support changing the underlying std::streambuf
+0$Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
+0$/*!
+0$
+0$};
+0$    std::FILE* m_file;
+0$    /// the file pointer to read from
+0$  private:
+0$
+0$    }
+0$        return std::fgetc(m_file);
+0$    {
+0$    std::char_traits<char>::int_type get_character() noexcept
+0$
+0$    ~file_input_adapter() = default;
+0$    file_input_adapter& operator=(file_input_adapter&&) = delete;
+0$    file_input_adapter& operator=(const file_input_adapter&) = delete;
+0$    file_input_adapter(file_input_adapter&&) noexcept = default;
+0$    file_input_adapter(const file_input_adapter&) = delete;
+0$    // make class move-only
+0$
+0$    }
+0$        JSON_ASSERT(m_file != nullptr);
+0$    {
+0$        : m_file(f)
+0$    explicit file_input_adapter(std::FILE* f) noexcept
+0$    JSON_HEDLEY_NON_NULL(2)
+0$
+0$    using char_type = char;
+0$  public:
+0${
+0$class file_input_adapter
+0$*/
+0$ buffer. This adapter is a very low level adapter.
+0$Input adapter for stdio file access. This adapter read only 1 byte and do not use any
+0$/*!
+0$#ifndef JSON_NO_IO
+0$
+0$////////////////////
+0$// input adapters //
+0$////////////////////
+0$
+0$enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };
+0$/// the supported input formats
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$// #include <nlohmann/detail/iterators/iterator_traits.hpp>
+0$
+0$#endif                  // JSON_NO_IO
+0$    #include <istream>  // istream
+0$    #include <cstdio>   // FILE *
+0$#ifndef JSON_NO_IO
+0$
+0$#include <utility> // pair, declval
+0$#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
+0$#include <string> // string, char_traits
+0$#include <numeric> // accumulate
+0$#include <memory> // shared_ptr, make_shared, addressof
+0$#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
+0$#include <cstring> // strlen
+0$#include <cstddef> // size_t
+0$#include <array> // array
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/input_adapters.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // make_pair, move
+0$#include <string> // char_traits, string
+0$#include <limits> // numeric_limits
+0$#include <iterator> // back_inserter
+0$#include <cstring> // memcpy
+0$#include <cstdio> // snprintf
+0$#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
+0$#include <cstddef> // size_t
+0$#include <cmath> // ldexp
+0$#include <array> // array
+0$#include <algorithm> // generate_n
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/binary_reader.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    }
+0$            return 0;              // LCOV_EXCL_LINE
+0$            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
+0$        default:                   // LCOV_EXCL_LINE
+0$
+0$        }
+0$            return seed;
+0$            }
+0$                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
+0$            {
+0$            for (const auto byte : j.get_binary())
+0$            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
+0$            seed = combine(seed, h);
+0$            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
+0$            auto seed = combine(type, j.get_binary().size());
+0$        {
+0$        case BasicJsonType::value_t::binary:
+0$
+0$        }
+0$            return combine(type, h);
+0$            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
+0$        {
+0$        case BasicJsonType::value_t::number_float:
+0$
+0$        }
+0$            return combine(type, h);
+0$            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
+0$        {
+0$        case BasicJsonType::value_t::number_unsigned:
+0$
+0$        }
+0$            return combine(type, h);
+0$            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
+0$        {
+0$        case BasicJsonType::value_t::number_integer:
+0$
+0$        }
+0$            return combine(type, h);
+0$            const auto h = std::hash<bool> {}(j.template get<bool>());
+0$        {
+0$        case BasicJsonType::value_t::boolean:
+0$
+0$        }
+0$            return combine(type, h);
+0$            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
+0$        {
+0$        case BasicJsonType::value_t::string:
+0$
+0$        }
+0$            return seed;
+0$            }
+0$                seed = combine(seed, hash(element));
+0$            {
+0$            for (const auto& element : j)
+0$            auto seed = combine(type, j.size());
+0$        {
+0$        case BasicJsonType::value_t::array:
+0$
+0$        }
+0$            return seed;
+0$            }
+0$                seed = combine(seed, hash(element.value()));
+0$                seed = combine(seed, h);
+0$                const auto h = std::hash<string_t> {}(element.key());
+0$            {
+0$            for (const auto& element : j.items())
+0$            auto seed = combine(type, j.size());
+0$        {
+0$        case BasicJsonType::value_t::object:
+0$
+0$        }
+0$            return combine(type, 0);
+0$        {
+0$        case BasicJsonType::value_t::discarded:
+0$        case BasicJsonType::value_t::null:
+0$    {
+0$    switch (j.type())
+0$    const auto type = static_cast<std::size_t>(j.type());
+0$
+0$    using number_float_t = typename BasicJsonType::number_float_t;
+0$    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
+0$    using number_integer_t = typename BasicJsonType::number_integer_t;
+0$    using string_t = typename BasicJsonType::string_t;
+0${
+0$std::size_t hash(const BasicJsonType& j)
+0$template<typename BasicJsonType>
+0$*/
+0$@return hash value of j
+0$@param j JSON value to hash
+0$@tparam BasicJsonType basic_json specialization
+0$
+0$null, 0, 0U, and false, etc.
+0$type of the JSON value is taken into account to have different hash values for
+0$The hash function tries to rely on std::hash where possible. Furthermore, the
+0$
+0$@brief hash a JSON value
+0$/*!
+0$
+0$}
+0$    return seed;
+0$    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
+0${
+0$inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
+0$// boost::hash_combine
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <functional> // hash
+0$#include <cstddef> // size_t
+0$#include <cstdint> // uint8_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/hash.hpp>
+0$
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$// #include <nlohmann/detail/conversions/to_json.hpp>
+0$
+0$// #include <nlohmann/detail/conversions/from_json.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$};
+0$    bool m_has_subtype = false;
+0$    subtype_type m_subtype = 0;
+0$  private:
+0$
+0$    }
+0$        m_has_subtype = false;
+0$        m_subtype = 0;
+0$    {
+0$    void clear_subtype() noexcept
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/clear_subtype/
+0$    /// @brief clears the binary subtype
+0$
+0$    }
+0$        return m_has_subtype;
+0$    {
+0$    constexpr bool has_subtype() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/has_subtype/
+0$    /// @brief return whether the value has a subtype
+0$
+0$    }
+0$        return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);
+0$    {
+0$    constexpr subtype_type subtype() const noexcept
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/subtype/
+0$    /// @brief return the binary subtype
+0$
+0$    }
+0$        m_has_subtype = true;
+0$        m_subtype = subtype_;
+0$    {
+0$    void set_subtype(subtype_type subtype_) noexcept
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/set_subtype/
+0$    /// @brief sets the binary subtype
+0$
+0$    }
+0$        return !(rhs == *this);
+0$    {
+0$    bool operator!=(const byte_container_with_subtype& rhs) const
+0$
+0$    }
+0$               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
+0$        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
+0$    {
+0$    bool operator==(const byte_container_with_subtype& rhs) const
+0$
+0$    {}
+0$        , m_has_subtype(true)
+0$        , m_subtype(subtype_)
+0$        : container_type(std::move(b))
+0$    byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
+0$
+0$    {}
+0$        , m_has_subtype(true)
+0$        , m_subtype(subtype_)
+0$        : container_type(b)
+0$    byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
+0$
+0$    {}
+0$        : container_type(std::move(b))
+0$    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
+0$
+0$    {}
+0$        : container_type(b)
+0$    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
+0$
+0$    {}
+0$        : container_type()
+0$    byte_container_with_subtype() noexcept(noexcept(container_type()))
+0$    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
+0$
+0$    using subtype_type = std::uint64_t;
+0$    using container_type = BinaryType;
+0$  public:
+0${
+0$class byte_container_with_subtype : public BinaryType
+0$template<typename BinaryType>
+0$/// @sa https://json.nlohmann.me/api/byte_container_with_subtype/
+0$/// @brief an internal type for a backed binary type
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <utility> // move
+0$#include <tuple> // tie
+0$#include <cstdint> // uint8_t, uint64_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/byte_container_with_subtype.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$};
+0$    }
+0$        ::nlohmann::to_json(j, std::forward<TargetType>(val));
+0$    {
+0$    -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
+0$        noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
+0$    static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
+0$    template<typename BasicJsonType, typename TargetType = ValueType>
+0$    /// @sa https://json.nlohmann.me/api/adl_serializer/to_json/
+0$    /// @brief convert any value type to a JSON value
+0$
+0$    }
+0$        return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
+0$    {
+0$    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
+0$    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
+0$    static auto from_json(BasicJsonType && j) noexcept(
+0$    template<typename BasicJsonType, typename TargetType = ValueType>
+0$    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
+0$    /// @brief convert a JSON value to any value type
+0$
+0$    }
+0$        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
+0$    {
+0$    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
+0$        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
+0$    static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
+0$    template<typename BasicJsonType, typename TargetType = ValueType>
+0$    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
+0$    /// @brief convert a JSON value to any value type
+0${
+0$struct adl_serializer
+0$template<typename ValueType, typename>
+0$/// @sa https://json.nlohmann.me/api/adl_serializer/
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/identity_tag.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$#endif
+0$}  // namespace
+0$#ifndef JSON_HAS_CPP_17
+0$    detail::static_const<detail::to_json_fn>::value;
+0$JSON_INLINE_VARIABLE constexpr const auto& to_json = // NOLINT(misc-definitions-in-headers)
+0$#endif
+0${
+0$namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
+0$/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
+0$/// to see why this is required:
+0$/// namespace to hold default `to_json` function
+0$#ifndef JSON_HAS_CPP_17
+0$
+0$}  // namespace detail
+0$};
+0$    }
+0$        return to_json(j, std::forward<T>(val));
+0$    {
+0$    -> decltype(to_json(j, std::forward<T>(val)), void())
+0$    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
+0$    template<typename BasicJsonType, typename T>
+0${
+0$struct to_json_fn
+0$
+0$#endif
+0$}
+0$    j = p.string();
+0${
+0$inline void to_json(BasicJsonType& j, const std_fs::path& p)
+0$template<typename BasicJsonType>
+0$#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$
+0$}
+0$    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
+0${
+0$inline void to_json(BasicJsonType& j, const T& t)
+0$template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
+0$
+0$}
+0$    j = { std::get<Idx>(t)... };
+0${
+0$inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
+0$template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
+0$
+0$}
+0$    j = { {b.key(), b.value()} };
+0${
+0$inline void to_json(BasicJsonType& j, const T& b)
+0$         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
+0$template<typename BasicJsonType, typename T,
+0$// for https://github.com/nlohmann/json/pull/1134
+0$
+0$}
+0$    j = { p.first, p.second };
+0${
+0$inline void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
+0$template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
+0$
+0$}
+0$    external_constructor<value_t::array>::construct(j, arr);
+0${
+0$inline void to_json(BasicJsonType& j, const T(&arr)[N]) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$                  int > = 0 >
+0$                  const T(&)[N]>::value, // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
+0$    typename BasicJsonType, typename T, std::size_t N,
+0$template <
+0$
+0$}
+0$    external_constructor<value_t::object>::construct(j, std::move(obj));
+0${
+0$inline void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    external_constructor<value_t::object>::construct(j, obj);
+0${
+0$inline void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
+0$           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
+0$template < typename BasicJsonType, typename CompatibleObjectType,
+0$
+0$}
+0$    external_constructor<value_t::array>::construct(j, std::move(arr));
+0${
+0$inline void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    external_constructor<value_t::array>::construct(j, std::move(arr));
+0${
+0$inline void to_json(BasicJsonType& j, const std::valarray<T>& arr)
+0$         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
+0$template<typename BasicJsonType, typename T,
+0$
+0$}
+0$    external_constructor<value_t::binary>::construct(j, bin);
+0${
+0$inline void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    external_constructor<value_t::array>::construct(j, arr);
+0${
+0$inline void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
+0$                         int > = 0 >
+0$                         !is_basic_json<CompatibleArrayType>::value,
+0$                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
+0$                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
+0$                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
+0$                         CompatibleArrayType>::value&&
+0$           enable_if_t < is_compatible_array_type<BasicJsonType,
+0$template < typename BasicJsonType, typename CompatibleArrayType,
+0$
+0$}
+0$    external_constructor<value_t::array>::construct(j, e);
+0${
+0$inline void to_json(BasicJsonType& j, const std::vector<bool>& e)
+0$template<typename BasicJsonType>
+0$
+0$#endif  // JSON_DISABLE_ENUM_SERIALIZATION
+0$}
+0$    external_constructor<integral_value_t>::construct(j, static_cast<underlying_type>(e));
+0$    static constexpr value_t integral_value_t = std::is_unsigned<underlying_type>::value ? value_t::number_unsigned : value_t::number_integer;
+0$    using underlying_type = typename std::underlying_type<EnumType>::type;
+0${
+0$inline void to_json(BasicJsonType& j, EnumType e) noexcept
+0$         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
+0$template<typename BasicJsonType, typename EnumType,
+0$#if !JSON_DISABLE_ENUM_SERIALIZATION
+0$
+0$}
+0$    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
+0${
+0$inline void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
+0$         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
+0$template<typename BasicJsonType, typename CompatibleNumberIntegerType,
+0$
+0$}
+0$    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
+0${
+0$inline void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
+0$         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
+0$template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
+0$
+0$}
+0$    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
+0${
+0$inline void to_json(BasicJsonType& j, FloatType val) noexcept
+0$         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
+0$template<typename BasicJsonType, typename FloatType,
+0$
+0$}
+0$    external_constructor<value_t::string>::construct(j, std::move(s));
+0${
+0$inline void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    external_constructor<value_t::string>::construct(j, s);
+0${
+0$inline void to_json(BasicJsonType& j, const CompatibleString& s)
+0$         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
+0$template<typename BasicJsonType, typename CompatibleString,
+0$
+0$}
+0$    external_constructor<value_t::boolean>::construct(j, static_cast<typename BasicJsonType::boolean_t>(b));
+0${
+0$inline void to_json(BasicJsonType& j, const BoolRef& b) noexcept
+0$               && std::is_convertible<const BoolRef&, typename BasicJsonType::boolean_t>::value, int > = 0 >
+0$                                      typename BasicJsonType::boolean_t >::value))
+0$                    && !std::is_same <detail::uncvref_t<std::vector<bool>::const_reference>,
+0$                || (std::is_same<std::vector<bool>::const_reference, BoolRef>::value
+0$                 && !std::is_same <std::vector<bool>::reference, typename BasicJsonType::boolean_t&>::value)
+0$               ((std::is_same<std::vector<bool>::reference, BoolRef>::value
+0$           enable_if_t <
+0$template < typename BasicJsonType, typename BoolRef,
+0$
+0$}
+0$    external_constructor<value_t::boolean>::construct(j, b);
+0${
+0$inline void to_json(BasicJsonType& j, T b) noexcept
+0$         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
+0$template<typename BasicJsonType, typename T,
+0$
+0$/////////////
+0$// to_json //
+0$/////////////
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
+0$        j.m_data.m_type = value_t::object;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$
+0$        using std::end;
+0$        using std::begin;
+0$    {
+0$    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
+0$               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
+0$    template < typename BasicJsonType, typename CompatibleObjectType,
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value = std::move(obj);
+0$        j.m_data.m_type = value_t::object;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value = obj;
+0$        j.m_data.m_type = value_t::object;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::object>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        }
+0$            std::copy(std::begin(arr), std::end(arr), j.m_data.m_value.array->begin());
+0$        {
+0$        if (arr.size() > 0)
+0$        j.m_data.m_value.array->resize(arr.size());
+0$        j.m_data.m_value = value_t::array;
+0$        j.m_data.m_type = value_t::array;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
+0$             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
+0$    template<typename BasicJsonType, typename T,
+0$
+0$    }
+0$        j.assert_invariant();
+0$        }
+0$            j.set_parent(j.m_data.m_value.array->back());
+0$            j.m_data.m_value.array->push_back(x);
+0$        {
+0$        for (const bool x : arr)
+0$        j.m_data.m_value.array->reserve(arr.size());
+0$        j.m_data.m_value = value_t::array;
+0$        j.m_data.m_type = value_t::array;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
+0$        j.m_data.m_type = value_t::array;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$
+0$        using std::end;
+0$        using std::begin;
+0$    {
+0$    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
+0$                             int > = 0 >
+0$               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
+0$    template < typename BasicJsonType, typename CompatibleArrayType,
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value = std::move(arr);
+0$        j.m_data.m_type = value_t::array;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.set_parents();
+0$        j.m_data.m_value = arr;
+0$        j.m_data.m_type = value_t::array;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::array>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = val;
+0$        j.m_data.m_type = value_t::number_integer;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::number_integer>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = val;
+0$        j.m_data.m_type = value_t::number_unsigned;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::number_unsigned>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = val;
+0$        j.m_data.m_type = value_t::number_float;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::number_float>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = typename BasicJsonType::binary_t(std::move(b));
+0$        j.m_data.m_type = value_t::binary;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = typename BasicJsonType::binary_t(b);
+0$        j.m_data.m_type = value_t::binary;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::binary>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
+0$        j.m_data.m_type = value_t::string;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const CompatibleStringType& str)
+0$                             int > = 0 >
+0$               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
+0$    template < typename BasicJsonType, typename CompatibleStringType,
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = std::move(s);
+0$        j.m_data.m_type = value_t::string;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = s;
+0$        j.m_data.m_type = value_t::string;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::string>
+0$template<>
+0$
+0$};
+0$    }
+0$        j.assert_invariant();
+0$        j.m_data.m_value = b;
+0$        j.m_data.m_type = value_t::boolean;
+0$        j.m_data.m_value.destroy(j.m_data.m_type);
+0$    {
+0$    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
+0$    template<typename BasicJsonType>
+0${
+0$struct external_constructor<value_t::boolean>
+0$template<>
+0$
+0$template<value_t> struct external_constructor;
+0$
+0$ */
+0$ * https://github.com/nlohmann/json/issues/2865 for more information.
+0$ * allocated value (e.g., a string). See bug issue
+0$ * j.m_data.m_value.destroy(j.m_data.m_type) to avoid a memory leak in case j contains an
+0$ * Note all external_constructor<>::construct functions need to call
+0$/*
+0$
+0$//////////////////
+0$// constructors //
+0$//////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/meta/std_fs.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#endif
+0$    inline constexpr bool ::std::ranges::enable_borrowed_range<::nlohmann::detail::iteration_proxy<IteratorType>> = true;
+0$    template <typename IteratorType>
+0$#if JSON_HAS_RANGES
+0$
+0$}  // namespace std
+0$
+0$#endif
+0$    #pragma clang diagnostic pop
+0$#if defined(__clang__)
+0$};
+0$                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
+0$                     get<N>(std::declval <
+0$    using type = decltype(
+0$  public:
+0${
+0$class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >> // NOLINT(cert-dcl58-cpp)
+0$template<std::size_t N, typename IteratorType>
+0$
+0$            : public std::integral_constant<std::size_t, 2> {};
+0$class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>> // NOLINT(cert-dcl58-cpp)
+0$template<typename IteratorType>
+0$#endif
+0$    #pragma clang diagnostic ignored "-Wmismatched-tags"
+0$    #pragma clang diagnostic push
+0$    // Fix: https://github.com/nlohmann/json/issues/1401
+0$#if defined(__clang__)
+0$
+0${
+0$namespace std
+0$// And see https://github.com/nlohmann/json/pull/1391
+0$// For further reference see https://blog.tartanllama.xyz/structured-bindings/
+0$// Structured Bindings Support to the iteration_proxy_value class
+0$// The Addition to the STD Namespace is required to add
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    return i.value();
+0${
+0$auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
+0$template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
+0$// And see https://github.com/nlohmann/json/pull/1391
+0$// For further reference see https://blog.tartanllama.xyz/structured-bindings/
+0$// Structured Bindings Support
+0$}
+0$    return i.key();
+0${
+0$auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
+0$template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
+0$// And see https://github.com/nlohmann/json/pull/1391
+0$// For further reference see https://blog.tartanllama.xyz/structured-bindings/
+0$// Structured Bindings Support
+0$
+0$};
+0$    }
+0$        return iteration_proxy_value<IteratorType>(container->end());
+0$    {
+0$    iteration_proxy_value<IteratorType> end() const noexcept
+0$    /// return iterator end (needed for range-based for)
+0$
+0$    }
+0$        return iteration_proxy_value<IteratorType>(container->begin());
+0$    {
+0$    iteration_proxy_value<IteratorType> begin() const noexcept
+0$    /// return iterator begin (needed for range-based for)
+0$
+0$    ~iteration_proxy() = default;
+0$    iteration_proxy& operator=(iteration_proxy&&) noexcept = default;
+0$    iteration_proxy(iteration_proxy&&) noexcept = default;
+0$    iteration_proxy& operator=(iteration_proxy const&) = default;
+0$    iteration_proxy(iteration_proxy const&) = default;
+0$
+0$        : container(&cont) {}
+0$    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
+0$    /// construct iteration proxy from a container
+0$
+0$    explicit iteration_proxy() = default;
+0$  public:
+0$
+0$    typename IteratorType::pointer container = nullptr;
+0$    /// the container to iterate
+0$  private:
+0${
+0$template<typename IteratorType> class iteration_proxy
+0$/// proxy class for the items() function
+0$
+0$};
+0$    }
+0$        return anchor.value();
+0$    {
+0$    typename IteratorType::reference value() const
+0$    /// return value of the iterator
+0$
+0$    }
+0$        }
+0$                return empty_str;
+0$            default:
+0$            case value_t::discarded:
+0$            case value_t::binary:
+0$            case value_t::number_float:
+0$            case value_t::number_unsigned:
+0$            case value_t::number_integer:
+0$            case value_t::boolean:
+0$            case value_t::string:
+0$            case value_t::null:
+0$            // use an empty key for all primitive types
+0$
+0$                return anchor.key();
+0$            case value_t::object:
+0$            // use key from the object
+0$
+0$            }
+0$                return array_index_str;
+0$                }
+0$                    array_index_last = array_index;
+0$                    int_to_string( array_index_str, array_index );
+0$                {
+0$                if (array_index != array_index_last)
+0$            {
+0$            case value_t::array:
+0$            // use integer array index as key
+0$        {
+0$        switch (anchor.m_object->type())
+0$
+0$        JSON_ASSERT(anchor.m_object != nullptr);
+0$    {
+0$    const string_type& key() const
+0$    /// return key of the iterator
+0$
+0$    }
+0$        return anchor != o.anchor;
+0$    {
+0$    bool operator!=(const iteration_proxy_value& o) const
+0$    /// inequality operator (needed for range-based for)
+0$
+0$    }
+0$        return anchor == o.anchor;
+0$    {
+0$    bool operator==(const iteration_proxy_value& o) const
+0$    /// equality operator (needed for InputIterator)
+0$
+0$    }
+0$        return tmp;
+0$        ++array_index;
+0$        ++anchor;
+0$        auto tmp = iteration_proxy_value(anchor, array_index);
+0$    {
+0$    iteration_proxy_value operator++(int)& // NOLINT(cert-dcl21-cpp)
+0$
+0$    }
+0$        return *this;
+0$
+0$        ++array_index;
+0$        ++anchor;
+0$    {
+0$    iteration_proxy_value& operator++()
+0$    /// increment operator (needed for range-based for)
+0$
+0$    }
+0$        return *this;
+0$    {
+0$    const iteration_proxy_value& operator*() const
+0$    /// dereference operator (needed for range-based for)
+0$
+0$    ~iteration_proxy_value() = default;
+0$             && std::is_nothrow_move_assignable<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
+0$    noexcept(std::is_nothrow_move_assignable<IteratorType>::value
+0$    iteration_proxy_value& operator=(iteration_proxy_value&&)
+0$             && std::is_nothrow_move_constructible<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
+0$    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
+0$    iteration_proxy_value(iteration_proxy_value&&)
+0$    // older GCCs are a bit fussy and require explicit noexcept specifiers on defaulted functions
+0$    iteration_proxy_value& operator=(iteration_proxy_value const&) = default;
+0$    iteration_proxy_value(iteration_proxy_value const&) = default;
+0$
+0$    {}
+0$        , array_index(array_index_)
+0$        : anchor(std::move(it))
+0$             && std::is_nothrow_default_constructible<string_type>::value)
+0$    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
+0$    explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
+0$    explicit iteration_proxy_value() = default;
+0$  public:
+0$
+0$    string_type empty_str{};
+0$    /// an empty string (to return a reference for primitive values)
+0$    mutable string_type array_index_str = "0";
+0$    /// a string representation of the array index
+0$    mutable std::size_t array_index_last = 0;
+0$    /// last stringified array index
+0$    std::size_t array_index = 0;
+0$    /// an index for arrays (used to create key names)
+0$    IteratorType anchor{};
+0$    /// the iterator
+0$  private:
+0$
+0$    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;
+0$    using iterator_category = std::input_iterator_tag;
+0$    using reference = value_type &;
+0$    using pointer = value_type *;
+0$    using value_type = iteration_proxy_value;
+0$    using difference_type = std::ptrdiff_t;
+0$  public:
+0${
+0$template<typename IteratorType> class iteration_proxy_value
+0$}
+0$    target = to_string(value);
+0$    using std::to_string;
+0$    // For ADL
+0${
+0$void int_to_string( string_type& target, std::size_t value )
+0$template<typename string_type>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#endif
+0$    #include <ranges> // enable_borrowed_range
+0$#if JSON_HAS_RANGES
+0$
+0$#include <utility> // move
+0$#include <tuple> // tuple_size, get, tuple_element
+0$#include <string> // string, to_string
+0$#include <iterator> // input_iterator_tag
+0$#include <cstddef> // size_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/iteration_proxy.hpp>
+0$
+0$#include <vector> // vector
+0$#include <valarray> // valarray
+0$#include <utility> // move, forward, declval, pair
+0$#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
+0$#include <tuple> // tuple, get
+0$#include <string> // string
+0$#include <iterator> // begin, end
+0$#include <algorithm> // copy
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/conversions/to_json.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$#endif
+0$}  // namespace
+0$#ifndef JSON_HAS_CPP_17
+0$    detail::static_const<detail::from_json_fn>::value;
+0$JSON_INLINE_VARIABLE constexpr const auto& from_json = // NOLINT(misc-definitions-in-headers)
+0$#endif
+0${
+0$namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
+0$/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
+0$/// to see why this is required:
+0$/// namespace to hold default `from_json` function
+0$#ifndef JSON_HAS_CPP_17
+0$
+0$}  // namespace detail
+0$
+0$};
+0$    }
+0$        return from_json(j, std::forward<T>(val));
+0$    {
+0$    -> decltype(from_json(j, std::forward<T>(val)))
+0$    noexcept(noexcept(from_json(j, std::forward<T>(val))))
+0$    auto operator()(const BasicJsonType& j, T&& val) const
+0$    template<typename BasicJsonType, typename T>
+0${
+0$struct from_json_fn
+0$
+0$#endif
+0$}
+0$    p = *j.template get_ptr<const typename BasicJsonType::string_t*>();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
+0${
+0$inline void from_json(const BasicJsonType& j, std_fs::path& p)
+0$template<typename BasicJsonType>
+0$#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$
+0$}
+0$    }
+0$        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
+0$        }
+0$            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
+0$    {
+0$    for (const auto& p : j)
+0$    m.clear();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$inline void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
+0$                                        typename BasicJsonType::string_t, Key >::value >>
+0$           typename = enable_if_t < !std::is_constructible <
+0$template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
+0$
+0$}
+0$    }
+0$        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
+0$        }
+0$            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
+0$        {
+0$        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
+0$    {
+0$    for (const auto& p : j)
+0$    m.clear();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$inline void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
+0$                                        typename BasicJsonType::string_t, Key >::value >>
+0$           typename = enable_if_t < !std::is_constructible <
+0$template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
+0$
+0$}
+0$    return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$-> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
+0$auto from_json(BasicJsonType&& j, TupleRelated&& t)
+0$template<typename BasicJsonType, typename TupleRelated>
+0$
+0$}
+0$    t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
+0${
+0$inline void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> /*unused*/)
+0$template<typename BasicJsonType, typename... Args>
+0$
+0$}
+0$    return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
+0${
+0$std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> /*unused*/, priority_tag<2> /*unused*/)
+0$template<typename BasicJsonType, typename... Args>
+0$
+0$}
+0$    p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
+0${
+0$inline void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> /*unused*/)
+0$template<typename BasicJsonType, typename A1, typename A2>
+0$
+0$}
+0$            std::forward<BasicJsonType>(j).at(1).template get<A2>()};
+0$    return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
+0${
+0$std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> /*unused*/, priority_tag<0> /*unused*/)
+0$template < typename BasicJsonType, class A1, class A2 >
+0$
+0$}
+0$    return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);
+0${
+0$std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> /*unused*/)
+0$template<typename BasicJsonType, typename... Args, std::size_t... Idx>
+0$
+0$}
+0$    }
+0$            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
+0$        default:
+0$        case value_t::discarded:
+0$        case value_t::binary:
+0$        case value_t::string:
+0$        case value_t::array:
+0$        case value_t::object:
+0$        case value_t::null:
+0$
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
+0$        {
+0$        case value_t::boolean:
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
+0$        {
+0$        case value_t::number_float:
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
+0$        {
+0$        case value_t::number_integer:
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
+0$        {
+0$        case value_t::number_unsigned:
+0$    {
+0$    switch (static_cast<value_t>(j))
+0${
+0$inline void from_json(const BasicJsonType& j, ArithmeticType& val)
+0$               int > = 0 >
+0$               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
+0$               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
+0$               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
+0$               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
+0$               std::is_arithmetic<ArithmeticType>::value&&
+0$           enable_if_t <
+0$template < typename BasicJsonType, typename ArithmeticType,
+0$// an arithmetic type?
+0$// overloads for boolean_t etc. in case of a custom BooleanType which is not
+0$// (BooleanType, etc..); note: Is it really necessary to provide explicit
+0$// overload for arithmetic types, not chosen for basic_json template arguments
+0$
+0$}
+0$    obj = std::move(ret);
+0$    });
+0$        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
+0$    {
+0$        [](typename BasicJsonType::object_t::value_type const & p)
+0$        std::inserter(ret, ret.begin()),
+0$        inner_object->begin(), inner_object->end(),
+0$    std::transform(
+0$    using value_type = typename ConstructibleObjectType::value_type;
+0$    const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
+0$    ConstructibleObjectType ret;
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be object, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
+0${
+0$inline void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
+0$         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
+0$template<typename BasicJsonType, typename ConstructibleObjectType,
+0$
+0$}
+0$    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be binary, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$-> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
+0$auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
+0$template < typename BasicJsonType, typename T, std::size_t N >
+0$
+0$}
+0$    return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
+0${
+0$        identity_tag<std::array<T, sizeof...(Idx)>> /*unused*/, index_sequence<Idx...> /*unused*/)
+0$std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
+0$template < typename BasicJsonType, typename T, std::size_t... Idx >
+0$
+0$}
+0$    from_json_array_impl(j, arr, priority_tag<3> {});
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$void())
+0$j.template get<typename ConstructibleArrayType::value_type>(),
+0$-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
+0$auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
+0$               int > = 0 >
+0$               !is_basic_json<ConstructibleArrayType>::value,
+0$               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
+0$               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
+0$               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
+0$               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
+0$           enable_if_t <
+0$template < typename BasicJsonType, typename ConstructibleArrayType,
+0$
+0$}
+0$    arr = std::move(ret);
+0$    });
+0$        return i.template get<typename ConstructibleArrayType::value_type>();
+0$        // method when value_type is BasicJsonType
+0$        // get<BasicJsonType>() returns *this, this won't call a from_json
+0$    {
+0$        [](const BasicJsonType & i)
+0$        j.begin(), j.end(), std::inserter(ret, end(ret)),
+0$    std::transform(
+0$    ConstructibleArrayType ret;
+0$
+0$    using std::end;
+0${
+0$                                 priority_tag<0> /*unused*/)
+0$inline void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
+0$             int> = 0>
+0$             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
+0$         enable_if_t<
+0$template<typename BasicJsonType, typename ConstructibleArrayType,
+0$
+0$}
+0$    arr = std::move(ret);
+0$    });
+0$        return i.template get<typename ConstructibleArrayType::value_type>();
+0$        // method when value_type is BasicJsonType
+0$        // get<BasicJsonType>() returns *this, this won't call a from_json
+0$    {
+0$                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
+0$    std::transform(j.begin(), j.end(),
+0$    ret.reserve(j.size());
+0$    ConstructibleArrayType ret;
+0$
+0$    using std::end;
+0${
+0$    void())
+0$    j.template get<typename ConstructibleArrayType::value_type>(),
+0$    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
+0$-> decltype(
+0$auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
+0$             int> = 0>
+0$             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
+0$         enable_if_t<
+0$template<typename BasicJsonType, typename ConstructibleArrayType,
+0$
+0$}
+0$    }
+0$        arr[i] = j.at(i).template get<T>();
+0$    {
+0$    for (std::size_t i = 0; i < N; ++i)
+0${
+0$-> decltype(j.template get<T>(), void())
+0$                          priority_tag<2> /*unused*/)
+0$auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
+0$template<typename BasicJsonType, typename T, std::size_t N>
+0$
+0$}
+0$    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
+0${
+0$inline void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    }
+0$        arr[i] = j.at(i).template get<T>();
+0$    {
+0$    for (std::size_t i = 0; i < N; ++i)
+0${
+0$-> decltype(j.template get<T>(), void())
+0$auto from_json(const BasicJsonType& j, T (&arr)[N])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$template<typename BasicJsonType, typename T, std::size_t N>
+0$
+0$}
+0$    });
+0$        return elem.template get<T>();
+0$    {
+0$                   [](const BasicJsonType & elem)
+0$    std::transform(j.begin(), j.end(), std::begin(l),
+0$    l.resize(j.size());
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$inline void from_json(const BasicJsonType& j, std::valarray<T>& l)
+0$         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
+0$template<typename BasicJsonType, typename T,
+0$// valarray doesn't have an insert method
+0$
+0$}
+0$    });
+0$        return i.template get<T>();
+0$    {
+0$                   std::front_inserter(l), [](const BasicJsonType & i)
+0$    std::transform(j.rbegin(), j.rend(),
+0$    l.clear();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
+0${
+0$inline void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
+0$         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
+0$template<typename BasicJsonType, typename T, typename Allocator,
+0$// forward_list doesn't have an insert method
+0$
+0$#endif  // JSON_DISABLE_ENUM_SERIALIZATION
+0$}
+0$    e = static_cast<EnumType>(val);
+0$    get_arithmetic_value(j, val);
+0$    typename std::underlying_type<EnumType>::type val;
+0${
+0$inline void from_json(const BasicJsonType& j, EnumType& e)
+0$         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
+0$template<typename BasicJsonType, typename EnumType,
+0$#if !JSON_DISABLE_ENUM_SERIALIZATION
+0$
+0$}
+0$    get_arithmetic_value(j, val);
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    get_arithmetic_value(j, val);
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    get_arithmetic_value(j, val);
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
+0$
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
+0${
+0$inline void from_json(const BasicJsonType& j, StringType& s)
+0$        && !is_json_ref<StringType>::value, int > = 0 >
+0$        && !std::is_same<typename BasicJsonType::string_t, StringType>::value
+0$        && is_detected_exact<typename BasicJsonType::string_t::value_type, value_type_t, StringType>::value
+0$        std::is_assignable<StringType&, const typename BasicJsonType::string_t>::value
+0$    enable_if_t <
+0$    typename BasicJsonType, typename StringType,
+0$template <
+0$
+0$}
+0$    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be boolean, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
+0${
+0$inline void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
+0$template<typename BasicJsonType>
+0$
+0$}
+0$    }
+0$            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
+0$        default:
+0$        case value_t::discarded:
+0$        case value_t::binary:
+0$        case value_t::boolean:
+0$        case value_t::string:
+0$        case value_t::array:
+0$        case value_t::object:
+0$        case value_t::null:
+0$
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
+0$        {
+0$        case value_t::number_float:
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
+0$        {
+0$        case value_t::number_integer:
+0$        }
+0$            break;
+0$            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
+0$        {
+0$        case value_t::number_unsigned:
+0$    {
+0$    switch (static_cast<value_t>(j))
+0${
+0$void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
+0$                         int > = 0 >
+0$                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
+0$           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
+0$template < typename BasicJsonType, typename ArithmeticType,
+0$// overloads for basic_json template parameters
+0$
+0$}
+0$    n = nullptr;
+0$    }
+0$        JSON_THROW(type_error::create(302, concat("type must be null, but is ", j.type_name()), &j));
+0$    {
+0$    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
+0${
+0$inline void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
+0$template<typename BasicJsonType>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$#endif
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$namespace std_fs = std::filesystem;
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$#include <filesystem>
+0$#elif JSON_HAS_FILESYSTEM
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$namespace std_fs = std::experimental::filesystem;
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$#include <experimental/filesystem>
+0$#if JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/std_fs.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$template <class T> struct identity_tag {};
+0$// dispatching helper struct
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/identity_tag.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
+0$    JSON_HEDLEY_NON_NULL(3)
+0$  private:
+0$
+0$    }
+0$        return {id_, w.c_str()};
+0$        const std::string w = concat(exception::name("other_error", id_), exception::diagnostics(context), what_arg);
+0$    {
+0$    static other_error create(int id_, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$  public:
+0${
+0$class other_error : public exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/other_error/
+0$/// @brief exception indicating other library errors
+0$
+0$};
+0$    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
+0$    JSON_HEDLEY_NON_NULL(3)
+0$  private:
+0$
+0$    }
+0$        return {id_, w.c_str()};
+0$        const std::string w = concat(exception::name("out_of_range", id_), exception::diagnostics(context), what_arg);
+0$    {
+0$    static out_of_range create(int id_, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$  public:
+0${
+0$class out_of_range : public exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/out_of_range/
+0$/// @brief exception indicating access out of the defined range
+0$
+0$};
+0$    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
+0$    JSON_HEDLEY_NON_NULL(3)
+0$  private:
+0$
+0$    }
+0$        return {id_, w.c_str()};
+0$        const std::string w = concat(exception::name("type_error", id_), exception::diagnostics(context), what_arg);
+0$    {
+0$    static type_error create(int id_, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$  public:
+0${
+0$class type_error : public exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/type_error/
+0$/// @brief exception indicating executing a member function with a wrong type
+0$
+0$};
+0$        : exception(id_, what_arg) {}
+0$    invalid_iterator(int id_, const char* what_arg)
+0$    JSON_HEDLEY_NON_NULL(3)
+0$  private:
+0$
+0$    }
+0$        return {id_, w.c_str()};
+0$        const std::string w = concat(exception::name("invalid_iterator", id_), exception::diagnostics(context), what_arg);
+0$    {
+0$    static invalid_iterator create(int id_, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$  public:
+0${
+0$class invalid_iterator : public exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/invalid_iterator/
+0$/// @brief exception indicating errors with iterators
+0$
+0$};
+0$    }
+0$                      ", column ", std::to_string(pos.chars_read_current_line));
+0$        return concat(" at line ", std::to_string(pos.lines_read + 1),
+0$    {
+0$    static std::string position_string(const position_t& pos)
+0$
+0$        : exception(id_, what_arg), byte(byte_) {}
+0$    parse_error(int id_, std::size_t byte_, const char* what_arg)
+0$  private:
+0$
+0$    const std::size_t byte;
+0$    */
+0$          This also holds true when reading a byte vector (CBOR or MessagePack).
+0$          n+1 is the index of the terminating null byte or the end of file.
+0$    @note For an input with n bytes, 1 is the index of the first character and
+0$
+0$    The byte index of the last read character in the input file.
+0$
+0$    @brief byte index of the parse error
+0$    /*!
+0$
+0$    }
+0$        return {id_, byte_, w.c_str()};
+0$                                     ": ", exception::diagnostics(context), what_arg);
+0$                                     (byte_ != 0 ? (concat(" at byte ", std::to_string(byte_))) : ""),
+0$        const std::string w = concat(exception::name("parse_error", id_), "parse error",
+0$    {
+0$    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$
+0$    }
+0$        return {id_, pos.chars_read_total, w.c_str()};
+0$                                     position_string(pos), ": ", exception::diagnostics(context), what_arg);
+0$        const std::string w = concat(exception::name("parse_error", id_), "parse error",
+0$    {
+0$    static parse_error create(int id_, const position_t& pos, const std::string& what_arg, BasicJsonContext context)
+0$    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
+0$    */
+0$    @return parse_error object
+0$    @param[in] what_arg  the explanatory string
+0$                         determined)
+0$                         chars_read_total=0 if the position cannot be
+0$    @param[in] pos       the position where the error occurred (or with
+0$    @param[in] id_       the id of the exception
+0$    @brief create a parse error exception
+0$    /*!
+0$  public:
+0${
+0$class parse_error : public exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/parse_error/
+0$/// @brief exception indicating a parse error
+0$
+0$};
+0$    std::runtime_error m;
+0$    /// an exception object as storage for error messages
+0$  private:
+0$
+0$    }
+0$#endif
+0$        return "";
+0$        static_cast<void>(leaf_element);
+0$#else
+0$        return concat('(', str, ") ");
+0$        });
+0$            return concat(a, '/', detail::escape(b));
+0$        {
+0$                                   [](const std::string & a, const std::string & b)
+0$        auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
+0$
+0$        }
+0$            return "";
+0$        {
+0$        if (tokens.empty())
+0$
+0$        }
+0$            }
+0$                    break; // LCOV_EXCL_LINE
+0$                default:   // LCOV_EXCL_LINE
+0$                case value_t::discarded: // LCOV_EXCL_LINE
+0$                case value_t::binary: // LCOV_EXCL_LINE
+0$                case value_t::number_float: // LCOV_EXCL_LINE
+0$                case value_t::number_unsigned: // LCOV_EXCL_LINE
+0$                case value_t::number_integer: // LCOV_EXCL_LINE
+0$                case value_t::boolean: // LCOV_EXCL_LINE
+0$                case value_t::string: // LCOV_EXCL_LINE
+0$                case value_t::null: // LCOV_EXCL_LINE
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        }
+0$                            break;
+0$                            tokens.emplace_back(element.first.c_str());
+0$                        {
+0$                        if (&element.second == current)
+0$                    {
+0$                    for (const auto& element : *current->m_parent->m_data.m_value.object)
+0$                {
+0$                case value_t::object:
+0$
+0$                }
+0$                    break;
+0$                    }
+0$                        }
+0$                            break;
+0$                            tokens.emplace_back(std::to_string(i));
+0$                        {
+0$                        if (&current->m_parent->m_data.m_value.array->operator[](i) == current)
+0$                    {
+0$                    for (std::size_t i = 0; i < current->m_parent->m_data.m_value.array->size(); ++i)
+0$                {
+0$                case value_t::array:
+0$            {
+0$            switch (current->m_parent->type())
+0$        {
+0$        for (const auto* current = leaf_element; current != nullptr && current->m_parent != nullptr; current = current->m_parent)
+0$        std::vector<std::string> tokens;
+0$#if JSON_DIAGNOSTICS
+0$    {
+0$    static std::string diagnostics(const BasicJsonType* leaf_element)
+0$    template<typename BasicJsonType>
+0$
+0$    }
+0$        return "";
+0$    {
+0$    static std::string diagnostics(std::nullptr_t /*leaf_element*/)
+0$
+0$    }
+0$        return concat("[json.exception.", ename, '.', std::to_string(id_), "] ");
+0$    {
+0$    static std::string name(const std::string& ename, int id_)
+0$
+0$    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} // NOLINT(bugprone-throw-keyword-missing)
+0$    JSON_HEDLEY_NON_NULL(3)
+0$  protected:
+0$
+0$    const int id; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)
+0$    /// the id of the exception
+0$
+0$    }
+0$        return m.what();
+0$    {
+0$    const char* what() const noexcept override
+0$    /// returns the explanatory string
+0$  public:
+0${
+0$class exception : public std::exception
+0$/// @sa https://json.nlohmann.me/api/basic_json/exception/
+0$/// @brief general exception of the @ref basic_json class
+0$
+0$////////////////
+0$// exceptions //
+0$////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    return str;
+0$    concat_into(str, std::forward<Args>(args)...);
+0$    str.reserve(concat_length(args...));
+0$    OutStringType str;
+0${
+0$inline OutStringType concat(Args && ... args)
+0$template<typename OutStringType = std::string, typename... Args>
+0$
+0$}
+0$    concat_into(out, std::forward<Args>(rest)...);
+0$    out.append(arg.data(), arg.size());
+0${
+0$inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
+0$                         && detect_string_can_append_data<OutStringType, Arg>::value, int > >
+0$                         && !detect_string_can_append_iter<OutStringType, Arg>::value
+0$                         && !detect_string_can_append_op<OutStringType, Arg>::value
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$}
+0$    concat_into(out, std::forward<Args>(rest)...);
+0$    out.append(arg.begin(), arg.end());
+0${
+0$inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
+0$                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > >
+0$                         && !detect_string_can_append_op<OutStringType, Arg>::value
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$}
+0$    concat_into(out, std::forward<Args>(rest)...);
+0$    out += std::forward<Arg>(arg);
+0${
+0$inline void concat_into(OutStringType& out, Arg&& arg, Args&& ... rest)
+0$                         && detect_string_can_append_op<OutStringType, Arg>::value, int > >
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$}
+0$    concat_into(out, std::forward<Args>(rest)...);
+0$    out.append(std::forward<Arg>(arg));
+0${
+0$inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest)
+0$         enable_if_t<detect_string_can_append<OutStringType, Arg>::value, int> = 0>
+0$template<typename OutStringType, typename Arg, typename... Args,
+0$
+0$inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);
+0$                         && detect_string_can_append_data<OutStringType, Arg>::value, int > = 0 >
+0$                         && !detect_string_can_append_iter<OutStringType, Arg>::value
+0$                         && !detect_string_can_append_op<OutStringType, Arg>::value
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);
+0$                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > = 0 >
+0$                         && !detect_string_can_append_op<OutStringType, Arg>::value
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest);
+0$                         && detect_string_can_append_op<OutStringType, Arg>::value, int > = 0 >
+0$           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
+0$template < typename OutStringType, typename Arg, typename... Args,
+0$
+0$using detect_string_can_append_data = is_detected<string_can_append_data, StringType, Arg>;
+0$template<typename StringType, typename Arg>
+0$
+0$using string_can_append_data = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().data(), std::declval<const Arg&>().size()));
+0$template<typename StringType, typename Arg>
+0$
+0$using detect_string_can_append_iter = is_detected<string_can_append_iter, StringType, Arg>;
+0$template<typename StringType, typename Arg>
+0$
+0$using string_can_append_iter = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().begin(), std::declval<const Arg&>().end()));
+0$template<typename StringType, typename Arg>
+0$
+0$using detect_string_can_append_op = is_detected<string_can_append_op, StringType, Arg>;
+0$template<typename StringType, typename Arg>
+0$
+0$using string_can_append_op = decltype(std::declval<StringType&>() += std::declval < Arg && > ());
+0$template<typename StringType, typename Arg>
+0$
+0$using detect_string_can_append = is_detected<string_can_append, StringType, Arg>;
+0$template<typename StringType, typename Arg>
+0$
+0$using string_can_append = decltype(std::declval<StringType&>().append(std::declval < Arg && > ()));
+0$template<typename StringType, typename Arg>
+0$
+0${}
+0$inline void concat_into(OutStringType& /*out*/)
+0$template<typename OutStringType>
+0$
+0$}
+0$    return str.size() + concat_length(rest...);
+0${
+0$inline std::size_t concat_length(const StringType& str, const Args& ... rest)
+0$template<typename StringType, typename... Args>
+0$
+0$}
+0$    return ::strlen(cstr) + concat_length(rest...);
+0$    // cppcheck-suppress ignoredReturnValue
+0${
+0$inline std::size_t concat_length(const char* cstr, const Args& ... rest)
+0$template<typename... Args>
+0$
+0$}
+0$    return 1 + concat_length(rest...);
+0${
+0$inline std::size_t concat_length(const char /*c*/, const Args& ... rest)
+0$template<typename... Args>
+0$
+0$inline std::size_t concat_length(const StringType& str, const Args& ... rest);
+0$template<typename StringType, typename... Args>
+0$
+0$inline std::size_t concat_length(const char* cstr, const Args& ... rest);
+0$template<typename... Args>
+0$
+0$}
+0$    return 0;
+0${
+0$inline std::size_t concat_length()
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/detected.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$#include <utility> // forward
+0$#include <string> // string
+0$#include <cstring> // strlen
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/string_concat.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$///////////////////////////////////////////////////////////////////////////////
+0$
+0$struct is_transparent : bool_constant<impl::is_transparent<T>()> {};
+0$template<typename T>
+0$// checks whether T has a member named is_transparent
+0$
+0$}  // namespace impl
+0$
+0$}
+0$    return is_detected<detect_is_transparent, T>::value;
+0${
+0$inline constexpr bool is_transparent()
+0$template<typename T>
+0$
+0${
+0$namespace impl
+0$
+0$///////////////////////////////////////////////////////////////////////////////
+0$// is_transparent
+0$///////////////////////////////////////////////////////////////////////////////
+0$
+0$using is_c_string_uncvref = is_c_string<uncvref_t<T>>;
+0$template<typename T>
+0$
+0$struct is_c_string : bool_constant<impl::is_c_string<T>()> {};
+0$template<typename T>
+0$// checks whether T is a [cv] char */[cv] char[] C string
+0$
+0$}  // namespace impl
+0$
+0$}
+0$        || (std::is_pointer<T>::value && std::is_same<TUnCVPtr, char>::value);
+0$        (std::is_array<T>::value && std::is_same<TUnCVExt, char>::value)
+0$    return
+0$    using TUnCVPtr = typename std::remove_cv<TUnPtr>::type;
+0$    using TUnPtr = typename std::remove_pointer<T>::type;
+0$    using TUnCVExt = typename std::remove_cv<TUnExt>::type;
+0$    using TUnExt = typename std::remove_extent<T>::type;
+0${
+0$inline constexpr bool is_c_string()
+0$template<typename T>
+0$
+0${
+0$namespace impl
+0$
+0$///////////////////////////////////////////////////////////////////////////////
+0$// is_c_string
+0$///////////////////////////////////////////////////////////////////////////////
+0$
+0$using bool_constant = std::integral_constant<bool, Value>;
+0$template<bool Value>
+0$
+0$}
+0$    return value_in_range_of_impl1<OfType, T>::test(val);
+0${
+0$inline constexpr bool value_in_range_of(T val)
+0$template<typename OfType, typename T>
+0$
+0$};
+0$    }
+0$        return true;
+0$    {
+0$    static constexpr bool test(T /*val*/)
+0${
+0$struct value_in_range_of_impl1<OfType, T, true>
+0$template<typename OfType, typename T>
+0$
+0$};
+0$    }
+0$        return value_in_range_of_impl2<OfType, T>::test(val);
+0$    {
+0$    static constexpr bool test(T val)
+0${
+0$struct value_in_range_of_impl1<OfType, T, false>
+0$template<typename OfType, typename T>
+0$
+0$struct value_in_range_of_impl1;
+0$         typename = detail::enable_if_t<all_integral<OfType, T>::value>>
+0$         bool NeverOutOfRange = never_out_of_range<OfType, T>::value,
+0$template<typename OfType, typename T,
+0$
+0$};
+0$    }
+0$               && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
+0$        return static_cast<CommonType>(val) >= static_cast<CommonType>((std::numeric_limits<OfType>::min)())
+0$        using CommonType = typename std::common_type<OfType, T>::type;
+0$    {
+0$    static constexpr bool test(T val)
+0${
+0$struct value_in_range_of_impl2<OfType, T, true, true>
+0$template<typename OfType, typename T>
+0$
+0$};
+0$    }
+0$        return val >= 0 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
+0$        using CommonType = typename std::common_type<OfType, T>::type;
+0$    {
+0$    static constexpr bool test(T val)
+0${
+0$struct value_in_range_of_impl2<OfType, T, false, true>
+0$template<typename OfType, typename T>
+0$
+0$};
+0$    }
+0$        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
+0$        using CommonType = typename std::common_type<OfType, T>::type;
+0$    {
+0$    static constexpr bool test(T val)
+0${
+0$struct value_in_range_of_impl2<OfType, T, true, false>
+0$template<typename OfType, typename T>
+0$
+0$};
+0$    }
+0$        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
+0$        using CommonType = typename std::common_type<OfType, T>::type;
+0$    {
+0$    static constexpr bool test(T val)
+0${
+0$struct value_in_range_of_impl2<OfType, T, false, false>
+0$template<typename OfType, typename T>
+0$
+0$struct value_in_range_of_impl2;
+0$         bool TSigned = std::is_signed<T>::value>
+0$         bool OfTypeSigned = std::is_signed<OfType>::value,
+0$template<typename OfType, typename T,
+0$
+0$      || (same_sign<OfType, T>::value && sizeof(OfType) == sizeof(T)) >;
+0$      (std::is_signed<OfType>::value && (sizeof(T) < sizeof(OfType)))
+0$using never_out_of_range = std::integral_constant < bool,
+0$template<typename OfType, typename T>
+0$
+0$      all_signed<Types...>::value || all_unsigned<Types...>::value >;
+0$using same_sign = std::integral_constant < bool,
+0$template<typename... Types>
+0$// there's a disjunction trait in another PR; replace when merged
+0$
+0$using all_unsigned = conjunction<std::is_unsigned<Types>...>;
+0$template<typename... Types>
+0$
+0$using all_signed = conjunction<std::is_signed<Types>...>;
+0$template<typename... Types>
+0$
+0$using all_integral = conjunction<std::is_integral<Types>...>;
+0$template<typename... Types>
+0$
+0$}
+0$    return value;
+0${
+0$T conditional_static_cast(U value)
+0$template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
+0$
+0$}
+0$    return static_cast<T>(value);
+0${
+0$T conditional_static_cast(U value)
+0$template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
+0$// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)
+0$
+0$};
+0$    enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
+0$
+0$    template <typename C> static two test(...);
+0$    template <typename C> static one test( decltype(&C::capacity) ) ;
+0$
+0$    };
+0$        char x[2]; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
+0$    {
+0$    struct two
+0$
+0$    using one = char;
+0${
+0$struct is_ordered_map
+0$template <typename T>
+0$// ordered_map inherits capacity() from std::vector)
+0$// a naive helper to check if a type is an ordered_map (exploits the fact that
+0$
+0$                                std::false_type >::type;
+0$                                std::true_type,
+0$                                typename BasicJsonType::object_t, KeyType >::value,
+0$                                detect_erase_with_key_type,
+0$                                is_detected <
+0$using has_erase_with_key_type = typename std::conditional <
+0$template<typename BasicJsonType, typename KeyType>
+0$// type trait to check if object_t has an erase() member functions accepting KeyType
+0$
+0$using detect_erase_with_key_type = decltype(std::declval<ObjectType&>().erase(std::declval<KeyType>()));
+0$template<typename ObjectType, typename KeyType>
+0$
+0$        std::false_type >::type;
+0$        std::true_type,
+0$        && !is_json_iterator_of<BasicJsonType, KeyType>::value,
+0$        RequireTransparentComparator, ExcludeObjectKeyType>::value
+0$        typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
+0$        is_usable_as_key_type<typename BasicJsonType::object_comparator_t,
+0$using is_usable_as_basic_json_key_type = typename std::conditional <
+0$         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
+0$template<typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
+0$//   - KeyType is not a JSON iterator or json_pointer
+0$//   - the comparator is transparent or RequireTransparentComparator is false
+0$//   - if ExcludeObjectKeyType is true, KeyType is not BasicJsonType::object_t::key_type
+0$//   - KeyType is comparable with BasicJsonType::object_t::key_type
+0$// true if:
+0$// type trait to check if KeyType can be used as object key
+0$
+0$                              std::false_type >::type;
+0$                              std::true_type,
+0$                              && !is_json_pointer<KeyType>::value,
+0$                                  || is_detected <detect_is_transparent, Comparator>::value)
+0$                              && (!RequireTransparentComparator
+0$                                   ObjectKeyType>::value)
+0$                              && !(ExcludeObjectKeyType && std::is_same<KeyType,
+0$                              is_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value
+0$using is_usable_as_key_type = typename std::conditional <
+0$         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
+0$template<typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
+0$// see is_usable_as_basic_json_key_type below
+0$// type trait to check if KeyType can be used as object key (without a BasicJsonType)
+0$
+0$using detect_is_transparent = typename T::is_transparent;
+0$template<typename T>
+0$
+0$>> : std::true_type {};
+0$decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))
+0$decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>())),
+0$struct is_comparable<Compare, A, B, void_t<
+0$template<typename Compare, typename A, typename B>
+0$
+0$struct is_comparable : std::false_type {};
+0$template<typename Compare, typename A, typename B, typename = void>
+0$// checks if A and B are comparable using Compare functor
+0$
+0$using is_json_pointer = is_specialization_of<::nlohmann::json_pointer, uncvref_t<T>>;
+0$template<typename T>
+0$
+0$struct is_specialization_of<Primary, Primary<Args...>> : std::true_type {};
+0$template<template <typename...> class Primary, typename... Args>
+0$
+0$struct is_specialization_of : std::false_type {};
+0$template<template <typename...> class Primary, typename T>
+0$// checks if a given type T is a template specialization of Primary
+0$
+0${};
+0$struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::const_iterator> : std::true_type
+0$template<typename BasicJsonType>
+0$
+0$struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::iterator> : std::true_type {};
+0$template<typename BasicJsonType>
+0$
+0$struct is_json_iterator_of : std::false_type {};
+0$template<typename BasicJsonType, typename T>
+0$
+0$struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};
+0$template<typename T1, typename... Args>
+0$
+0$struct is_constructible_tuple : std::false_type {};
+0$template<typename T1, typename T2>
+0$
+0$    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};
+0$struct is_compatible_type
+0$template<typename BasicJsonType, typename CompatibleType>
+0$
+0$};
+0$        has_to_json<BasicJsonType, CompatibleType>::value;
+0$    static constexpr bool value =
+0${
+0$    enable_if_t<is_complete_type<CompatibleType>::value >>
+0$    BasicJsonType, CompatibleType,
+0$struct is_compatible_type_impl <
+0$template<typename BasicJsonType, typename CompatibleType>
+0$
+0$struct is_compatible_type_impl: std::false_type {};
+0$template<typename BasicJsonType, typename CompatibleType, typename = void>
+0$
+0$      CompatibleNumberIntegerType> {};
+0$    : is_compatible_integer_type_impl<RealIntegerType,
+0$struct is_compatible_integer_type
+0$template<typename RealIntegerType, typename CompatibleNumberIntegerType>
+0$
+0$};
+0$        RealLimits::is_signed == CompatibleLimits::is_signed;
+0$        CompatibleLimits::is_integer &&
+0$        CompatibleNumberIntegerType>::value &&
+0$        is_constructible<RealIntegerType,
+0$    static constexpr auto value =
+0$
+0$    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;
+0$    using RealLimits = std::numeric_limits<RealIntegerType>;
+0$    // is there an assert somewhere on overflows?
+0${
+0$    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
+0$    std::is_integral<CompatibleNumberIntegerType>::value&&
+0$    enable_if_t < std::is_integral<RealIntegerType>::value&&
+0$    RealIntegerType, CompatibleNumberIntegerType,
+0$struct is_compatible_integer_type_impl <
+0$template<typename RealIntegerType, typename CompatibleNumberIntegerType>
+0$
+0$struct is_compatible_integer_type_impl : std::false_type {};
+0$         typename = void>
+0$template<typename RealIntegerType, typename CompatibleNumberIntegerType,
+0$
+0$    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};
+0$struct is_constructible_array_type
+0$template<typename BasicJsonType, typename ConstructibleArrayType>
+0$
+0$};
+0$        value_type >::value;
+0$        BasicJsonType,
+0$        has_non_default_from_json <
+0$        value_type>::value ||
+0$        has_from_json<BasicJsonType,
+0$        typename BasicJsonType::array_t::value_type>::value ||
+0$        std::is_same<value_type,
+0$    static constexpr bool value =
+0$
+0$    using value_type = range_value_t<ConstructibleArrayType>;
+0${
+0$        detected_t<range_value_t, ConstructibleArrayType >>::value >>
+0$        is_complete_type <
+0$!std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&
+0$// c.f. https://github.com/nlohmann/json/pull/3073
+0$// special case for types like std::filesystem::path whose iterator's value_type are themselves
+0$is_detected<range_value_t, ConstructibleArrayType>::value&&
+0$is_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&
+0$is_detected<iterator_t, ConstructibleArrayType>::value&&
+0$ std::is_copy_assignable<ConstructibleArrayType>::value)&&
+0$(std::is_move_assignable<ConstructibleArrayType>::value ||
+0$    is_default_constructible<ConstructibleArrayType>::value&&
+0$    !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
+0$    typename BasicJsonType::value_type>::value&&
+0$    enable_if_t < !std::is_same<ConstructibleArrayType,
+0$    BasicJsonType, ConstructibleArrayType,
+0$struct is_constructible_array_type_impl <
+0$template<typename BasicJsonType, typename ConstructibleArrayType>
+0$
+0$            : std::true_type {};
+0$    typename BasicJsonType::value_type>::value >>
+0$    enable_if_t<std::is_same<ConstructibleArrayType,
+0$    BasicJsonType, ConstructibleArrayType,
+0$struct is_constructible_array_type_impl <
+0$template<typename BasicJsonType, typename ConstructibleArrayType>
+0$
+0$struct is_constructible_array_type_impl : std::false_type {};
+0$template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
+0$
+0$    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};
+0$struct is_compatible_array_type
+0$template<typename BasicJsonType, typename CompatibleArrayType>
+0$
+0$};
+0$        range_value_t<CompatibleArrayType>>::value;
+0$        is_constructible<BasicJsonType,
+0$    static constexpr bool value =
+0${
+0$    !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>
+0$// c.f. https://github.com/nlohmann/json/pull/3073
+0$// special case for types like std::filesystem::path whose iterator's value_type are themselves
+0$    is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&
+0$    is_detected<iterator_t, CompatibleArrayType>::value&&
+0$    enable_if_t <
+0$    BasicJsonType, CompatibleArrayType,
+0$struct is_compatible_array_type_impl <
+0$template<typename BasicJsonType, typename CompatibleArrayType>
+0$
+0$struct is_compatible_array_type_impl : std::false_type {};
+0$template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
+0$
+0$};
+0$        value_type_t, laundered_type >>::value;
+0$        is_detected_exact<typename BasicJsonType::string_t::value_type,
+0$        is_constructible<laundered_type, typename BasicJsonType::string_t>,
+0$        conjunction <
+0$    static constexpr auto value =
+0$
+0$#endif
+0$    using laundered_type = ConstructibleStringType;
+0$#else
+0$    using laundered_type = decltype(std::declval<ConstructibleStringType>());
+0$#ifdef __INTEL_COMPILER
+0$    // launder type through decltype() to fix compilation failure on ICPC
+0${
+0$struct is_constructible_string_type
+0$template<typename BasicJsonType, typename ConstructibleStringType>
+0$
+0$};
+0$        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
+0$    static constexpr auto value =
+0${
+0$struct is_compatible_string_type
+0$template<typename BasicJsonType, typename CompatibleStringType>
+0$
+0$      ConstructibleObjectType> {};
+0$    : is_constructible_object_type_impl<BasicJsonType,
+0$struct is_constructible_object_type
+0$template<typename BasicJsonType, typename ConstructibleObjectType>
+0$
+0$};
+0$         typename ConstructibleObjectType::mapped_type >::value);
+0$         BasicJsonType,
+0$         has_non_default_from_json <
+0$         typename ConstructibleObjectType::mapped_type>::value ||
+0$        (has_from_json<BasicJsonType,
+0$          typename ConstructibleObjectType::mapped_type >::value)) ||
+0$          typename object_t::mapped_type,
+0$          std::is_same <
+0$          typename object_t::key_type>::value &&
+0$         (is_constructible<typename ConstructibleObjectType::key_type,
+0$          std::is_copy_assignable<ConstructibleObjectType>::value) &&
+0$         (std::is_move_assignable<ConstructibleObjectType>::value ||
+0$        (is_default_constructible<ConstructibleObjectType>::value &&
+0$    static constexpr bool value =
+0$
+0$    using object_t = typename BasicJsonType::object_t;
+0${
+0$    is_detected<key_type_t, ConstructibleObjectType>::value >>
+0$    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
+0$    BasicJsonType, ConstructibleObjectType,
+0$struct is_constructible_object_type_impl <
+0$template<typename BasicJsonType, typename ConstructibleObjectType>
+0$
+0$struct is_constructible_object_type_impl : std::false_type {};
+0$         typename = void>
+0$template<typename BasicJsonType, typename ConstructibleObjectType,
+0$
+0$    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};
+0$struct is_compatible_object_type
+0$template<typename BasicJsonType, typename CompatibleObjectType>
+0$
+0$};
+0$        typename CompatibleObjectType::mapped_type>::value;
+0$        is_constructible<typename object_t::mapped_type,
+0$        typename CompatibleObjectType::key_type>::value &&
+0$        is_constructible<typename object_t::key_type,
+0$    static constexpr bool value =
+0$    // macOS's is_constructible does not play well with nonesuch...
+0$
+0$    using object_t = typename BasicJsonType::object_t;
+0${
+0$    is_detected<key_type_t, CompatibleObjectType>::value >>
+0$    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
+0$    BasicJsonType, CompatibleObjectType,
+0$struct is_compatible_object_type_impl <
+0$template<typename BasicJsonType, typename CompatibleObjectType>
+0$
+0$struct is_compatible_object_type_impl : std::false_type {};
+0$         typename = void>
+0$template<typename BasicJsonType, typename CompatibleObjectType,
+0$
+0$struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};
+0$template<typename T>
+0$
+0$struct is_complete_type : std::false_type {};
+0$template<typename T, typename = void>
+0$
+0$// and is written by Xiang Fan who agreed to using it in this library.
+0$// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/
+0$// The following implementation of is_complete_type is taken from
+0$
+0$using range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;
+0$template<typename T>
+0$
+0$using iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;
+0$template<typename R>
+0$
+0$};
+0$    static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;
+0$  public:
+0$
+0$        is_iterator_traits<iterator_traits<iterator>>::value;
+0$    static constexpr auto is_iterator_begin =
+0$    // but reimplementing these would be too much work, as a lot of other concepts are used underneath
+0$    // and https://en.cppreference.com/w/cpp/iterator/sentinel_for
+0$    // to be 100% correct, it should use https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator
+0$
+0$    using sentinel = detected_t<result_of_end, t_ref>;
+0$    using iterator = detected_t<result_of_begin, t_ref>;
+0$
+0$    using t_ref = typename std::add_lvalue_reference<T>::type;
+0$  private:
+0${
+0$struct is_range
+0$template<typename T>
+0$
+0$};
+0$        is_detected<reference_t, traits>::value;
+0$        is_detected<iterator_category_t, traits>::value &&
+0$        is_detected<pointer_t, traits>::value &&
+0$        is_detected<difference_type_t, traits>::value &&
+0$        is_detected<value_type_t, traits>::value &&
+0$    static constexpr auto value =
+0$  public:
+0$
+0$    using traits = iterator_traits<T>;
+0$  private:
+0${
+0$struct is_iterator_traits<iterator_traits<T>>
+0$template<typename T>
+0$
+0$struct is_iterator_traits : std::false_type {};
+0$template<typename T, typename = void>
+0$
+0$struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};
+0$template <typename... Ts>
+0$
+0$struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};
+0$template <typename... Ts>
+0$
+0$struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};
+0$template <typename T1, typename T2>
+0$
+0$struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};
+0$template <typename T1, typename T2>
+0$
+0$struct is_constructible : std::is_constructible<T, Args...> {};
+0$template <typename T, typename... Args>
+0$
+0$            : conjunction<is_default_constructible<Ts>...> {};
+0$struct is_default_constructible<const std::tuple<Ts...>>
+0$template <typename... Ts>
+0$
+0$            : conjunction<is_default_constructible<Ts>...> {};
+0$struct is_default_constructible<std::tuple<Ts...>>
+0$template <typename... Ts>
+0$
+0$            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
+0$struct is_default_constructible<const std::pair<T1, T2>>
+0$template <typename T1, typename T2>
+0$
+0$            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
+0$struct is_default_constructible<std::pair<T1, T2>>
+0$template <typename T1, typename T2>
+0$
+0$struct is_default_constructible : std::is_default_constructible<T> {};
+0$template <typename T>
+0$// This causes compile errors in e.g. clang 3.5 or gcc 4.9.
+0$// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).
+0$// Reimplementation of is_constructible and is_default_constructible, due to them being broken for
+0$
+0$template<class B> struct negation : std::integral_constant < bool, !B::value > { };
+0$// https://en.cppreference.com/w/cpp/types/negation
+0$
+0$: std::conditional<static_cast<bool>(B::value), conjunction<Bn...>, B>::type {};
+0$struct conjunction<B, Bn...>
+0$template<class B, class... Bn>
+0$template<class B> struct conjunction<B> : B { };
+0$template<class...> struct conjunction : std::true_type { };
+0$// https://en.cppreference.com/w/cpp/types/conjunction
+0$
+0$///////////////////
+0$// is_ functions //
+0$///////////////////
+0$
+0$};
+0$    }
+0$        return static_cast<int_type>(EOF);
+0$    {
+0$    static constexpr int_type eof() noexcept
+0$
+0$    }
+0$        return static_cast<char_type>(i);
+0$    {
+0$    static char_type to_char_type(int_type i) noexcept
+0$
+0$    }
+0$        return static_cast<int_type>(c);
+0$    {
+0$    static int_type to_int_type(char_type c) noexcept
+0$    // Redefine to_int_type function
+0$
+0$    using int_type = uint64_t;
+0$    using char_type = signed char;
+0${
+0$struct char_traits<signed char> : std::char_traits<char>
+0$template<>
+0$// Explicitly define char traits for signed char since it is not standard
+0$
+0$};
+0$    }
+0$        return static_cast<int_type>(EOF);
+0$    {
+0$    static constexpr int_type eof() noexcept
+0$
+0$    }
+0$        return static_cast<char_type>(i);
+0$    {
+0$    static char_type to_char_type(int_type i) noexcept
+0$
+0$    }
+0$        return static_cast<int_type>(c);
+0$    {
+0$    static int_type to_int_type(char_type c) noexcept
+0$    // Redefine to_int_type function
+0$
+0$    using int_type = uint64_t;
+0$    using char_type = unsigned char;
+0${
+0$struct char_traits<unsigned char> : std::char_traits<char>
+0$template<>
+0$// Explicitly define char traits for unsigned char since it is not standard
+0$
+0${};
+0$struct char_traits : std::char_traits<T>
+0$template<typename T>
+0$// Primary template of char_traits calls std char_traits
+0$
+0$/////////////////
+0$// char_traits //
+0$/////////////////
+0$
+0$using actual_object_comparator_t = typename actual_object_comparator<BasicJsonType>::type;
+0$template<typename BasicJsonType>
+0$
+0$};
+0$          typename object_t::key_compare, object_comparator_t>::type;
+0$    using type = typename std::conditional < has_key_compare<object_t>::value,
+0$    using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
+0$    using object_t = typename BasicJsonType::object_t;
+0${
+0$struct actual_object_comparator
+0$template<typename BasicJsonType>
+0$// obtains the actual object key comparator
+0$
+0$struct has_key_compare : std::integral_constant<bool, is_detected<detect_key_compare, T>::value> {};
+0$template<typename T>
+0$
+0$using detect_key_compare = typename T::key_compare;
+0$template<typename T>
+0$
+0$};
+0$        T>::value;
+0$        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
+0$    static constexpr bool value =
+0$
+0$    using serializer = typename BasicJsonType::template json_serializer<T, void>;
+0${
+0$struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
+0$template<typename BasicJsonType, typename T>
+0$
+0$struct has_to_json : std::false_type {};
+0$template<typename BasicJsonType, typename T, typename = void>
+0$// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
+0$// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
+0$
+0$};
+0$        const BasicJsonType&>::value;
+0$        is_detected_exact<T, from_json_function, serializer,
+0$    static constexpr bool value =
+0$
+0$    using serializer = typename BasicJsonType::template json_serializer<T, void>;
+0${
+0$struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
+0$template<typename BasicJsonType, typename T>
+0$
+0$struct has_non_default_from_json : std::false_type {};
+0$template<typename BasicJsonType, typename T, typename = void>
+0$// this overload is used for non-default-constructible user-defined-types
+0$// This trait checks if JSONSerializer<T>::from_json(json const&) exists
+0$
+0$};
+0$        const BasicJsonType&, T&>::value;
+0$        is_detected_exact<void, from_json_function, serializer,
+0$    static constexpr bool value =
+0$
+0$    using serializer = typename BasicJsonType::template json_serializer<T, void>;
+0${
+0$struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
+0$template<typename BasicJsonType, typename T>
+0$
+0$};
+0$    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
+0${
+0$struct is_getable
+0$template <typename BasicJsonType, typename T>
+0$// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
+0$// both rely on, or make use of implicit conversions, and thus fail when T
+0$// use this trait instead of std::is_constructible or std::is_convertible,
+0$// trait checking if j.get<T> is valid
+0$
+0$struct has_from_json : std::false_type {};
+0$template<typename BasicJsonType, typename T, typename = void>
+0$// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
+0$
+0$using get_template_function = decltype(std::declval<T>().template get<U>());
+0$template<typename T, typename U>
+0$
+0$using from_json_function = decltype(T::from_json(std::declval<Args>()...));
+0$template<typename T, typename... Args>
+0$
+0$using to_json_function = decltype(T::to_json(std::declval<Args>()...));
+0$template<typename T, typename... Args>
+0$
+0$using iterator_category_t = typename T::iterator_category;
+0$template<typename T>
+0$
+0$using reference_t = typename T::reference;
+0$template<typename T>
+0$
+0$using pointer_t = typename T::pointer;
+0$template<typename T>
+0$
+0$using difference_type_t = typename T::difference_type;
+0$template<typename T>
+0$
+0$using value_type_t = typename T::value_type;
+0$template<typename T>
+0$
+0$using key_type_t = typename T::key_type;
+0$template<typename T>
+0$
+0$using mapped_type_t = typename T::mapped_type;
+0$template<typename T>
+0$
+0$//////////////////////////
+0$// aliases for detected //
+0$//////////////////////////
+0$
+0$struct is_json_ref<json_ref<T>> : std::true_type {};
+0$template<typename T>
+0$
+0$struct is_json_ref : std::false_type {};
+0$template<typename>
+0$
+0$class json_ref;
+0$template<typename>
+0$
+0$//////////////////////
+0$// json_ref helpers //
+0$//////////////////////
+0$
+0${};
+0$    || std::is_same<BasicJsonContext, std::nullptr_t>::value >
+0$    is_basic_json<typename std::remove_cv<typename std::remove_pointer<BasicJsonContext>::type>::type>::value
+0$    std::integral_constant < bool,
+0$struct is_basic_json_context :
+0$template<typename BasicJsonContext>
+0$// false_type otherwise
+0$// true_type for pointer to possibly cv-qualified basic_json or std::nullptr_t
+0$// used by exceptions create() member functions
+0$
+0$struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};
+0$NLOHMANN_BASIC_JSON_TPL_DECLARATION
+0$
+0$template<typename> struct is_basic_json : std::false_type {};
+0$
+0$// (e.g. to_json(BasicJsonType&, const T&))
+0$// In this case, T has to be properly CV-qualified to constraint the function arguments
+0$//
+0$// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
+0$// The only exceptions are in the 'aliases for detected' section
+0$// Every trait in this file expects a non CV-qualified type.
+0$//
+0$// Note to maintainers:
+0$
+0$/////////////
+0$// helpers //
+0$/////////////
+0$
+0${
+0$namespace detail
+0$*/
+0$@since version 2.1.0
+0$
+0$implementations of some @ref basic_json methods, and meta-programming helpers.
+0$This namespace collects functions that should not be exposed,
+0$
+0$@brief detail namespace with internal helper functions
+0$/*!
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_
+0$
+0$    NLOHMANN_JSON_NAMESPACE_END
+0$
+0$    using ordered_json = basic_json<nlohmann::ordered_map>;
+0$    /// @sa https://json.nlohmann.me/api/ordered_json/
+0$    /// @brief specialization that maintains the insertion order of object keys
+0$
+0$    struct ordered_map;
+0$    template<class Key, class T, class IgnoredLess, class Allocator>
+0$    /// @sa https://json.nlohmann.me/api/ordered_map/
+0$    /// @brief a minimal map-like container that preserves insertion order
+0$
+0$    using json = basic_json<>;
+0$    */
+0$    @sa https://json.nlohmann.me/api/json/
+0$    @brief default specialization
+0$    /*!
+0$
+0$    class json_pointer;
+0$    template<typename RefStringType>
+0$    /// @sa https://json.nlohmann.me/api/json_pointer/
+0$    /// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
+0$
+0$    class basic_json;
+0$    class CustomBaseClass = void>
+0$    class BinaryType = std::vector<std::uint8_t>, // cppcheck-suppress syntaxError
+0$    adl_serializer,
+0$    template<typename T, typename SFINAE = void> class JSONSerializer =
+0$    template<typename U> class AllocatorType = std::allocator,
+0$    class NumberFloatType = double,
+0$    class NumberUnsignedType = std::uint64_t,
+0$    class NumberIntegerType = std::int64_t,
+0$    class StringType = std::string, class BooleanType = bool,
+0$    template<typename U, typename... Args> class ArrayType = std::vector,
+0$    std::map,
+0$    template<template<typename U, typename V, typename... Args> class ObjectType =
+0$    /// @sa https://json.nlohmann.me/api/basic_json/
+0$    /// a class to store JSON values
+0$
+0$    struct adl_serializer;
+0$    template<typename T = void, typename SFINAE = void>
+0$    */
+0$    for serialization.
+0$    ([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
+0$    This serializer ignores the template arguments and uses ADL
+0$
+0$    @brief default JSONSerializer template argument
+0$    /*!
+0$
+0$    NLOHMANN_JSON_NAMESPACE_BEGIN
+0$    */
+0$    @since version 1.0.0
+0$    @see https://github.com/nlohmann
+0$    @brief namespace for Niels Lohmann
+0$    /*!
+0$
+0$
+0$    // #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$    #include <vector> // vector
+0$    #include <string> // string
+0$    #include <memory> // allocator
+0$    #include <map> // map
+0$    #include <cstdint> // int64_t, uint64_t
+0$
+0$    #define INCLUDE_NLOHMANN_JSON_FWD_HPP_
+0$#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/json_fwd.hpp>
+0$
+0$// #include <nlohmann/detail/meta/detected.hpp>
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/call_std/end.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$
+0$NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);
+0$
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/call_std/begin.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    using reference = T&;
+0$    using pointer = T*;
+0$    using difference_type = ptrdiff_t;
+0$    using value_type = T;
+0$    using iterator_category = std::random_access_iterator_tag;
+0${
+0$struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
+0$template<typename T>
+0$
+0$};
+0${
+0$            : iterator_types<T>
+0$struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
+0$template<typename T>
+0$
+0$};
+0${
+0$struct iterator_traits
+0$template<typename T, typename = void>
+0$// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
+0$// This is required as some compilers implement std::iterator_traits in a way that
+0$
+0$};
+0$    using iterator_category = typename It::iterator_category;
+0$    using reference = typename It::reference;
+0$    using pointer = typename It::pointer;
+0$    using value_type = typename It::value_type;
+0$    using difference_type = typename It::difference_type;
+0${
+0$    typename It::reference, typename It::iterator_category >>
+0$    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
+0$    It,
+0$struct iterator_types <
+0$template<typename It>
+0$
+0$struct iterator_types {};
+0$template<typename It, typename = void>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/meta/void_t.hpp>
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <iterator> // random_access_iterator_tag
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/iterators/iterator_traits.hpp>
+0$
+0$#include <string> // char_traits
+0$#include <tuple> // tuple
+0$#include <utility> // declval
+0$#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
+0$#include <limits> // numeric_limits
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/type_traits.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    return std::array<T, sizeof...(Args)> {{static_cast<T>(std::forward<Args>(args))...}};
+0${
+0$inline constexpr std::array<T, sizeof...(Args)> make_array(Args&& ... args)
+0$template<typename T, typename... Args>
+0$
+0$#endif
+0$    constexpr T static_const<T>::value;
+0$    template<typename T>
+0$#ifndef JSON_HAS_CPP_17
+0$
+0$};
+0$    static JSON_INLINE_VARIABLE constexpr T value{};
+0${
+0$struct static_const
+0$template<typename T>
+0$// taken from ranges-v3
+0$
+0$template<> struct priority_tag<0> {};
+0$template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
+0$// dispatch utility (taken from ranges-v3)
+0$
+0$#endif
+0$
+0$//// END OF CODE FROM GOOGLE ABSEIL
+0$
+0$using index_sequence_for = make_index_sequence<sizeof...(Ts)>;
+0$template <typename... Ts>
+0$// `std::index_sequence_for()`
+0$// is designed to be a drop-in replacement for C++14's
+0$// Converts a typename pack into an index sequence of the same length, and
+0$//
+0$// index_sequence_for
+0$
+0$using make_index_sequence = make_integer_sequence<size_t, N>;
+0$template <size_t N>
+0$// `std::make_index_sequence`.
+0$// and is designed to be a drop-in replacement for C++14's
+0$// This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,
+0$//
+0$// make_index_sequence
+0$
+0$using make_integer_sequence = typename utility_internal::Gen<T, N>::type;
+0$template <typename T, T N>
+0$// replacement for C++14's `std::make_integer_sequence`.
+0$// `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in
+0$// This template alias is equivalent to
+0$//
+0$// make_integer_sequence
+0$
+0$// Compile-time sequences of integers
+0$
+0$}  // namespace utility_internal
+0$
+0$};
+0$    using type = integer_sequence<T>;
+0${
+0$struct Gen<T, 0>
+0$template <typename T>
+0$
+0$};
+0$        typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
+0$    using type =
+0${
+0$struct Gen
+0$template <typename T, size_t N>
+0$// 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.
+0$// Recursion helper for 'make_integer_sequence<T, N>'.
+0$
+0$};
+0$    using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
+0${
+0$struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
+0$template <typename T, T... Ints, size_t SeqSize>
+0$
+0$};
+0$    using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
+0${
+0$struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
+0$template <typename T, T... Ints, size_t SeqSize>
+0$// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.
+0$
+0$struct Extend;
+0$template <typename Seq, size_t SeqSize, size_t Rem>
+0$
+0${
+0$namespace utility_internal
+0$
+0$using index_sequence = integer_sequence<size_t, Ints...>;
+0$template <size_t... Ints>
+0$// `std::index_sequence`.
+0$// `absl::index_sequence` is designed to be a drop-in replacement for C++14's
+0$// A helper template for an `integer_sequence` of `size_t`,
+0$//
+0$// index_sequence
+0$
+0$};
+0$    }
+0$        return sizeof...(Ints);
+0$    {
+0$    static constexpr std::size_t size() noexcept
+0$    using value_type = T;
+0${
+0$struct integer_sequence
+0$template <typename T, T... Ints>
+0$//   }
+0$//     user_function(make_integer_sequence<int, 5>());
+0$//     // will be deduced to `0, 1, 2, 3, 4`.
+0$//     // user_function's `T` will be deduced to `int` and `Ints...`
+0$//   {
+0$//   int main()
+0$//
+0$//   void user_function(integer_sequence<T, Ints...>);
+0$//   template< class T, T... Ints >
+0$//
+0$// Example:
+0$//
+0$// to be a drop-in replacement for C++14's `std::integer_sequence`.
+0$// working with C++11 variadic templates). `absl::integer_sequence` is designed
+0$// type through its template arguments (which is a common need when
+0$// of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its
+0$// Class template representing a compile-time integer sequence. An instantiation
+0$//
+0$// integer_sequence
+0$
+0$//// START OF CODE FROM GOOGLE ABSEIL
+0$
+0$// which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.
+0$// The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h
+0$
+0$using enable_if_t = typename std::enable_if<B, T>::type;
+0$template<bool B, typename T = void>
+0$// alias templates to reduce boilerplate
+0$
+0$#else
+0$
+0$using std::index_sequence_for;
+0$using std::make_index_sequence;
+0$using std::index_sequence;
+0$using std::enable_if_t;
+0$// the following utilities are natively available in C++14
+0$
+0$#ifdef JSON_HAS_CPP_14
+0$
+0$using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;
+0$template<typename T>
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#include <utility> // index_sequence, make_index_sequence, index_sequence_for
+0$#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type
+0$#include <cstddef> // size_t
+0$#include <array> // array
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2018 The Abseil Authors
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/cpp_future.hpp>
+0$
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$};
+0$    }
+0$        return chars_read_total;
+0$    {
+0$    constexpr operator size_t() const
+0$    /// conversion to size_t to preserve SAX interface
+0$
+0$    std::size_t lines_read = 0;
+0$    /// the number of lines read
+0$    std::size_t chars_read_current_line = 0;
+0$    /// the number of characters read in the current line
+0$    std::size_t chars_read_total = 0;
+0$    /// the total number of characters read
+0${
+0$struct position_t
+0$/// struct to capture the start position of the current token
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <cstddef> // size_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/input/position_t.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$}
+0$    replace_substring(s, StringType{"~0"}, StringType{"~"});
+0$    replace_substring(s, StringType{"~1"}, StringType{"/"});
+0${
+0$static void unescape(StringType& s)
+0$template<typename StringType>
+0$ */
+0$ * Note the order of escaping "~1" to "/" and "~0" to "~" is important.
+0$ *
+0$ * @return    unescaped string
+0$ * @param[in] s string to unescape
+0$ * @brief string unescaping as described in RFC 6901 (Sect. 4)
+0$/*!
+0$
+0$}
+0$    return s;
+0$    replace_substring(s, StringType{"/"}, StringType{"~1"});
+0$    replace_substring(s, StringType{"~"}, StringType{"~0"});
+0${
+0$inline StringType escape(StringType s)
+0$template<typename StringType>
+0$ */
+0$ * Note the order of escaping "~" to "~0" and "/" to "~1" is important.
+0$ *
+0$ * @return    escaped string
+0$ * @param[in] s string to escape
+0$ * @brief string escaping as described in RFC 6901 (Sect. 4)
+0$/*!
+0$
+0$}
+0$    {}
+0$            pos = s.find(f, pos + t.size()))  // find next occurrence of f
+0$            s.replace(pos, f.size(), t),      // replace with t, and
+0$            pos != StringType::npos;          // make sure f was found
+0$    for (auto pos = s.find(f);                // find first occurrence of f
+0$    JSON_ASSERT(!f.empty());
+0${
+0$                              const StringType& t)
+0$inline void replace_substring(StringType& s, const StringType& f,
+0$template<typename StringType>
+0$*/
+0$@since version 2.0.0
+0$
+0$enforced with an assertion.**
+0$@pre The search string @a f must not be empty. **This precondition is
+0$
+0$@param[in]     t  the string to replace @a f
+0$@param[in]     f  the substring to replace with @a t
+0$               occurrences of @a f are replaced with @a t
+0$@param[in,out] s  the string to manipulate; changed so that all
+0$
+0$@brief replace all occurrences of a substring by another string
+0$/*!
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/string_escape.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$#endif
+0$}
+0$    return std::is_lt(lhs <=> rhs); // *NOPAD*
+0${
+0$inline bool operator<(const value_t lhs, const value_t rhs) noexcept
+0$#if JSON_HAS_THREE_WAY_COMPARISON && defined(__GNUC__)
+0$// (see GCC bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105200)
+0$// Clang, MSVC, and ICC select the rewritten candidate
+0$// a user-defined spaceship operator
+0$// GCC selects the built-in operator< over an operator rewritten from
+0$
+0$}
+0$#endif
+0$    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
+0$#else
+0$    return std::partial_ordering::unordered;
+0$    }
+0$        return order[l_index] <=> order[r_index]; // *NOPAD*
+0$    {
+0$    if (l_index < order.size() && r_index < order.size())
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$    const auto r_index = static_cast<std::size_t>(rhs);
+0$    const auto l_index = static_cast<std::size_t>(lhs);
+0$
+0$    };
+0$        }
+0$            6 /* binary */
+0$            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
+0$            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
+0$    static constexpr std::array<std::uint8_t, 9> order = {{
+0${
+0$#endif
+0$    inline bool operator<(const value_t lhs, const value_t rhs) noexcept
+0$#else
+0$    inline std::partial_ordering operator<=>(const value_t lhs, const value_t rhs) noexcept // *NOPAD*
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$*/
+0$@since version 1.0.0
+0$
+0$  be surprising behavior in a JSON file.
+0$  string; however, making a binary array directly comparable with a string would
+0$- binary is represented as a b"" string in python and directly comparable to a
+0$- discarded values are not comparable
+0$- furthermore, each type is not smaller than itself
+0$- order: null < boolean < number < object < array < string < binary
+0$Returns an ordering that is similar to Python:
+0$
+0$@brief comparison operator for JSON types
+0$/*!
+0$
+0$};
+0$    discarded         ///< discarded by the parser callback function
+0$    binary,           ///< binary array (ordered collection of bytes)
+0$    number_float,     ///< number value (floating-point)
+0$    number_unsigned,  ///< number value (unsigned integer)
+0$    number_integer,   ///< number value (signed integer)
+0$    boolean,          ///< boolean value
+0$    string,           ///< string value
+0$    array,            ///< array (ordered collection of values)
+0$    object,           ///< object (unordered set of name/value pairs)
+0$    null,             ///< null value
+0${
+0$enum class value_t : std::uint8_t
+0$*/
+0$@since version 1.0.0
+0$
+0$value with the default value for a given type
+0$@sa see @ref basic_json::basic_json(const value_t value_type) -- create a JSON
+0$
+0$approximate integers which do not fit in the limits of their respective type.
+0$@ref basic_json::number_float_t is used for floating-point numbers or to
+0$@ref basic_json::number_integer_t is used for signed integers, and
+0$@ref basic_json::number_unsigned_t is used for unsigned integers,
+0$number_float), because the library distinguishes these three types for numbers:
+0$@note There are three enumeration entries (number_integer, number_unsigned, and
+0$
+0$@ref basic_json::is_structured() rely on it.
+0$@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
+0$@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
+0$@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
+0$@ref basic_json::is_string(), @ref basic_json::is_boolean(),
+0$@ref basic_json::is_object(), @ref basic_json::is_array(),
+0$distinguish the stored values, and the functions @ref basic_json::is_null(),
+0$This enumeration collects the different JSON types. It is internally used to
+0$
+0$@brief the JSON type enumeration
+0$/*!
+0$
+0$///////////////////////////
+0$// JSON type enumeration //
+0$///////////////////////////
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$#endif
+0$    #include <compare> // partial_ordering
+0$#if JSON_HAS_THREE_WAY_COMPARISON
+0$
+0$#endif
+0$    #define JSON_USE_GLOBAL_UDLS 1
+0$#ifndef JSON_USE_GLOBAL_UDLS
+0$
+0$#endif
+0$    #define JSON_DISABLE_ENUM_SERIALIZATION 0
+0$#ifndef JSON_DISABLE_ENUM_SERIALIZATION
+0$
+0$#endif
+0$    #define JSON_EXPLICIT explicit
+0$#else
+0$    #define JSON_EXPLICIT
+0$#if JSON_USE_IMPLICIT_CONVERSIONS
+0$
+0$#endif
+0$    #define JSON_USE_IMPLICIT_CONVERSIONS 1
+0$#ifndef JSON_USE_IMPLICIT_CONVERSIONS
+0$
+0$    }
+0$    {                                                                             \
+0$    struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \
+0$    template<typename... T>                                                       \
+0$    \
+0$    } /* namespace detail2 */ \
+0$    };                                                                            \
+0$                                            is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \
+0$        static constexpr auto const value = ::nlohmann::detail::                  \
+0$    {                                                                             \
+0$    struct would_call_std_##std_name                                              \
+0$    template<typename... T>                                                       \
+0$    \
+0$    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
+0$    template<typename... T>                                                       \
+0$    \
+0$    std_name##_tag std_name(T&&...);                                              \
+0$    template<typename... T>                                                       \
+0$    \
+0$    };                                                                            \
+0$    {                                                                             \
+0$    struct std_name##_tag                                                         \
+0$    namespace detail2 {                                                           \
+0$    \
+0$    }                                                                             \
+0$    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
+0$    template<typename... T>                                                       \
+0$    \
+0$    using std::std_name;                                                          \
+0$    namespace detail {                                                            \
+0$#define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
+0$// of such an expression
+0$// it allows using the detected idiom to retrieve the return type
+0$//
+0$// using std::begin; begin(x);
+0$// allows to call any std function as if (e.g. with begin):
+0$// inspired from https://stackoverflow.com/a/26745591
+0$
+0$    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
+0$    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
+0$#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
+0$
+0$    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }
+0$#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
+0$
+0$    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
+0$    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
+0$#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
+0$*/
+0$@since version 3.9.0
+0$@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
+0$@brief macro
+0$/*!
+0$
+0$    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }
+0$#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
+0$
+0$    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }
+0$    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
+0$#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
+0$
+0$    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
+0$    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
+0$#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
+0$*/
+0$@since version 3.9.0
+0$@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
+0$@brief macro
+0$/*!
+0$
+0$#define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1);
+0$#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
+0$#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
+0$
+0$#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)
+0$#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
+0$#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
+0$#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
+0$#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
+0$#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
+0$#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
+0$#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
+0$#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
+0$#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
+0$#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
+0$#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
+0$#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
+0$#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
+0$#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
+0$#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
+0$#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
+0$#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
+0$#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
+0$#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
+0$#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
+0$#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
+0$#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
+0$#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
+0$#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
+0$#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
+0$#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
+0$#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
+0$#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
+0$#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
+0$#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
+0$#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
+0$#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
+0$#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
+0$#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
+0$#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
+0$#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
+0$#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
+0$#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
+0$#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
+0$#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
+0$#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
+0$#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
+0$#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
+0$#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
+0$#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
+0$#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
+0$#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
+0$#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
+0$#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
+0$#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
+0$#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
+0$#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
+0$#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
+0$#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
+0$#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
+0$#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
+0$#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
+0$#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
+0$#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
+0$#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
+0$#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
+0$#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
+0$        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
+0$        NLOHMANN_JSON_PASTE2, \
+0$        NLOHMANN_JSON_PASTE3, \
+0$        NLOHMANN_JSON_PASTE4, \
+0$        NLOHMANN_JSON_PASTE5, \
+0$        NLOHMANN_JSON_PASTE6, \
+0$        NLOHMANN_JSON_PASTE7, \
+0$        NLOHMANN_JSON_PASTE8, \
+0$        NLOHMANN_JSON_PASTE9, \
+0$        NLOHMANN_JSON_PASTE10, \
+0$        NLOHMANN_JSON_PASTE11, \
+0$        NLOHMANN_JSON_PASTE12, \
+0$        NLOHMANN_JSON_PASTE13, \
+0$        NLOHMANN_JSON_PASTE14, \
+0$        NLOHMANN_JSON_PASTE15, \
+0$        NLOHMANN_JSON_PASTE16, \
+0$        NLOHMANN_JSON_PASTE17, \
+0$        NLOHMANN_JSON_PASTE18, \
+0$        NLOHMANN_JSON_PASTE19, \
+0$        NLOHMANN_JSON_PASTE20, \
+0$        NLOHMANN_JSON_PASTE21, \
+0$        NLOHMANN_JSON_PASTE22, \
+0$        NLOHMANN_JSON_PASTE23, \
+0$        NLOHMANN_JSON_PASTE24, \
+0$        NLOHMANN_JSON_PASTE25, \
+0$        NLOHMANN_JSON_PASTE26, \
+0$        NLOHMANN_JSON_PASTE27, \
+0$        NLOHMANN_JSON_PASTE28, \
+0$        NLOHMANN_JSON_PASTE29, \
+0$        NLOHMANN_JSON_PASTE30, \
+0$        NLOHMANN_JSON_PASTE31, \
+0$        NLOHMANN_JSON_PASTE32, \
+0$        NLOHMANN_JSON_PASTE33, \
+0$        NLOHMANN_JSON_PASTE34, \
+0$        NLOHMANN_JSON_PASTE35, \
+0$        NLOHMANN_JSON_PASTE36, \
+0$        NLOHMANN_JSON_PASTE37, \
+0$        NLOHMANN_JSON_PASTE38, \
+0$        NLOHMANN_JSON_PASTE39, \
+0$        NLOHMANN_JSON_PASTE40, \
+0$        NLOHMANN_JSON_PASTE41, \
+0$        NLOHMANN_JSON_PASTE42, \
+0$        NLOHMANN_JSON_PASTE43, \
+0$        NLOHMANN_JSON_PASTE44, \
+0$        NLOHMANN_JSON_PASTE45, \
+0$        NLOHMANN_JSON_PASTE46, \
+0$        NLOHMANN_JSON_PASTE47, \
+0$        NLOHMANN_JSON_PASTE48, \
+0$        NLOHMANN_JSON_PASTE49, \
+0$        NLOHMANN_JSON_PASTE50, \
+0$        NLOHMANN_JSON_PASTE51, \
+0$        NLOHMANN_JSON_PASTE52, \
+0$        NLOHMANN_JSON_PASTE53, \
+0$        NLOHMANN_JSON_PASTE54, \
+0$        NLOHMANN_JSON_PASTE55, \
+0$        NLOHMANN_JSON_PASTE56, \
+0$        NLOHMANN_JSON_PASTE57, \
+0$        NLOHMANN_JSON_PASTE58, \
+0$        NLOHMANN_JSON_PASTE59, \
+0$        NLOHMANN_JSON_PASTE60, \
+0$        NLOHMANN_JSON_PASTE61, \
+0$        NLOHMANN_JSON_PASTE62, \
+0$        NLOHMANN_JSON_PASTE63, \
+0$        NLOHMANN_JSON_PASTE64, \
+0$#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
+0$#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
+0$#define NLOHMANN_JSON_EXPAND( x ) x
+0$
+0$// Macros to simplify conversion from/to types
+0$
+0$    AllocatorType, JSONSerializer, BinaryType, CustomBaseClass>
+0$    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
+0$    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
+0$#define NLOHMANN_BASIC_JSON_TPL                                            \
+0$
+0$             class CustomBaseClass>
+0$             class BinaryType,                                             \
+0$             template<typename, typename = void> class JSONSerializer,     \
+0$             template<typename> class AllocatorType,                       \
+0$             class NumberUnsignedType, class NumberFloatType,              \
+0$             class StringType, class BooleanType, class NumberIntegerType, \
+0$             template<typename, typename...> class ArrayType,              \
+0$    template<template<typename, typename, typename...> class ObjectType,   \
+0$#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
+0$
+0$// may be removed in the future once the class is split.
+0$// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
+0$
+0$    }
+0$        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
+0$        });                                                                                     \
+0$            return ej_pair.second == j;                                                         \
+0$        {                                                                                       \
+0$                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
+0$        auto it = std::find_if(std::begin(m), std::end(m),                                      \
+0$        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
+0$        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
+0$    {                                                                                           \
+0$    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
+0$    template<typename BasicJsonType>                                                            \
+0$    }                                                                                           \
+0$        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
+0$        });                                                                                     \
+0$            return ej_pair.first == e;                                                          \
+0$        {                                                                                       \
+0$                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
+0$        auto it = std::find_if(std::begin(m), std::end(m),                                      \
+0$        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
+0$        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
+0$    {                                                                                           \
+0$    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
+0$    template<typename BasicJsonType>                                                            \
+0$#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
+0$*/
+0$@since version 3.4.0
+0$@def NLOHMANN_JSON_SERIALIZE_ENUM
+0$@brief macro to briefly define a mapping between an enum and JSON
+0$/*!
+0$
+0$#endif
+0$    #define JSON_PRIVATE_UNLESS_TESTED private
+0$#else
+0$    #define JSON_PRIVATE_UNLESS_TESTED public
+0$#if defined(JSON_TESTS_PRIVATE)
+0$// allow to access some private functions (needed by the test suite)
+0$
+0$#endif
+0$    #define JSON_ASSERT(x) assert(x)
+0$    #include <cassert> // assert
+0$#if !defined(JSON_ASSERT)
+0$// allow overriding assert
+0$
+0$#endif
+0$    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
+0$    #undef JSON_INTERNAL_CATCH
+0$#if defined(JSON_INTERNAL_CATCH_USER)
+0$#endif
+0$    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
+0$    #undef JSON_INTERNAL_CATCH
+0$    #define JSON_CATCH JSON_CATCH_USER
+0$    #undef JSON_CATCH
+0$#if defined(JSON_CATCH_USER)
+0$#endif
+0$    #define JSON_TRY JSON_TRY_USER
+0$    #undef JSON_TRY
+0$#if defined(JSON_TRY_USER)
+0$#endif
+0$    #define JSON_THROW JSON_THROW_USER
+0$    #undef JSON_THROW
+0$#if defined(JSON_THROW_USER)
+0$// override exception macros
+0$
+0$#endif
+0$    #define JSON_INTERNAL_CATCH(exception) if(false)
+0$    #define JSON_CATCH(exception) if(false)
+0$    #define JSON_TRY if(true)
+0$    #define JSON_THROW(exception) std::abort()
+0$    #include <cstdlib>
+0$#else
+0$    #define JSON_INTERNAL_CATCH(exception) catch(exception)
+0$    #define JSON_CATCH(exception) catch(exception)
+0$    #define JSON_TRY try
+0$    #define JSON_THROW(exception) throw exception
+0$#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
+0$// allow disabling exceptions
+0$
+0$#endif
+0$    #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
+0$    #pragma clang diagnostic ignored "-Wdocumentation"
+0$    #pragma clang diagnostic push
+0$#if defined(__clang__)
+0$// disable documentation warnings on clang
+0$
+0$#endif
+0$    #define JSON_NO_UNIQUE_ADDRESS
+0$#else
+0$    #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
+0$#if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
+0$
+0$#endif
+0$    #define JSON_INLINE_VARIABLE
+0$#else
+0$    #define JSON_INLINE_VARIABLE inline
+0$#ifdef JSON_HAS_CPP_17
+0$
+0$#endif
+0$    #endif
+0$        #define JSON_HAS_STATIC_RTTI 0
+0$    #else
+0$        #define JSON_HAS_STATIC_RTTI 1
+0$    #if !defined(_HAS_STATIC_RTTI) || _HAS_STATIC_RTTI != 0
+0$#ifndef JSON_HAS_STATIC_RTTI
+0$
+0$#endif
+0$    #endif
+0$        #define JSON_HAS_RANGES 0
+0$    #else
+0$        #define JSON_HAS_RANGES 1
+0$    #elif defined(__cpp_lib_ranges)
+0$        #define JSON_HAS_RANGES 0
+0$    #if defined(__GLIBCXX__) && __GLIBCXX__ == 20210427
+0$    // ranges header shipping in GCC 11.1.0 (released 2021-04-27) has syntax error
+0$#ifndef JSON_HAS_RANGES
+0$
+0$#endif
+0$    #endif
+0$        #define JSON_HAS_THREE_WAY_COMPARISON 0
+0$    #else
+0$        #define JSON_HAS_THREE_WAY_COMPARISON 1
+0$        && defined(__cpp_lib_three_way_comparison) && __cpp_lib_three_way_comparison >= 201907L
+0$    #if defined(__cpp_impl_three_way_comparison) && __cpp_impl_three_way_comparison >= 201907L \
+0$#ifndef JSON_HAS_THREE_WAY_COMPARISON
+0$
+0$#endif
+0$    #define JSON_HAS_FILESYSTEM 0
+0$#ifndef JSON_HAS_FILESYSTEM
+0$
+0$#endif
+0$    #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
+0$#ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$
+0$#endif
+0$    #endif
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
+0$        // no filesystem support before macOS Catalina
+0$
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
+0$        // no filesystem support before iOS 13
+0$
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(_MSC_VER) && _MSC_VER < 1914
+0$        // no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler_support
+0$
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(__clang_major__) && __clang_major__ < 7
+0$        // no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler_support
+0$
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8
+0$        // no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler_support
+0$
+0$        #endif
+0$            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
+0$            #undef JSON_HAS_FILESYSTEM
+0$        #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8
+0$        // std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-w64/bugs/737/
+0$
+0$        #endif
+0$            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
+0$        #elif __has_include(<experimental/filesystem>)
+0$            #define JSON_HAS_FILESYSTEM 1
+0$        #elif __has_include(<filesystem>)
+0$            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
+0$        #elif !defined(__has_include)
+0$            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
+0$        #elif defined(__cpp_lib_experimental_filesystem)
+0$            #define JSON_HAS_FILESYSTEM 1
+0$        #if defined(__cpp_lib_filesystem)
+0$    #ifdef JSON_HAS_CPP_17
+0$#if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
+0$
+0$#endif
+0$    #endif
+0$        #include <version>
+0$    #if __has_include(<version>)
+0$#ifdef __has_include
+0$
+0$#endif
+0$    #define JSON_HAS_CPP_11
+0$    // the cpp 11 flag is always specified because it is the minimal required version
+0$    #endif
+0$        #define JSON_HAS_CPP_14
+0$    #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
+0$        #define JSON_HAS_CPP_14
+0$        #define JSON_HAS_CPP_17
+0$    #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
+0$        #define JSON_HAS_CPP_14
+0$        #define JSON_HAS_CPP_17
+0$        #define JSON_HAS_CPP_20
+0$    #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
+0$#if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
+0$// if the user manually specified the used c++ version this is skipped
+0$// C++ language standard detection
+0$
+0$#endif
+0$    #endif
+0$        #endif
+0$            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
+0$        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
+0$    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
+0$        #endif
+0$            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
+0$        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
+0$    #if defined(__clang__)
+0$#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
+0$// exclude unsupported compilers
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them
+0$// This file contains all internal macro definitions (except those affecting ABI)
+0$
+0$
+0$#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_WARNING
+0$#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
+0$#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
+0$#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
+0$#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
+0$
+0$#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
+0$#if defined(__clang__)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
+0$
+0$/* Remaining macros are deprecated. */
+0$
+0$#endif
+0$    #define JSON_HEDLEY_EMPTY_BASES
+0$#else
+0$    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_EMPTY_BASES
+0$#if defined(JSON_HEDLEY_EMPTY_BASES)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
+0$#else
+0$    }))
+0$        JSON_HEDLEY_DIAGNOSTIC_POP \
+0$        ((T) (expr)); \
+0$        _Pragma("warning(disable:188)") \
+0$        JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
+0$#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
+0$#endif
+0$    #undef JSON_HEDLEY_FLAGS_CAST
+0$#if defined(JSON_HEDLEY_FLAGS_CAST)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_FLAGS
+0$#else
+0$    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
+0$#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
+0$#endif
+0$    #undef JSON_HEDLEY_FLAGS
+0$#if defined(JSON_HEDLEY_FLAGS)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
+0$#  define JSON_HEDLEY_REQUIRE(expr)
+0$#else
+0$#  endif
+0$#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
+0$#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
+0$#  else
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    __attribute__((diagnose_if(!(expr), msg, "error"))) \
+0$    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
+0$    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#    define JSON_HEDLEY_REQUIRE(expr) \
+0$#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
+0$#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
+0$#endif
+0$    #undef JSON_HEDLEY_REQUIRE_MSG
+0$#if defined(JSON_HEDLEY_REQUIRE_MSG)
+0$#endif
+0$    #undef JSON_HEDLEY_REQUIRE
+0$#if defined(JSON_HEDLEY_REQUIRE)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
+0$#else
+0$#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
+0$  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$  JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
+0$#elif \
+0$#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
+0$#elif \
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    JSON_HEDLEY_PRAGMA(clang warning msg) \
+0$    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#  define JSON_HEDLEY_WARNING(msg) \
+0$#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+0$#endif
+0$    #undef JSON_HEDLEY_WARNING
+0$#if defined(JSON_HEDLEY_WARNING)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_MESSAGE(msg)
+0$#else
+0$#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
+0$#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
+0$#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
+0$#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
+0$#elif \
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    JSON_HEDLEY_PRAGMA(message msg) \
+0$    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#  define JSON_HEDLEY_MESSAGE(msg) \
+0$#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+0$#endif
+0$    #undef JSON_HEDLEY_MESSAGE
+0$#if defined(JSON_HEDLEY_MESSAGE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_NULL ((void*) 0)
+0$#else
+0$    #define JSON_HEDLEY_NULL NULL
+0$#elif defined(NULL)
+0$    #endif
+0$        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
+0$    #else
+0$        #define JSON_HEDLEY_NULL NULL
+0$    #elif defined(NULL)
+0$        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
+0$    #if __cplusplus >= 201103L
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_NULL
+0$#if defined(JSON_HEDLEY_NULL)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
+0$#else
+0$#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
+0$  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
+0$  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
+0$#elif \
+0$#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
+0$    )
+0$      defined(_Static_assert) \
+0$      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
+0$      (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
+0$      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
+0$  !defined(__cplusplus) && ( \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_STATIC_ASSERT
+0$#if defined(JSON_HEDLEY_STATIC_ASSERT)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_C_DECL
+0$    #define JSON_HEDLEY_END_C_DECLS
+0$    #define JSON_HEDLEY_BEGIN_C_DECLS
+0$#else
+0$    #define JSON_HEDLEY_C_DECL extern "C"
+0$    #define JSON_HEDLEY_END_C_DECLS }
+0$    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_C_DECL
+0$#if defined(JSON_HEDLEY_C_DECL)
+0$#endif
+0$    #undef JSON_HEDLEY_END_C_DECLS
+0$#if defined(JSON_HEDLEY_END_C_DECLS)
+0$#endif
+0$    #undef JSON_HEDLEY_BEGIN_C_DECLS
+0$#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
+0$    #endif
+0$        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
+0$    #if !defined(JSON_HEDLEY_IS_CONSTANT)
+0$#else
+0$    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
+0$    #endif
+0$        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
+0$    #if !defined(JSON_HEDLEY_IS_CONSTANT)
+0$#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
+0$#endif
+0$#  endif
+0$                                            )
+0$              ) \
+0$                ) \
+0$((struct { char v[sizeof(void) * 2]; } *) 1) \
+0$                  ((void*) ((expr) * 0L) ) : \
+0$                  1 ? \
+0$        sizeof(*( \
+0$        sizeof(void) != \
+0$#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
+0$       defined(__clang__)
+0$       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
+0$       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
+0$       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
+0$       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
+0$       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
+0$       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
+0$       defined(JSON_HEDLEY_TINYC_VERSION) || \
+0$       defined(JSON_HEDLEY_INTEL_VERSION) || \
+0$       defined(JSON_HEDLEY_GCC_VERSION) || \
+0$#  elif \
+0$#endif
+0$    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
+0$    #include <stdint.h>
+0$#else
+0$    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
+0$#if defined(__INTPTR_TYPE__)
+0$       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
+0$       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
+0$       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
+0$       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
+0$       (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
+0$          !defined(JSON_HEDLEY_IAR_VERSION)) || \
+0$          !defined(JSON_HEDLEY_PGI_VERSION) && \
+0$          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
+0$          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
+0$       ( \
+0$#  elif \
+0$#endif
+0$    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
+0$    #include <stdint.h>
+0$#else
+0$    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
+0$#if defined(__INTPTR_TYPE__)
+0$       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
+0$       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
+0$       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
+0$       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
+0$       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
+0$       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
+0$#  if \
+0$#if !defined(__cplusplus)
+0$#endif
+0$    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
+0$    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
+0$    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_IS_CONSTEXPR_
+0$#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
+0$   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
+0$/* JSON_HEDLEY_IS_CONSTEXPR_ is for
+0$#endif
+0$    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
+0$#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
+0$#endif
+0$    #undef JSON_HEDLEY_IS_CONSTANT
+0$#if defined(JSON_HEDLEY_IS_CONSTANT)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_ARRAY_PARAM(name)
+0$#else
+0$    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
+0$    !defined(JSON_HEDLEY_TINYC_VERSION)
+0$    !defined(JSON_HEDLEY_PGI_VERSION) && \
+0$    !defined(__cplusplus) && \
+0$    !defined(__STDC_NO_VLA__) && \
+0$    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_ARRAY_PARAM
+0$#if defined(JSON_HEDLEY_ARRAY_PARAM)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_RETURNS_NON_NULL
+0$#else
+0$    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
+0$#elif defined(_Ret_notnull_) /* SAL */
+0$    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_RETURNS_NON_NULL
+0$#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_FALL_THROUGH
+0$#else
+0$    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
+0$#elif defined(__fallthrough) /* SAL */
+0$    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
+0$#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
+0$    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
+0$#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
+0$    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_FALL_THROUGH
+0$#if defined(JSON_HEDLEY_FALL_THROUGH)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_NO_THROW
+0$#else
+0$    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_NO_THROW
+0$#if defined(JSON_HEDLEY_NO_THROW)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_IMPORT    extern
+0$#  endif
+0$#    define JSON_HEDLEY_PUBLIC
+0$#    define JSON_HEDLEY_PRIVATE
+0$#  else
+0$#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
+0$#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    ) || \
+0$      ) \
+0$        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
+0$        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$      ( \
+0$      defined(__TI_EABI__) && \
+0$    ( \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
+0$#  if \
+0$#else
+0$#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
+0$#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
+0$#  define JSON_HEDLEY_PRIVATE
+0$#if defined(_WIN32) || defined(__CYGWIN__)
+0$#endif
+0$    #undef JSON_HEDLEY_IMPORT
+0$#if defined(JSON_HEDLEY_IMPORT)
+0$#endif
+0$    #undef JSON_HEDLEY_PUBLIC
+0$#if defined(JSON_HEDLEY_PUBLIC)
+0$#endif
+0$    #undef JSON_HEDLEY_PRIVATE
+0$#if defined(JSON_HEDLEY_PRIVATE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_NEVER_INLINE
+0$#else
+0$    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
+0$    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
+0$#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
+0$    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
+0$#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
+0$    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
+0$    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
+0$    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_NEVER_INLINE
+0$#if defined(JSON_HEDLEY_NEVER_INLINE)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
+0$#else
+0$#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
+0$    )
+0$      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
+0$      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
+0$      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    ( \
+0$#elif defined(__cplusplus) && \
+0$#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
+0$  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$  JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
+0$#elif \
+0$#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
+0$  JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
+0$  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
+0$  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
+0$  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_ALWAYS_INLINE
+0$#if defined(JSON_HEDLEY_ALWAYS_INLINE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_INLINE
+0$#else
+0$    #define JSON_HEDLEY_INLINE __inline
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_INLINE __inline__
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
+0$    defined(JSON_HEDLEY_GCC_VERSION) || \
+0$#elif \
+0$    #define JSON_HEDLEY_INLINE inline
+0$    (defined(__cplusplus) && (__cplusplus >= 199711L))
+0$    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_INLINE
+0$#if defined(JSON_HEDLEY_INLINE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_RESTRICT
+0$#else
+0$    #define JSON_HEDLEY_RESTRICT _Restrict
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
+0$    #define JSON_HEDLEY_RESTRICT __restrict
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    defined(__clang__) || \
+0$    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
+0$    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_RESTRICT restrict
+0$#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_RESTRICT
+0$#if defined(JSON_HEDLEY_RESTRICT)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
+0$#else
+0$    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
+0$#elif \
+0$    #define JSON_HEDLEY_CONST __attribute__((__const__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_CONST
+0$#if defined(JSON_HEDLEY_CONST)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_PURE
+0$#else
+0$#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
+0$    )
+0$      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
+0$      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
+0$      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
+0$    ( \
+0$#elif defined(__cplusplus) && \
+0$#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
+0$#  define JSON_HEDLEY_PURE __attribute__((__pure__))
+0$  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
+0$  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
+0$  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_PURE
+0$#if defined(JSON_HEDLEY_PURE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_MALLOC
+0$#else
+0$    #define JSON_HEDLEY_MALLOC __declspec(restrict)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
+0$    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_MALLOC
+0$#if defined(JSON_HEDLEY_MALLOC)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
+0$#if !defined(JSON_HEDLEY_UNPREDICTABLE)
+0$#endif
+0$#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
+0$#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
+0$#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
+0$#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
+0$#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
+0$#else
+0$#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
+0$#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
+0$    }))
+0$        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
+0$        double hedley_probability_ = (probability); \
+0$    (__extension__ ({ \
+0$#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
+0$    }))
+0$        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
+0$        double hedley_probability_ = (probability); \
+0$    (__extension__ ({ \
+0$#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
+0$    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
+0$#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
+0$  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
+0$  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
+0$  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
+0$  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
+0$  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
+0$  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
+0$  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
+0$  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
+0$#elif \
+0$#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
+0$#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
+0$#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
+0$#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
+0$#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
+0$  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
+0$  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
+0$#if \
+0$#endif
+0$    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
+0$#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
+0$#endif
+0$    #undef JSON_HEDLEY_UNPREDICTABLE
+0$#if defined(JSON_HEDLEY_UNPREDICTABLE)
+0$#endif
+0$    #undef JSON_HEDLEY_UNLIKELY
+0$#if defined(JSON_HEDLEY_UNLIKELY)
+0$#endif
+0$    #undef JSON_HEDLEY_LIKELY
+0$#if defined(JSON_HEDLEY_LIKELY)
+0$#endif
+0$    #undef JSON_HEDLEY_PREDICT
+0$#if defined(JSON_HEDLEY_PREDICT)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_CONSTEXPR
+0$#if !defined(JSON_HEDLEY_CONSTEXPR)
+0$#endif
+0$    #endif
+0$        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
+0$    #if __cplusplus >= 201103L
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_CONSTEXPR
+0$#if defined(JSON_HEDLEY_CONSTEXPR)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
+0$#else
+0$    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
+0$    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
+0$#elif \
+0$    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
+0$#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
+0$    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
+0$#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
+0$#endif
+0$    #undef JSON_HEDLEY_PRINTF_FORMAT
+0$#if defined(JSON_HEDLEY_PRINTF_FORMAT)
+0$
+0$JSON_HEDLEY_DIAGNOSTIC_POP
+0$#endif
+0$    #define JSON_HEDLEY_NON_NULL(...)
+0$#else
+0$    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_NON_NULL
+0$#if defined(JSON_HEDLEY_NON_NULL)
+0$#endif
+0$    #endif
+0$        #pragma GCC diagnostic ignored "-Wvariadic-macros"
+0$    #elif defined(JSON_HEDLEY_GCC_VERSION)
+0$        #pragma clang diagnostic ignored "-Wvariadic-macros"
+0$    #if defined(__clang__)
+0$#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
+0$#endif
+0$    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
+0$#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
+0$#endif
+0$    #pragma clang diagnostic ignored "-Wpedantic"
+0$#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
+0$JSON_HEDLEY_DIAGNOSTIC_PUSH
+0$
+0$#endif
+0$    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
+0$#if !defined(JSON_HEDLEY_UNREACHABLE)
+0$#endif
+0$    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
+0$#else
+0$    #endif
+0$        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
+0$    #else
+0$        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
+0$        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
+0$        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
+0$    #if  \
+0$#if defined(JSON_HEDLEY_UNREACHABLE)
+0$#endif
+0$    #endif
+0$        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
+0$    #else
+0$        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
+0$    #if defined(JSON_HEDLEY_UNREACHABLE)
+0$#if !defined(JSON_HEDLEY_ASSUME)
+0$#endif
+0$    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
+0$#elif defined(JSON_HEDLEY_ASSUME)
+0$    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
+0$    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
+0$#if \
+0$#endif
+0$    #endif
+0$        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
+0$    #else
+0$        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
+0$    #if defined(__cplusplus)
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
+0$#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
+0$    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_ASSUME
+0$#if defined(JSON_HEDLEY_ASSUME)
+0$#endif
+0$    #undef JSON_HEDLEY_UNREACHABLE_RETURN
+0$#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
+0$#endif
+0$    #undef JSON_HEDLEY_UNREACHABLE
+0$#if defined(JSON_HEDLEY_UNREACHABLE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_NO_ESCAPE
+0$#else
+0$    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
+0$#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
+0$#endif
+0$    #undef JSON_HEDLEY_NO_ESCAPE
+0$#if defined(JSON_HEDLEY_NO_ESCAPE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_NO_RETURN
+0$#else
+0$    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
+0$    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
+0$#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
+0$    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
+0$#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
+0$    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
+0$    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
+0$    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
+0$#elif \
+0$    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
+0$#elif defined(__cplusplus) && (__cplusplus >= 201103L)
+0$    #define JSON_HEDLEY_NO_RETURN _Noreturn
+0$#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
+0$    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_NO_RETURN __noreturn
+0$#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$#endif
+0$    #undef JSON_HEDLEY_NO_RETURN
+0$#if defined(JSON_HEDLEY_NO_RETURN)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_SENTINEL(position)
+0$#else
+0$    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_SENTINEL
+0$#if defined(JSON_HEDLEY_SENTINEL)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT
+0$#else
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
+0$#elif defined(_Check_return_) /* SAL */
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+0$#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+0$#elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
+0$    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
+0$    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
+0$#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
+0$#endif
+0$    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
+0$#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_UNAVAILABLE(available_since)
+0$#else
+0$    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_UNAVAILABLE
+0$#if defined(JSON_HEDLEY_UNAVAILABLE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
+0$    #define JSON_HEDLEY_DEPRECATED(since)
+0$#else
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
+0$    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
+0$    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
+0$    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
+0$    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
+0$    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
+0$    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
+0$#elif defined(__cplusplus) && (__cplusplus >= 201402L)
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
+0$    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
+0$    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
+0$    (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
+0$    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_DEPRECATED_FOR
+0$#if defined(JSON_HEDLEY_DEPRECATED_FOR)
+0$#endif
+0$    #undef JSON_HEDLEY_DEPRECATED
+0$#if defined(JSON_HEDLEY_DEPRECATED)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
+0$#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
+0$#elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
+0$#if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
+0$#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
+0$#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
+0$#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
+0$#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
+0$#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
+0$#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
+0$#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
+0$#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
+0$#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
+0$#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
+0$#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
+0$#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
+0$#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
+0$#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
+0$#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
+0$    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
+0$    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
+0$    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
+0$#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
+0$#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
+0$#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
+0$#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
+0$#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+0$#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
+0$#else
+0$#  endif
+0$#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
+0$#  else
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    _Pragma("diag_suppress=Pe137") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#    define JSON_HEDLEY_CPP_CAST(T, expr) \
+0$#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    ((T) (expr)) \
+0$    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#    define JSON_HEDLEY_CPP_CAST(T, expr) \
+0$#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_CPP_CAST
+0$#if defined(JSON_HEDLEY_CPP_CAST)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
+0$#else
+0$    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_STATIC_CAST
+0$#if defined(JSON_HEDLEY_STATIC_CAST)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
+0$#else
+0$    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_REINTERPRET_CAST
+0$#if defined(JSON_HEDLEY_REINTERPRET_CAST)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
+0$#else
+0$    }))
+0$        JSON_HEDLEY_DIAGNOSTIC_POP \
+0$        ((T) (expr)); \
+0$        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
+0$        JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
+0$  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
+0$  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
+0$#elif \
+0$#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_CONST_CAST
+0$#if defined(JSON_HEDLEY_CONST_CAST)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
+0$#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
+0$#endif
+0$#  endif
+0$#    endif
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    xpr \
+0$    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
+0$#    else
+0$#      endif
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    xpr \
+0$    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
+0$    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
+0$#      else
+0$    JSON_HEDLEY_DIAGNOSTIC_POP
+0$    xpr \
+0$    _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
+0$    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
+0$    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
+0$    JSON_HEDLEY_DIAGNOSTIC_PUSH \
+0$#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
+0$#      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
+0$#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
+0$#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
+0$#if defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
+0$   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
+0$/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
+0$#else
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
+0$#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
+0$#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
+0$    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
+0$    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
+0$#elif \
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
+0$#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
+0$#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
+0$    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
+0$    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
+0$#if defined(__clang__)
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_POP
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
+0$#endif
+0$    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
+0$#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PRAGMA(value)
+0$#else
+0$    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
+0$#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
+0$    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
+0$    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
+0$    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
+0$    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
+0$    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
+0$    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
+0$    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
+0$    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
+0$    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
+0$    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
+0$    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
+0$    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
+0$    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
+0$    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
+0$    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
+0$    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
+0$    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
+0$    defined(__clang__) || \
+0$    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
+0$#if \
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
+0$#if defined(__has_warning)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_WARNING
+0$#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
+0$#if defined(__has_warning)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_WARNING
+0$#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
+0$#if defined(__has_warning)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_WARNING
+0$#if defined(JSON_HEDLEY_HAS_WARNING)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
+0$#if defined(__has_declspec_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
+0$#if defined(__has_declspec_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
+0$#if defined(__has_declspec_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
+0$#if defined(__has_extension)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
+0$#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
+0$#if defined(__has_extension)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
+0$#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
+0$#if defined(__has_extension)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_EXTENSION
+0$#if defined(JSON_HEDLEY_HAS_EXTENSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
+0$#if defined(__has_feature)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_FEATURE
+0$#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
+0$#if defined(__has_feature)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
+0$#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
+0$#if defined(__has_feature)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_FEATURE
+0$#if defined(JSON_HEDLEY_HAS_FEATURE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
+0$#if defined(__has_builtin)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
+0$#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
+0$#if defined(__has_builtin)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
+0$#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
+0$#if defined(__has_builtin)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_BUILTIN
+0$#if defined(JSON_HEDLEY_HAS_BUILTIN)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
+0$#if defined(__has_cpp_attribute) && defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
+0$#if defined(__has_cpp_attribute) && defined(__cplusplus)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
+0$    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
+0$    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
+0$    !defined(JSON_HEDLEY_IAR_VERSION) && \
+0$    !defined(JSON_HEDLEY_PGI_VERSION) && \
+0$#elif \
+0$    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
+0$#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
+0$#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
+0$#else
+0$    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
+0$    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
+0$    defined(__cplusplus) && \
+0$    defined(__has_cpp_attribute) && \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
+0$#if defined(__has_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
+0$#if defined(__has_attribute)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
+0$
+0$#endif
+0$#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
+0$#else
+0$#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
+0$  )
+0$    (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
+0$  ( \
+0$  defined(__has_attribute) && \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_HAS_ATTRIBUTE
+0$#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_GCC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
+0$    !defined(JSON_HEDLEY_MCST_LCC_VERSION)
+0$    !defined(__COMPCERT__) && \
+0$    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
+0$    !defined(JSON_HEDLEY_TI_VERSION) && \
+0$    !defined(JSON_HEDLEY_CRAY_VERSION) && \
+0$    !defined(JSON_HEDLEY_ARM_VERSION) && \
+0$    !defined(JSON_HEDLEY_PGI_VERSION) && \
+0$    !defined(JSON_HEDLEY_INTEL_VERSION) && \
+0$    !defined(__clang__) && \
+0$    defined(JSON_HEDLEY_GNUC_VERSION) && \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_GCC_VERSION
+0$#if defined(JSON_HEDLEY_GCC_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
+0$#if defined(__LCC__) && defined(__LCC_MINOR__)
+0$#endif
+0$    #undef JSON_HEDLEY_MCST_LCC_VERSION
+0$#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_PELLES_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
+0$#if defined(__POCC__)
+0$#endif
+0$    #undef JSON_HEDLEY_PELLES_VERSION
+0$#if defined(JSON_HEDLEY_PELLES_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_COMPCERT_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
+0$#if defined(__COMPCERT_VERSION__)
+0$#endif
+0$    #undef JSON_HEDLEY_COMPCERT_VERSION
+0$#if defined(JSON_HEDLEY_COMPCERT_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_DMC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_DMC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
+0$#if defined(__DMC__)
+0$#endif
+0$    #undef JSON_HEDLEY_DMC_VERSION
+0$#if defined(JSON_HEDLEY_DMC_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TINYC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
+0$#if defined(__TINYC__)
+0$#endif
+0$    #undef JSON_HEDLEY_TINYC_VERSION
+0$#if defined(JSON_HEDLEY_TINYC_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_IAR_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_IAR_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
+0$
+0$#endif
+0$    #endif
+0$        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
+0$    #else
+0$        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
+0$    #if __VER__ > 1000
+0$#if defined(__IAR_SYSTEMS_ICC__)
+0$#endif
+0$    #undef JSON_HEDLEY_IAR_VERSION
+0$#if defined(JSON_HEDLEY_IAR_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_CRAY_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
+0$
+0$#endif
+0$    #endif
+0$        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
+0$    #else
+0$        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
+0$    #if defined(_RELEASE_PATCHLEVEL)
+0$#if defined(_CRAYC)
+0$#endif
+0$    #undef JSON_HEDLEY_CRAY_VERSION
+0$#if defined(JSON_HEDLEY_CRAY_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CLPRU_VERSION
+0$#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL7X_VERSION
+0$#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL6X_VERSION
+0$#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
+0$#endif
+0$    #undef JSON_HEDLEY_TI_ARMCL_VERSION
+0$#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_CL430_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL430_VERSION
+0$#if defined(JSON_HEDLEY_TI_CL430_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_CL2000_VERSION
+0$#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_TI_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_TI_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
+0$
+0$#endif
+0$#endif
+0$    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
+0$#if (__TI_COMPILER_VERSION__ >= 16000000)
+0$    )
+0$      defined(__TMS320C2000__) \
+0$      defined(__MSP430__) || \
+0$      defined(__TMS470__) || defined(__TI_ARM__) || \
+0$    ( \
+0$    defined(__TI_COMPILER_VERSION__) && \
+0$#if \
+0$#endif
+0$    #undef JSON_HEDLEY_TI_VERSION
+0$#if defined(JSON_HEDLEY_TI_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_IBM_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_IBM_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
+0$#elif defined(__xlC__)
+0$    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
+0$#elif defined(__xlC__) && defined(__xlC_ver__)
+0$    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
+0$#if defined(__ibmxl__)
+0$#endif
+0$    #undef JSON_HEDLEY_IBM_VERSION
+0$#if defined(JSON_HEDLEY_IBM_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_ARM_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_ARM_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
+0$#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
+0$    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
+0$#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_ARM_VERSION
+0$#if defined(JSON_HEDLEY_ARM_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
+0$#if defined(__EMSCRIPTEN__)
+0$#endif
+0$    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
+0$#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_SUNPRO_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
+0$#elif defined(__SUNPRO_CC)
+0$    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
+0$#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
+0$    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
+0$#elif defined(__SUNPRO_C)
+0$    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
+0$#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
+0$#endif
+0$    #undef JSON_HEDLEY_SUNPRO_VERSION
+0$#if defined(JSON_HEDLEY_SUNPRO_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_PGI_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_PGI_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
+0$#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
+0$#endif
+0$    #undef JSON_HEDLEY_PGI_VERSION
+0$#if defined(JSON_HEDLEY_PGI_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
+0$#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
+0$#endif
+0$    #undef JSON_HEDLEY_INTEL_CL_VERSION
+0$#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_INTEL_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
+0$#elif defined(__INTEL_COMPILER) && !defined(__ICL)
+0$    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
+0$#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
+0$#endif
+0$    #undef JSON_HEDLEY_INTEL_VERSION
+0$#if defined(JSON_HEDLEY_INTEL_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
+0$#else
+0$    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
+0$#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
+0$    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
+0$#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
+0$    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
+0$#if !defined(JSON_HEDLEY_MSVC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
+0$#elif defined(_MSC_VER) && !defined(__ICL)
+0$    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
+0$#elif defined(_MSC_FULL_VER) && !defined(__ICL)
+0$    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
+0$#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
+0$#endif
+0$    #undef JSON_HEDLEY_MSVC_VERSION
+0$#if defined(JSON_HEDLEY_MSVC_VERSION)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
+0$#else
+0$    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
+0$#if defined(JSON_HEDLEY_GNUC_VERSION)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
+0$#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
+0$
+0$#endif
+0$    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
+0$#elif defined(__GNUC__)
+0$    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
+0$#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
+0$#endif
+0$    #undef JSON_HEDLEY_GNUC_VERSION
+0$#if defined(JSON_HEDLEY_GNUC_VERSION)
+0$
+0$#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
+0$#endif
+0$    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
+0$#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
+0$
+0$#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
+0$#endif
+0$    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
+0$#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
+0$
+0$#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
+0$#endif
+0$    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
+0$#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
+0$
+0$#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))
+0$#endif
+0$    #undef JSON_HEDLEY_VERSION_ENCODE
+0$#if defined(JSON_HEDLEY_VERSION_ENCODE)
+0$
+0$#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)
+0$#endif
+0$    #undef JSON_HEDLEY_CONCAT3
+0$#if defined(JSON_HEDLEY_CONCAT3)
+0$
+0$#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c
+0$#endif
+0$    #undef JSON_HEDLEY_CONCAT3_EX
+0$#if defined(JSON_HEDLEY_CONCAT3_EX)
+0$
+0$#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)
+0$#endif
+0$    #undef JSON_HEDLEY_CONCAT
+0$#if defined(JSON_HEDLEY_CONCAT)
+0$
+0$#define JSON_HEDLEY_CONCAT_EX(a,b) a##b
+0$#endif
+0$    #undef JSON_HEDLEY_CONCAT_EX
+0$#if defined(JSON_HEDLEY_CONCAT_EX)
+0$
+0$#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)
+0$#endif
+0$    #undef JSON_HEDLEY_STRINGIFY
+0$#if defined(JSON_HEDLEY_STRINGIFY)
+0$
+0$#define JSON_HEDLEY_STRINGIFY_EX(x) #x
+0$#endif
+0$    #undef JSON_HEDLEY_STRINGIFY_EX
+0$#if defined(JSON_HEDLEY_STRINGIFY_EX)
+0$
+0$#define JSON_HEDLEY_VERSION 15
+0$#endif
+0$    #undef JSON_HEDLEY_VERSION
+0$#if defined(JSON_HEDLEY_VERSION)
+0$#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
+0$
+0$ */
+0$ * Created by Evan Nemerson <evan@nemerson.com>
+0$/* Hedley - https://nemequ.github.io/hedley
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2016-2021 Evan Nemerson <evan@nemerson.com>
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$
+0$
+0$// #include <nlohmann/thirdparty/hedley/hedley.hpp>
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$    std::is_convertible<detected_t<Op, Args...>, To>;
+0$using is_detected_convertible =
+0$template<class To, template<class...> class Op, class... Args>
+0$
+0$using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;
+0$template<class Expected, template<class...> class Op, class... Args>
+0$
+0$using detected_or_t = typename detected_or<Default, Op, Args...>::type;
+0$template<class Default, template<class...> class Op, class... Args>
+0$
+0$using detected_or = detector<Default, void, Op, Args...>;
+0$template<class Default, template<class...> class Op, class... Args>
+0$
+0$using detected_t = typename detector<nonesuch, void, Op, Args...>::type;
+0$template<template<class...> class Op, class... Args>
+0$
+0$struct is_detected_lazy : is_detected<Op, Args...> { };
+0$template<template<class...> class Op, class... Args>
+0$
+0$using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;
+0$template<template<class...> class Op, class... Args>
+0$
+0$};
+0$    using type = Op<Args...>;
+0$    using value_t = std::true_type;
+0${
+0$struct detector<Default, void_t<Op<Args...>>, Op, Args...>
+0$template<class Default, template<class...> class Op, class... Args>
+0$
+0$};
+0$    using type = Default;
+0$    using value_t = std::false_type;
+0${
+0$struct detector
+0$         class... Args>
+0$         template<class...> class Op,
+0$         class AlwaysVoid,
+0$template<class Default,
+0$
+0$};
+0$    void operator=(nonesuch&&) = delete;
+0$    void operator=(nonesuch const&) = delete;
+0$    nonesuch(nonesuch const&&) = delete;
+0$    nonesuch(nonesuch const&) = delete;
+0$    ~nonesuch() = delete;
+0$    nonesuch() = delete;
+0${
+0$struct nonesuch
+0$// https://en.cppreference.com/w/cpp/experimental/is_detected
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$NLOHMANN_JSON_NAMESPACE_END
+0$}  // namespace detail
+0$
+0$template<typename ...Ts> using void_t = typename make_void<Ts...>::type;
+0$};
+0$    using type = void;
+0${
+0$template<typename ...Ts> struct make_void
+0$
+0${
+0$namespace detail
+0$NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/void_t.hpp>
+0$
+0$#include <type_traits>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/meta/detected.hpp>
+0$#include <utility> // declval, pair
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/macro_scope.hpp>
+0$
+0$#include <string> // string
+0$#include <cstdint> // uint8_t
+0$#include <cstddef> // size_t
+0$#include <array> // array
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/value_t.hpp>
+0$
+0$#include <vector> // vector
+0$#include <string> // to_string
+0$#include <stdexcept> // runtime_error
+0$#endif
+0$    #include <numeric> // accumulate
+0$#if JSON_DIAGNOSTICS
+0$#include <exception> // exception
+0$#include <cstddef> // nullptr_t
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/exceptions.hpp>
+0$
+0$#include <valarray> // valarray
+0$#include <utility> // pair, declval
+0$#include <unordered_map> // unordered_map
+0$#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
+0$#include <tuple> // tuple, make_tuple
+0$#include <string> // string
+0$#include <map> // map
+0$#include <iterator> // inserter, front_inserter, end
+0$#include <forward_list> // forward_list
+0$#include <array> // array
+0$#include <algorithm> // transform
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/conversions/from_json.hpp>
+0$
+0$#endif
+0$    }  // namespace nlohmann
+0$    }  /* namespace (inline namespace) NOLINT(readability/namespace) */ \
+0$#define NLOHMANN_JSON_NAMESPACE_END                                     \
+0$#ifndef NLOHMANN_JSON_NAMESPACE_END
+0$
+0$#endif
+0$    {
+0$                NLOHMANN_JSON_NAMESPACE_VERSION)     \
+0$                NLOHMANN_JSON_ABI_TAGS,              \
+0$    inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
+0$    {                                                \
+0$    namespace nlohmann                               \
+0$#define NLOHMANN_JSON_NAMESPACE_BEGIN                \
+0$#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
+0$
+0$#endif
+0$            NLOHMANN_JSON_NAMESPACE_VERSION)
+0$            NLOHMANN_JSON_ABI_TAGS,           \
+0$    nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
+0$#define NLOHMANN_JSON_NAMESPACE               \
+0$#ifndef NLOHMANN_JSON_NAMESPACE
+0$
+0$    NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)
+0$#define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
+0$#define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
+0$// Combine namespace components
+0$
+0$#endif
+0$                                           NLOHMANN_JSON_VERSION_PATCH)
+0$                                           NLOHMANN_JSON_VERSION_MINOR, \
+0$    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
+0$#define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
+0$#else
+0$#define NLOHMANN_JSON_NAMESPACE_VERSION
+0$#if NLOHMANN_JSON_NAMESPACE_NO_VERSION
+0$
+0$    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)
+0$#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
+0$    _v ## major ## _ ## minor ## _ ## patch
+0$#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
+0$// Construct the namespace version component
+0$
+0$            NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON)
+0$            NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
+0$    NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
+0$#define NLOHMANN_JSON_ABI_TAGS                                       \
+0$
+0$    NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b)
+0$#define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b) \
+0$#define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b) json_abi ## a ## b
+0$// Construct the namespace ABI tags component
+0$
+0$#endif
+0$    #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
+0$#ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
+0$
+0$#endif
+0$    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
+0$#else
+0$    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
+0$#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
+0$
+0$#endif
+0$    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
+0$#else
+0$    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
+0$#if JSON_DIAGNOSTICS
+0$
+0$#endif
+0$    #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
+0$#ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
+0$
+0$#endif
+0$    #define JSON_DIAGNOSTICS 0
+0$#ifndef JSON_DIAGNOSTICS
+0$
+0$#define NLOHMANN_JSON_VERSION_PATCH 3   // NOLINT(modernize-macro-to-enum)
+0$#define NLOHMANN_JSON_VERSION_MINOR 11  // NOLINT(modernize-macro-to-enum)
+0$#define NLOHMANN_JSON_VERSION_MAJOR 3   // NOLINT(modernize-macro-to-enum)
+0$
+0$#endif
+0$    #endif
+0$        #endif
+0$            #warning "Already included a different version of the library!"
+0$        #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 11 || NLOHMANN_JSON_VERSION_PATCH != 3
+0$    #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
+0$#ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
+0$
+0$// This file contains all macro definitions affecting or depending on the ABI
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/detail/abi_macros.hpp>
+0$
+0$#include <utility>
+0$
+0$
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
+0$// #include <nlohmann/adl_serializer.hpp>
+0$
+0$#include <vector> // vector
+0$#include <utility> // declval, forward, move, pair, swap
+0$#include <string> // string, stoi, to_string
+0$#include <memory> // unique_ptr
+0$#include <iterator> // random_access_iterator_tag
+0$#endif  // JSON_NO_IO
+0$    #include <iosfwd> // istream, ostream
+0$#ifndef JSON_NO_IO
+0$#include <initializer_list> // initializer_list
+0$#include <functional> // hash, less
+0$#include <cstddef> // nullptr_t, ptrdiff_t, size_t
+0$#include <algorithm> // all_of, find, for_each
+0$
+0$#define INCLUDE_NLOHMANN_JSON_HPP_
+0$#ifndef INCLUDE_NLOHMANN_JSON_HPP_
+0$
+0$\****************************************************************************/
+0$ * file docs/README.md.                                                     *
+0$ * removed, but marked deprecated. See "Generate documentation" section in  *
+0$ * previous versions; documentation for deprecated functions is not         *
+0$ * contains the most recent documentation and should also be applicable to  *
+0$ * documentation of the public API at https://json.nlohmann.me. This URL    *
+0$ * Note on documentation: The source files contain links to the online      *
+0$/****************************************************************************\
+0$
+0$// SPDX-License-Identifier: MIT
+0$// SPDX-FileCopyrightText: 2013-2023 Niels Lohmann <https://nlohmann.me>
+0$//
+0$// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
+0$// |  |  |__   |  |  | | | |  version 3.11.3
+0$//  __|  |   __|     |   | |  JSON for Modern C++
+0$//     __ _____ _____ _____
