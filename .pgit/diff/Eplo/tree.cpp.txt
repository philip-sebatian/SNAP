+0$}
+0$   
+0$
+0$    //xcgvhbjknlm,
+0$    tree.snapshot("Eplo");
+0$    std::shared_ptr<Treeobject> head = std::make_shared<Treeobject>(tree);
+0$    Treeobject tree = Treeobject::from_json(tree_json);
+0$    file.close();
+0$    // Close the file
+0$
+0$    file >> tree_json;
+0$    std::ifstream file((fs::current_path()/fs::path(".pgit")/fs::path("tree.json")).string());
+0$    json tree_json;
+0$    //esrtdfyguhlkj;,
+0$    //sadjh
+0$    }*/
+0$        return 1; // Return error code
+0$        std::cerr << "Unable to open file for writing." << std::endl;
+0$    } else {
+0$        std::cout << "JSON data written to file successfully." << std::endl;
+0$        file.close();
+0$        file << tree_json.dump(4); // Write formatted JSON to file
+0$    if (file.is_open()) {
+0$    std::ofstream file("tree.json");
+0$    // Output JSON string
+0$    json tree_json = tee.to_json();
+0$   
+0$   
+0$   
+0$   // auto  i =get_content("/home/ubuntu/cppgit/v-control/.diff/noob/diff.cpp.txt");
+0$   
+0$    
+0$    
+0$    
+0$    /*Treeobject tee = Treeobject("hello");
+0$int main(){
+0$
+0$
+0$
+0$
+0$}
+0$    
+0$    
+0$
+0$    }
+0$        }
+0$            }
+0$                traverse_make_tree_obj(entry.path(),tee);
+0$            if(entry.path().filename().string()[0]!='.'){
+0$        if(fs::is_directory(entry)){
+0$        tee.insert_blob(entry.path());
+0$
+0$        if(fs::is_regular_file(entry))
+0$        std::cout<<entry.path()<<std::endl;
+0$    for (const auto& entry : fs::directory_iterator(root)) {
+0$    
+0$void traverse_make_tree_obj(const fs::path& root,Treeobject &tee) {
+0$
+0$};
+0$
+0$
+0$    }
+0$
+0$
+0$        file.close();
+0$        file << tree_json.dump(4); // Write formatted JSON to file
+0$        std::ofstream file((fs::current_path()/fs::path(".pgit")/fs::path("tree.json")).string());
+0$        auto tree_json = this->to_json();
+0$        curr->next->traverse_make_tree_obj(fs::current_path());
+0$        curr->next=std::make_shared<Treeobject>(Treeobject(name));
+0$        }
+0$            curr=curr->next;
+0$            curr->make_fs();
+0$        while(curr->next!=nullptr){
+0$        auto curr = std::make_shared<Treeobject>(*this);
+0$        void snapshot(std::string name ){
+0$}
+0$    
+0$    
+0$    }
+0$        }
+0$            }
+0$                traverse_make_tree_obj(entry.path());
+0$            if(entry.path().filename().string()[0]!='.'){
+0$        if(fs::is_directory(entry)){
+0$        insert_blob(entry.path());
+0$
+0$        if(fs::is_regular_file(entry))
+0$        std::cout<<entry.path()<<std::endl;
+0$    for (const auto& entry : fs::directory_iterator(root)) {
+0$    
+0$    void traverse_make_tree_obj(const fs::path& root) {
+0$
+0$        }
+0$            }
+0$                
+0$                
+0$                write_vector(vec,fs::current_path()/fs::path(".pgit")/fs::path("stage")/i.filepath);
+0$                std::cout<<"size="<<vec.size()<<std::endl;
+0$                auto vec =get_vector_from_delta(i.filepath.filename());
+0$                std::cout<<i.filepath<<std::endl;
+0$            for(auto i : fb){
+0$            create_change(fs_set,fs::current_path()/fs::path(".pgit")/fs::path("stage"));
+0$            auto fs_set =get_fs(fs::current_path()/fs::path(".pgit")/ fs::path("file")/fs::path(this->commit_name+".txt"));
+0$        void make_fs(){
+0$        }
+0$            fb.insert(file_blob(fs::relative(f_path,fs::current_path()),diff_base/fs::path(f_path.filename().string()+".txt")));
+0$            
+0$            write_delta_from_file_name(stage_file,f_path,diff_base/fs::path(""+f_path.filename().string()+""".txt"));
+0$            
+0$            write_fs_delta(file_struct_path/fs::path(this->commit_name+".txt"));
+0$            fs::path file_struct_path=fs::current_path()/fs::path(".pgit")/fs::path("file");
+0$            }
+0$                fs::create_directories(diff_base);
+0$            if(!fs::exists(diff_base)){
+0$            fs::path diff_base=fs::current_path()/fs::path(".pgit")/fs::path("diff")/fs::path(this->commit_name);
+0$            std::cout<<"ssssssssssssssssssss =="<<stage_file<<std::endl;
+0$            
+0$            
+0$            std::string stage_file= stage_path /fs::relative(f_path,fs::current_path());
+0$            std::cout<<"biasbiabsdasdnskad=------"<<stage_path /fs::relative(f_path, fs::current_path())<<std::endl;
+0$            std::string stage_path=fs::current_path()/fs::path(".pgit")/fs::path("stage");//this acts as base to the stage file change it 
+0$        void insert_blob(fs::path f_path){
+0$        }
+0$            ff.close();
+0$            }
+0$                ff<<(i+"\n");
+0$            for(auto i :cont){
+0$            ff.open(f_path,std::ios::out|std::ios::trunc);
+0$            
+0$            std:: fstream ff ;
+0$
+0$        void write_vector(std::vector<std::string> cont,fs::path f_path){
+0$        }
+0$            
+0$            
+0$            return content;
+0$            std::cout<<"////////////////////////////"<<content.size()<<"poooop"<<std::endl;
+0$            }
+0$                }
+0$                    content.erase(content.begin()+std::stoi(temp));
+0$                else{
+0$                }
+0$                    content.insert(content.begin()+std::stoi(temp),i.substr(j));
+0$
+0$                if(i[0]=='+'){
+0$                j++;
+0$                }
+0$                    j++;
+0$                    temp+=i[j];
+0$                while(i[j]!='$'){
+0$                std::string temp="";
+0$                int j =1;
+0$            for(auto i : delta){
+0$            std::cout<<content.size()<<std::endl;
+0$            std::cout<<"cccccc "<<diff_base/fs::path(f_path.string()+".txt")<<std::endl;
+0$            auto delta=get_content(diff_base/fs::path(f_path.string()+".txt"));
+0$            fs::path diff_base=fs::current_path()/fs::path(".pgit")/fs::path("diff")/fs::path(this->commit_name);
+0$            std::cout<<stage_base/f_path<<std::endl;
+0$            std::cout<<"////////////////////////////"<<content.size()<<std::endl;
+0$            auto content=get_content(stage_base/f_path);
+0$            fs::path stage_base=fs::current_path()/fs::path(".pgit")/fs::path("stage");
+0$        std::vector<std::string> get_vector_from_delta(fs::path f_path){
+0$        //f_path path to relative
+0$
+0$    }
+0$            return tree;
+0$
+0$            }
+0$                tree.prev = std::make_shared<Treeobject>(Treeobject::from_json(j.at("prev")));
+0$            if (j.find("prev") != j.end()) {
+0$            // Deserialize prev if it exists
+0$
+0$            }
+0$                tree.next = std::make_shared<Treeobject>(Treeobject::from_json(j.at("next")));
+0$            if (j.find("next") != j.end()) {
+0$            // Deserialize next if it exists
+0$
+0$            }
+0$                tree.fb.insert(file_blob::from_json(blob_json));
+0$            for (const auto& blob_json : j.at("fb")) {
+0$            // Deserialize set of file_blob objects from JSON array
+0$
+0$            Treeobject tree(commit_name);
+0$            std::string commit_name = j.at("commit_name").get<std::string>();
+0$    // Extract data from JSON and construct Treeobject instance
+0$        static Treeobject from_json(const json& j) {
+0$    // Deserialization from JSON
+0$
+0$
+0$
+0$
+0$}
+0$    return j;
+0$    }
+0$        j["prev"] = prev->to_json();
+0$    if (prev != nullptr) {
+0$    // Serialize prev if it exists
+0$    }
+0$        j["next"] = (next)->to_json();
+0$    if (next != nullptr) {
+0$    // Serialize next if it exists
+0$    }
+0$        j["fb"].push_back(blob.to_json());
+0$    for (const auto& blob : fb) {
+0$    // Serialize set of file_blob objects into JSON array
+0$    j["commit_name"] = commit_name;
+0$    // Serialize Treeobject members into JSON
+0$    json j;
+0$       json to_json() const {
+0$        }
+0$
+0$            
+0$            this->prev=nullptr;
+0$            this->next =nullptr;
+0$            this->commit_name=commit_name;
+0$            
+0$        Treeobject(std::string commit_name ){
+0$
+0$        std:: shared_ptr<Treeobject> prev=nullptr;
+0$        std:: shared_ptr<Treeobject> next=nullptr;
+0$        std::string commit_name;
+0$        std::set<file_blob> fb;
+0$       
+0$    public: 
+0$class Treeobject{
+0$
+0$};
+0$
+0$    }
+0$        return file_blob(filepath_str, f_name);
+0$        std::string f_name = j.at("f_name").get<std::string>();
+0$        std::string filepath_str = j.at("filepath").get<std::string>();
+0$        // Extract data from JSON and construct file_blob instance
+0$     static file_blob from_json(const json& j) {
+0$    }
+0$        return j;
+0$        j["f_name"] = f_name;
+0$        j["filepath"] = filepath.string();
+0$        // Serialize file_blob members into JSON
+0$        json j;
+0$        json to_json() const {
+0$    }
+0$        return filepath < other.filepath;
+0$        bool operator<(const file_blob& other) const {
+0$        }
+0$            
+0$            this->f_name=f_name;
+0$            this->filepath=f_path;
+0$        file_blob(std::string f_path,std::string f_name){
+0$        std:: string f_name ;
+0$        fs::path filepath;
+0$    public:
+0$class file_blob{
+0$
+0$using json = nlohmann::json;
+0$
+0$#include "json.hpp"
+0$#include "diff.cpp"
+0$#include <fstream>
+0$#include<bits/stdc++.h>
